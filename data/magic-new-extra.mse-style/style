mse version: 2.0.0
game: magic
short name: Modern Extra
full name: Modern w/ Extra Colors
installer group: magic/new style/extra colors
icon: card-sample.png
position hint: 250

version: 2016-01-05
depends on:
	package: magic.mse-game
	version: 2015-04-08
depends on:
	package: magic-default-image.mse-include
	version: 2007-09-23
depends on:
	package: magic-future-common.mse-include
	version: 2008-05-21
depends on:
	package: magic-watermarks-extra.mse-include
	version: 2007-12-22
depends on:
	package: magic-watermarks.mse-include
	version: 2007-09-29
depends on:
	package: magic-mana-large-extra.mse-symbol-font
	version: 2009-03-23
depends on:
	package: magic-mana-small-extra.mse-symbol-font
	version: 2009-03-23
depends on:
	package: magic-mana-large.mse-symbol-font
	version: 2007-10-12
depends on:
	package: magic-mana-small.mse-symbol-font
	version: 2007-10-12
depends on:
	package: magic-new.mse-style
	version: 2008-04-13
depends on:
	package: magic-pt-symbols-extra.mse-symbol-font
	version: 2009-09-25

card width: 375
card height: 523
card dpi: 150
#By Pichoro
#New Features:
#Unsorted casting costs.
############################################################## Extra scripts
init script:
	############################################################################################################ Proper Style Scripts
	# Load scripts for image box
	include file: /magic-default-image.mse-include/scripts
	
	# Should hybrids have a grey name?
	mask_hybrid_with_land := { styling.grey_hybrid_name }
	
	#Should multicolor lands with basic land types have a colored name?
	mask_multi_land_with_color := { styling.colored_multicolor_land_name }
	
	# Get frames from magic-new when possible.
	magic_new_router := {
		if type == "identity" then ""
		else if input == "a" or input == "m" or input == "w" or input == "u" or input == "b" or input == "r" or input == "g" or input == "c" then "/magic-new.mse-style/"
		else ""
	}
	magic_new_land_router := {
		if type == "identity" then ""
		else if input == "a" or input == "s" or input == "m" or input == "w" or input == "u" or input == "b" or input == "r" or input == "g" or input == "c" then "/magic-new.mse-style/"
		else ""
	}
	# Which artifact template should be used?  Which multicolor template should be used?
	alternate_template := {
		if input == "a" then (
			if       styling.artifact_style == "light" then "oa"
			else if  styling.artifact_style == "brown" then "ba"
			else                                            "a"
		) else if input == "m" then (
			if styling.saturated_multicolor then "m"
			else "om"
		) else input
	}
	template_suffix := [card: "card.jpg", pt: "pt.jpg", identity: "identity.png"]
	template      := { magic_new_router() + alternate_template() + template_suffix[type] }
	land_template := { magic_new_land_router() + (if input == "a" or input == "s" then "c" else alternate_template()) + "l" + template_suffix[type] }
	# Use land templates for previews because they show more contrast
	hybrid_previews := "land,hybrid"
	
	# Use the normal tap symbol
	mana_t := {
		if      styling.tap_symbol == "old"        then "old"
		else if styling.tap_symbol == "diagonal T" then "older"
		else                                            "new"
	}
	
	# Use guild mana symbols?
	guild_mana := { styling.use_guild_mana_symbols }
	
	# Should the artist paintbrush be black or white?
	paintbrush_color := {
		if to_int(styling.artist_font_color) < 96 then "black" else "white"
	}
	
	# Should the extra value default to treasure, poison, or neither?
	default_value_box := {
		if contains(card.sub_type, match:"Treasure") then "treasure"
		else if contains(card.rule_text, match:"oisonous ") then "poison"
		else "none"
	}
	
	# Filter to commas, so they can be counted to see if field is complete
	comma_count := filter_text@(match:",")
	
	# Should the card have a color indicator?
	has_identity := { styling.color_indicator }
	
	############################################################################################################ Scripts from Blends Package
	## Scripts being overwritten from /magic-blends.mse-include/new-blends
	overlay_hybrid := [
		1: { template(colors[0]) }
		2: { combine_blend(
			image1: template(colors[0]),
			image2: template(colors[1]),
			combine: styling.overlay_hybrid_type
		   )}
	]
	
	horizontal_card_hybrid := [
		1: { template(colors[0]) }
		2: card_hybrid_2
		3: {linear_blend(
			image1: template(colors[0])
			x1: 0.22,  y1: 0
			x2: 0.4,   y2: 0
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 0.6,   y1: 0
			  x2: 0.78,  y2: 0
			  image2: template(colors[2])
		   ))}
		4: {linear_blend(
			# blend = 0.16
			image1: template(colors[0])
			x1: 0.15,  y1: 0
			x2: 0.31,  y2: 0
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 0.42,  y1: 0
			  x2: 0.58,  y2: 0
			  image2: linear_blend(
			    image1: template(colors[2])
			    x1: 0.69, y1: 0
			    x2: 0.85, y2: 0
			    image2: template(colors[3])
		   )))}
		5: {linear_blend(
			image1: template(colors[0])
			x1: 2.0 / 15,  y1: 0
			x2: 4.0 / 15,  y2: 0
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 5.0 / 15,  y1: 0
			  x2: 7.0 / 15,  y2: 0
			  image2: linear_blend(
			    image1: template(colors[2])
			    x1:  8.0 / 15,  y1: 0
			    x2: 10.0 / 15,  y2: 0
			    image2: linear_blend(
			      image1: template(colors[3])
			      x1: 11.0 / 15,  y1: 0
			      x2: 13.0 / 15,  y2: 0
			      image2: template(colors[4])
		   ))))}
		6: {linear_blend(
			image1: template(colors[0])
			x1: 1.5 / 15,  y1: 0
			x2: 3.1 / 15,  y2: 0
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 4.1 / 15,  y1: 0
			  x2: 5.7 / 15,  y2: 0
			  image2: linear_blend(
			    image1: template(colors[2])
			    x1: 6.7 / 15,  y1: 0
			    x2: 8.3 / 15,  y2: 0
			    image2: linear_blend(
			      image1: template(colors[3])
			      x1: 9.3 / 15,  y1: 0
			      x2: 10.9 / 15,  y2: 0
			      image2: linear_blend(
			        image1: template(colors[4])
			        x1: 11.9 / 15, y1: 0
			        x2: 13.5 / 15, y2: 0
			        image2: template(colors[5])
		   )))))}
		7: {linear_blend(
			image1: template(colors[0])
			x1: 1.3 / 15,  y1: 0
			x2: 2.7 / 15,  y2: 0
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 3.5 / 15,  y1: 0
			  x2: 4.9 / 15,  y2: 0
			  image2: linear_blend(
			    image1: template(colors[2])
			    x1: 5.7 / 15,  y1: 0
			    x2: 7.1 / 15,  y2: 0
			    image2: linear_blend(
			      image1: template(colors[3])
			      x1: 7.9 / 15,  y1: 0
			      x2: 9.3 / 15,  y2: 0
			      image2: linear_blend(
			        image1: template(colors[4])
			        x1: 10.1 / 15, y1: 0
			        x2: 11.5 / 15, y2: 0
			        image2: linear_blend(
			          image1: template(colors[5])
			          x1: 12.3 / 15, y1: 0
			          x2: 13.7 / 15, y2: 0
			          image2: template(colors[6])
		   ))))))}
		8: { template("m") }
		9: { template("m") }
		10: { template("m") }
		11: { template("m") }
		12: { template("m") }
	]
	
	diagonal_card_hybrid := [
		1: { template(colors[0]) }
		2: {linear_blend(
			image1: template(colors[0]),
			image2: template(colors[1]),
			x1: 0.40, y1: 0.50
			x2: 0.60, y2: 0.60
		   )}
		3: {linear_blend(
			image1: linear_blend(
				image1: template(colors[0]),
				image2: template(colors[1]),
				x1: 0.15, y1: 0.50
				x2: 0.35, y2: 0.60),
			image2: template(colors[2]),
				x1: 0.65, y1: 0.50
				x2: 0.85, y2: 0.60
		   )}
		4: { linear_blend(
			image1: linear_blend(
				image1: template(colors[0]),
				image2: template(colors[1]),
				x1: -0.10, y1: 0.50
				x2: 0.10, y2: 0.60),
			image2: linear_blend(
				image1: template(colors[2]),
				image2: template(colors[3]),
				x1: 0.90, y1: 0.50
				x2: 1.10, y2: 0.60),
			x1: 0.40, y1: 0.50
			x2: 0.60, y2: 0.60
		   )}
		5: {linear_blend(
			image1: linear_blend(
				image1: linear_blend(
					image1: linear_blend(
						image1: template(colors[0]),
						image2: template(colors[1]),
						x1: -0.20, y1: 0.50
						x2: 0.00, y2: 0.60),
					image2: template(colors[2]),
					x1: 0.15, y1: 0.50
					x2: 0.35, y2: 0.60),
				image2: template(colors[3]),
				x1: 0.65, y1: 0.50
				x2: 0.85, y2: 0.60),
			image2: template(colors[4]),
			x1: 1.00, y1: 0.50
			x2: 1.20, y2: 0.60
		   )}
		6: {linear_blend(
			image1: linear_blend(
				image1: linear_blend(
					image1: linear_blend(
						image1: linear_blend(
							image1: template(colors[0]),
							image2: template(colors[1]),
							x1: -0.30, y1: 0.50
							x2: -0.10, y2: 0.60),
						image2: template(colors[2]),
						x1: 0.10, y1: 0.50
						x2: 0.20, y2: 0.60),
					image2: template(colors[3]),
					x1: 0.40, y1: 0.50
					x2: 0.60, y2: 0.60),
				image2: template(colors[4]),
				x1: 0.70, y1: 0.50
				x2: 0.90, y2: 0.60),
			image2: template(colors[5]),
			x1: 1.10, y1: 0.50
			x2: 1.30, y2: 0.60
		   )}
		7: { template("m") }
		8: { template("m") }
		9: { template("m") }
		10: { template("m") }
		11: { template("m") }
		12: { template("m") }
	]
	
	card_hybrid := [
		radial: [
			0: { template("c") }
			1: { template(colors[0]) }
			2: card_hybrid_2
			3: {linear_blend(
				image1: card_hybrid_2(colors: colors[0] + colors[1]),
				image2: template(colors[2]),
				x1: 0,  y1: 0.55
				x2: 0,  y2: 0.77
			   )}
			4: {linear_blend(
				image1: card_hybrid_2(colors: colors[0] + colors[1])
				image2: card_hybrid_2(colors: colors[3] + colors[2])
				x1: 0,  y1: 0.4
				x2: 0,  y2: 0.62
			   )}
			5: {linear_blend(
				image1: linear_blend(
					image1: card_hybrid_2(colors: colors[0] + colors[1]),
					image2: card_hybrid_2(colors: colors[4] + colors[2]),
					x1: 0,  y1: 0.19
					x2: 0,  y2: 0.35
				),
				image2: template(colors[3]),
				x1: 0,  y1: 0.777
				x2: 0,  y2: 0.937
			   )}
			6: {linear_blend(
				image1: linear_blend(
					image1: card_hybrid_2(colors: colors[0] + colors[1]),
					image2: card_hybrid_2(colors: colors[5] + colors[2]),
					x1: 0,  y1: 0.19
					x2: 0,  y2: 0.35
				),
				image2: card_hybrid_2(colors: colors[4] + colors[3]),
				x1: 0,  y1: 0.777
				x2: 0,  y2: 0.937
			   )}
			7: {linear_blend(
				image1: linear_blend(
					image1: linear_blend(
						image1: card_hybrid_2(colors: colors[0] + colors[1]),
						image2: card_hybrid_2(colors: colors[6] + colors[3]),
						x1: 0,  y1: 0.34
						x2: 0,  y2: 0.50
					),
					image2: card_hybrid_2(colors: colors[5] + colors[3]),
					x1: 0,  y1: 0.877
					x2: 0,  y2: 0.937
				),
				image2: template(colors[4]),
				x1: 0,  y1: 1.140
				x2: 0,  y2: 1.300
			   )}
			8: { template("m") }
			9: { template("m") }
			10: { template("m") }
			11: { template("m") }
			12: { template("m") }
		]
		horizontal: horizontal_card_hybrid
		diagonal: diagonal_card_hybrid
		vertical: [
			1: { template(colors[0]) }
			2: { linear_blend(
				image1: template(colors[0])
				image2: template(colors[1])
				x1: 0,  y1: 0.4
				x2: 0,  y2: 0.6
			   )}
			3: vertical_card_hybrid
			4: vertical_card_hybrid
			5: vertical_card_hybrid
			6: vertical_card_hybrid
			7: vertical_card_hybrid
			8: { template("m") }
			9: { template("m") }
			10: { template("m") }
			11: { template("m") }
			12: { template("m") }
		]
		overlay: overlay_hybrid
	]
	
	horizontal_pt_hybrid := [
		1: { template(colors[0]) }
		2: { template(colors[1]) }
		3: { linear_blend(
			image1: template(colors[1])
			image2: template(colors[2])
			x1: -0.51, y1: 0
			x2:  0.26, y2: 0
		   )}
		4: { linear_blend(
			image1: template(colors[2])
			image2: template(colors[3])
			x1: -0.1,  y1: 0
			x2:  0.6,  y2: 0
		   )}
		5: { linear_blend(
			image1: template(colors[3])
			image2: template(colors[4])
			x1: 0.08,  y1: 0
			x2: 0.65,  y2: 0
		   )}
		6: { linear_blend(
			image1: template(colors[4])
			image2: template(colors[5])
			x1: 0.07, y1: 0
			x2: 0.7, y2: 0
		   )}
		7: {linear_blend(
			image1: linear_blend(
				image1: template(colors[4]),
				image2: template(colors[5]),
				x1: -0.2,  y1: 0
				x2: 0.2,  y2: 0
			),
			image2: template(colors[6]),
			x1: 0.5,  y1: 0
			x2: 0.7,  y2: 0
		   )}
		8: { template("m") }
		9: { template("m") }
		10: { template("m") }
		11: { template("m") }
		12: { template("m") }
	]
	
	diagonal_pt_hybrid := [
		1: { template(colors[0]) }
		2: { template(colors[1]) }
		3: { template(colors[2]) }
		4: { template(colors[3]) }
		5: { linear_blend(
			image1: template(colors[3]),
			image2: template(colors[4]),
			x1: -0.10, y1: 0.50
			x2: 0.10, y2: 0.60
		   )}
		6: { linear_blend(
			image1: template(colors[4]),
			image2: template(colors[5]),
			x1: 0.10, y1: 0.50
			x2: 0.30, y2: 0.60
		   )}
		7: { template("m") }
		8: { template("m") }
		9: { template("m") }
		10: { template("m") }
		11: { template("m") }
		12: { template("m") }
	]
	
	pt_hybrid := [
		radial: [
			0: { template("c")       }
			1: { template(colors[0]) }
			2: { template(colors[1]) }
			3: { template(colors[2]) }
			4: { template(colors[2]) }
			5: { linear_blend(
				image1: template(colors[2])
				image2: template(colors[3])
				x1: 0, y1: -1.5
				x2: 0, y2: 0.7
			   )}
			6: { linear_blend(
				image1: template(colors[2])
				image2: template(colors[3])
				x1: 0, y1: -1.5
				x2: 0, y2: 0.7
			   )}
			7: { template(colors[3]) }
			8: { template("m") }
			9: { template("m") }
			10: { template("m") }
			11: { template("m") }
			12: { template("m") }
		]
		horizontal: horizontal_pt_hybrid
		diagonal: diagonal_pt_hybrid
		vertical: [
			1: { template(colors[0]) }
			2: { template(colors[1]) }
			3: { template(colors[2]) }
			4: { template(colors[3]) }
			5: { template(colors[4]) }
			6: { template(colors[5]) }
			7: { template(colors[6]) }
			8: { template("m") }
			9: { template("m") }
			10: { template("m") }
			11: { template("m") }
			12: { template("m") }
		]
		overlay: overlay_hybrid
	]
	
	identity_horizontal_hybrid := [
		0: { template("c") }
		1: { template(colors[0]) }
		2: { linear_blend(
			image1: template(colors[0])
			image2: template(colors[1])
			x1: 0.49,  y1: 0.49
			x2: 0.5,  y2: 0.5
		   )}
		3: {linear_blend(
			image1: template(colors[0])
			x1: 0.39,  y1: 0.39
			x2: 0.4,   y2: 0.4
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 0.6,   y1: 0.6
			  x2: 0.61,  y2: 0.61
			  image2: template(colors[2])
		   ))}
		4: {linear_blend(
			# blend = 0.16
			image1: template(colors[0])
			x1: 0.29,  y1: 0.29
			x2: 0.3,  y2: 0.3
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 0.49,  y1: 0.49
			  x2: 0.50,  y2: 0.5
			  image2: linear_blend(
			    image1: template(colors[2])
			    x1: 0.69, y1: 0.69
			    x2: 0.7, y2: 0.7
			    image2: template(colors[3])
		   )))}
		5: {linear_blend(
			image1: template(colors[0])
			x1: 0.28,  y1: 0.28
			x2: 0.29,  y2: 0.29
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 0.42,  y1: 0.42
			  x2: 0.43,  y2: 0.43
			  image2: linear_blend(
			    image1: template(colors[2])
			    x1:  0.56,  y1: 0.56
			    x2: 0.57,  y2: 0.57
			    image2: linear_blend(
			      image1: template(colors[3])
			      x1: 0.7,  y1: 0.7
			      x2: 0.71,  y2: 0.71
			      image2: template(colors[4])
		   ))))}
		6: {linear_blend(
			image1: template(colors[0])
			x1: 0.27,  y1: 0.27
			x2: 0.28,  y2: 0.28
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 0.38,  y1: 0.38
			  x2: 0.39,  y2: 0.39
			  image2: linear_blend(
			    image1: template(colors[2])
			    x1: 0.49,  y1: 0.49
			    x2: 0.50,  y2: 0.50
			    image2: linear_blend(
			      image1: template(colors[3])
			      x1: 0.60,  y1: 0.60
			      x2: 0.61,  y2: 0.61
			      image2: linear_blend(
			        image1: template(colors[4])
			        x1: 0.71,  y1: 0.71
			        x2: 0.72,  y2: 0.72
			        image2: template(colors[5])
		   )))))}
		7: {linear_blend(
			image1: template(colors[0])
			x1: 0.27,  y1: 0.27
			x2: 0.28,  y2: 0.28
			image2: linear_blend(
			  image1: template(colors[1])
			  x1: 0.36,  y1: 0.36
			  x2: 0.37,  y2: 0.37
			  image2: linear_blend(
			    image1: template(colors[2])
			    x1: 0.45,  y1: 0.45
			    x2: 0.46,  y2: 0.46
			    image2: linear_blend(
			      image1: template(colors[3])
			      x1: 0.54,  y1: 0.54
			      x2: 0.55,  y2: 0.55
			      image2: linear_blend(
			        image1: template(colors[4])
			        x1: 0.63,  y1: 0.63
			        x2: 0.64,  y2: 0.64
			        image2: linear_blend(
			          image1: template(colors[5])
			          x1: 0.72,  y1: 0.72
			          x2: 0.73,  y2: 0.73
			          image2: template(colors[6])
		   ))))))}
		8: { template("m") }
		9: { template("m") }
		10: { template("m") }
		11: { template("m") }
		12: { template("m") }
	]
	
	identity_hybrid := [
		radial: identity_horizontal_hybrid
		vertical: identity_horizontal_hybrid
		horizontal: identity_horizontal_hybrid
		overlay: identity_horizontal_hybrid
		diagonal: identity_horizontal_hybrid
	]

	color_background := {
	
		# for thumbnails
		if input == "hybrid" then
			input := "white,blue,red,{hybrid_previews},horizontal"
		else if input == "overlay" then
			input := "blue,red,{hybrid_previews},overlay"
		else if input == "radial" or input == "horizontal" or input == "vertical" then
			input := "white,blue,red,{hybrid_previews}," + input
		else if input == "diagonal" then
			input := "white,black,{hybrid_previews},diagonal"
		else if input == "reversed" then
			input := "white,blue,red,{hybrid_previews},horizontal,reversed"
		
		# What type of 'hybrid'?
		land     := chosen(choice:"land")
		multi    := chosen(choice:"multicolor")
		spectral := chosen(choice:"spectral")
		hybrid   := chosen(choice:"hybrid")
		artifact := chosen(choice:"artifact")
		snow := chosen(choice:"snow")
		rainbow := chosen(choice:"blue") and chosen(choice:"red") and chosen(choice:"green") and chosen(choice:"yellow") and chosen(choice:"purple") and chosen(choice:"orange")
		if land and colored_lands then template := land_template # use land template instead?
		
		# The selected colors
		colors := sort_text( order: "(wubrg)(lpoek)"
		                   , (if chosen(choice:"white") then "w")
		                   + (if chosen(choice:"blue")  then "u")
		                   + (if chosen(choice:"black") then "b")
		                   + (if chosen(choice:"red")   then "r")
		                   + (if chosen(choice:"green") then "g")
		                   + (if chosen(choice:"yellow") then "l")
		                   + (if chosen(choice:"purple") then "p")
		                   + (if chosen(choice:"orange") then "o")
		                   + (if chosen(choice:"brown") then "e")
		                   + (if chosen(choice:"pink") then "k"))
		if multi and (hybrid or colors == "") then (
			colors := colors + "m"
			multi := false
		)
		if spectral and (hybrid or colors == "") then (
			colors := colors + "t"
			multi := false
		)
		if artifact and (hybrid or colors == "") then (
			colors := colors + "a"
			artifact := false
		)
		if snow and (hybrid or colors == "") then (
			colors := colors + "s"
			snow := false
		)
		if chosen(choice:"reversed") then colors := reverse(colors)
		color_count := number_of_items(in: colors)
		if colors == "" then colors == "c"
		
		# 'shape' / type of hybrid
		shape := if      chosen(choice:"horizontal") then "horizontal"
		         else if chosen(choice:"vertical")   then "vertical"
		         else if chosen(choice:"overlay")    then "overlay"
		         else if chosen(choice:"diagonal")   then "diagonal"
		         else                                     "radial"
		
		# Determine background (allows styles to hook something else here)
		color_combination()
	}
	
	font_white := {
		hybrid   := chosen(choice:"hybrid")
		artifact := chosen(choice:"artifact")
		snow := chosen(choice:"snow")
		colors := sort_text( order: "(wubrg)[lpoek]"
			           , (if chosen(choice:"white") then "w")
			           + (if chosen(choice:"blue")  then "u")
			           + (if chosen(choice:"black") then "b")
			           + (if chosen(choice:"red")   then "r")
			           + (if chosen(choice:"green") then "g")
			           + (if chosen(choice:"yellow") then "l")
			           + (if chosen(choice:"purple") then "p")
			           + (if chosen(choice:"orange") then "o")
			           + (if chosen(choice:"brown") then "e")
			           + (if chosen(choice:"pink") then "k"))
			           + (if artifact               then "a")
			           + (if snow               then "s")
		font_colors_white(
			if chosen(choice:"land") then "l"
			else if input == "artifact, multicolor" then "a"
			else if input == "artifact, spectral" then "a"
			else if input == "snow, multicolor" then "s"
			else if input == "snow, spectral" then "s"
			else if chosen(choice:"multicolor")     then "m"
			else if chosen(choice:"spectral") then "t"
			else if artifact and snow then "a"
			else if artifact and not hybrid         then "a"
			else if snow and not hybrid then "s"
			else if colors == ""                    then "c"
			else colors[
				font_color_positions[
					if      chosen(choice:"horizontal") then "horizontal"
					else if chosen(choice:"vertical")   then "vertical"
					else if chosen(choice:"overlay")    then "overlay"
					else if chosen(choice:"diagonal")    then "diagonal"
					else                                     "radial"
				][number_of_items(in: colors)]
			]
		)
	}
	
	color_combination := {
		# The base hybrid, without the outer frame blended over it
		base := base_hybrid[shape][color_count]()
		magic_new_blend_router := "/magic-new.mse-style/"
		
		# Put a frame around it?
		# Frame Color Overrides
		if styling.outer_color != "default" or styling.trim_color != "default" or styling.inner_color != "default" then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: (if styling.outer_color == "default" then base
					else template(
						if styling.outer_color == "white" then "w"
						else if styling.outer_color == "blue" then "u"
						else if styling.outer_color == "black" then "b"
						else if styling.outer_color == "red" then "r"
						else if styling.outer_color == "green" then "g"
						else if styling.outer_color == "yellow" then "l"
						else if styling.outer_color == "purple" then "p"
						else if styling.outer_color == "orange" then "o"
						else if styling.outer_color == "brown" then "e"
						else if styling.outer_color == "pink" then "k"
						else if styling.outer_color == "multicolor" then "m"
						else if styling.outer_color == "spectral" then "t"
						else if styling.outer_color == "artifact" then "a"
						else if styling.outer_color == "snow" then "s"
						else "c"
					)
				)
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png",
					dark: (if styling.inner_color == "default" then base
						else template(
							if styling.inner_color == "white" then "w"
							else if styling.inner_color == "blue" then "u"
							else if styling.inner_color == "black" then "b"
							else if styling.inner_color == "red" then "r"
							else if styling.inner_color == "green" then "g"
							else if styling.inner_color == "yellow" then "l"
							else if styling.inner_color == "purple" then "p"
							else if styling.inner_color == "orange" then "o"
							else if styling.inner_color == "brown" then "e"
							else if styling.inner_color == "pink" then "k"
							else if styling.inner_color == "multicolor" then "m"
							else if styling.inner_color == "spectral" then "t"
							else if styling.inner_color == "artifact" then "a"
							else if styling.inner_color == "snow" then "s"
							else "c"
						)
					)
					light: (if styling.trim_color == "default" then base
						else template(
							if styling.trim_color == "white" then "w"
							else if styling.trim_color == "blue" then "u"
							else if styling.trim_color == "black" then "b"
							else if styling.trim_color == "red" then "r"
							else if styling.trim_color == "green" then "g"
							else if styling.trim_color == "yellow" then "l"
							else if styling.trim_color == "purple" then "p"
							else if styling.trim_color == "orange" then "o"
							else if styling.trim_color == "brown" then "e"
							else if styling.trim_color == "pink" then "k"
							else if styling.trim_color == "multicolor" then "m"
							else if styling.trim_color == "spectral" then "t"
							else if styling.trim_color == "artifact" then "a"
							else if styling.trim_color == "snow" then "s"
							else "c"
						)
					)
				)
			)
		# Lesurgo's "Land-brid" Effect
		else if contains(styling.extras, match:"spell-land hybrid") and color_count == 1 then
			linear_blend(
				image1: base,
				image2: land_template(colors[0]),
				x1: 0.4,  y1: 0
				x2: 0.6,  y2: 0
			)
		# Circeus' Hybrid Effect
		else if contains(styling.extras, match:"colorless-colored hybrid") and not artifact and not multi and color_count == 1 then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: base
				light: linear_blend(
					image1: template("c"),
					image2: base,
					x1: 0.4, y1: 0
					x2: 0.6, y2: 0
				)
			)
		else if contains(styling.extras, match:"colorless-colored hybrid") and not artifact and (multi or color_count > 1) then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("m")
				light: linear_blend(
					image1: template("c"),
					image2: template("m"),
					x1: 0.4, y1: 0
					x2: 0.6, y2: 0
				)
			)
		# Circeus' Tinged Artifact Hybrid Effect
		else if contains(styling.extras, match:"tinged artifact hybrid") and artifact and not multi and color_count == 1 then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("a")
				light: linear_blend(
					image1: template("a"),
					image2: template(colors[0]),
					x1: 0.4, y1: 0
					x2: 0.6, y2: 0
				)
			)
		else if contains(styling.extras, match:"tinged artifact hybrid") and artifact and (multi or color_count > 1) then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("a")
				light: linear_blend(
					image1: template("a"),
					image2: template("m"),
					x1: 0.4, y1: 0
					x2: 0.6, y2: 0
				)
			)
		# Rainbow Frames
		else if land and rainbow and type == "identity" then "rainbowl{type}.png"
		else if land and rainbow then "rainbowl{type}.jpg"
		else if rainbow and artifact then
			masked_blend(
				mask:  magic_new_blend_router + "artifact_blend_{type}.png",
				dark:  template("a"),
				light: "rainbow{type}.jpg",
			)
		else if rainbow and snow then
			masked_blend(
				mask:  magic_new_blend_router + "artifact_blend_{type}.png",
				dark:  template("s"),
				light: "rainbow{type}.jpg",
			)
		else if rainbow and type == "identity" then "rainbow{type}.png"
		else if rainbow then "rainbow{type}.jpg"
		# Alpha Style Dual Lands
		else if type == "card" and land and color_count == 2 and shape != "overlay" and styling.alpha_style_blending then
			masked_blend(
				mask:  "alpha_blend.png",
				dark:  land_template(colors[0]),
				light: land_template(colors[1]),
			)
		# Murmuring Bosk Effect
		else if land and multi and mask_multi_land_with_color() then
			masked_blend(
				mask:  magic_new_blend_router + "hybrid_blend_{type}.png",
				dark:  base,
				light:  land_template("m"),
			)
		# Multicolored Snow Artifact Frame
		else if artifact and snow and multi then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("a"),
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png"
					dark: template("m"),
					light: template("s"),
				)
			)
		# Spectral Snow Artifact Frame
		else if artifact and snow and spectral then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("a"),
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png"
					dark: template("t"),
					light: template("s"),
				)
			)
		# Multicolored Artifact Frame
		else if artifact and multi then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("a"),
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png"
					dark: template("m"),
					light: base,
				)
			)
		# Spectral Artifact Frame
		else if artifact and spectral then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("a"),
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png"
					dark: template("t"),
					light: base,
				)
			)
		# Snow Artifact Frame
		else if artifact and snow then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("a"),
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png"
					dark: template("s"),
					light: base,
				)
			)
		# Multicolored Snow Frame
		else if snow and multi then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("s"),
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png"
					dark: template("m"),
					light: base,
				)
			)
		# Spectral Snow Frame
		else if snow and spectral then
			masked_blend(
				mask: magic_new_blend_router + "artifact_blend_{type}.png",
				dark: template("s"),
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png"
					dark: template("t"),
					light: base,
				)
			)
		# Multicolored Frame
		else if multi then 
			masked_blend(
				mask:  magic_new_blend_router + "multicolor_blend_{type}.png",
				dark:  template("m"),
				light: base,
			)
		# Spectral Frame
		else if spectral then 
			masked_blend(
				mask:  magic_new_blend_router + "multicolor_blend_{type}.png",
				dark:  template("t"),
				light: base,
			)
		# Hybrid Colored Artifact Frame
		else if artifact and color_count > 1 and mask_hybrid_with_land() then 
			masked_blend(
				mask:  magic_new_blend_router + "artifact_blend_{type}.png",
				dark:  template("a"),
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png",
					dark: template("c"),
					light: base
				)
			)
		# Hybrid Colored Snow Frame
		else if snow and color_count > 1 and mask_hybrid_with_land() then 
			masked_blend(
				mask:  magic_new_blend_router + "artifact_blend_{type}.png",
				dark:  template("s"),
				light: masked_blend(
					mask: magic_new_blend_router + "multicolor_blend_{type}.png",
					dark: template("c"),
					light: base
				)
			)
		# Artifact Frame
		else if artifact then 
			masked_blend(
				mask:  magic_new_blend_router + "artifact_blend_{type}.png",
				dark:  template("a"),
				light: base,
			)
		# Snow Frame
		else if snow then 
			masked_blend(
				mask:  magic_new_blend_router + "artifact_blend_{type}.png",
				dark:  template("s"),
				light: base,
			)
		# Hybrid Frames
		else if color_count > 1 and mask_hybrid_with_land() then
			masked_blend(
				mask:  magic_new_blend_router + "hybrid_blend_{type}.png",
				dark:  land_template("c"),
				light: base,
			)
		else base
	}
	
	############################################################################################################ Scripts from Game File
	############################################################## Sorting mana symbols
	# Rainbow is L/P/O/U/R/G
	# correctly sort a mana symbol (no guild mana)
	mana_sort       := {
		if contains(styling.extras, match:"unsorted casting cost") then
			input
		else
			sort_text@(order: "XYZI[0123456789,]HSCAM(LPOEK)(WUBRG)")()
	}
	mana_sort_wedge := {
		if contains(styling.extras, match:"unsorted casting cost") then
			input
		else
			sort_text@(order: "XYZI[0123456789,]HSCAM(LOKPE)(WBGUR)")()
	}
	#mana_sort       := sort_text@(order: "XYZI[0123456789,]HSCAM(LPOEK)(WUBRG)")
	# correctly sort guild mana
	mana_sort_guild := sort_text@(order: "[XYZI01234567890,HSCAMLPOEKWUBRG/|]") +
			replace@(
				match: "./.|././.|./././.|.[|]",
				in_context: "(^|[^/])<match>($|[^/])",
				replace: {sort_text(order:"in_place((LPOEK)(WUBRG)")}
			)
	tap_filter := sort_text@(order: "<TQ>")
	############################################################## Determine card color
	
	# Names of colors
	color_name := {
		if      input == "W" then "white"
		else if input == "U" then "blue"
		else if input == "B" then "black"
		else if input == "R" then "red"
		else if input == "G" then "green"
		else if input == "L" then "yellow"
		else if input == "P" then "purple"
		else if input == "O" then "orange"
		else if input == "E" then "brown"
		else if input == "K" then "pink"
		else                     ""
	}
	color_names_6 := { color_name(colors.0) + ", " + color_name(colors.1) + ", " + color_name(colors.2) + ", " + color_name(colors.3) + ", " + color_name(colors.4) + ", " + color_name(colors.5) }
	color_names_7 := { color_name(colors.0) + ", " + color_name(colors.1) + ", " + color_name(colors.2) + ", " + color_name(colors.3) + ", " + color_name(colors.4) + ", " + color_name(colors.5) + ", " + color_name(colors.6) }
	# color based on mana cost, input = a mana cost
	color_filter  := sort_text@(order: "<WUBRGLPOEK>")
	color_filterS := sort_text@(order: "<S>")
	mana_to_color := {
		count  := number_of_items(in: colors)
		if hybrid == "" and snow == "" and contains(type, match:"Artifact") then
			# not a hybrid, not snow costed, but artifact
			if      count == 0 then  "colorless"
			else if count == 1 then  color_names_1() + ", artifact"
			else if set.set_info.use_gradient_multicolor == "no"  then "artifact, multicolor" # stop here
			else if count == 2 then  color_names_2() + ", artifact, multicolor"
			else if set.set_info.use_gradient_multicolor != "yes" then "artifact, multicolor" # stop here
			else if count == 3 then  color_names_3() + ", artifact, multicolor"
			else if count == 4 then  color_names_4() + ", artifact, multicolor"
			else if count == 5 then  color_names_5() + ", artifact, multicolor"
			else if count == 6 then  color_names_6() + ", artifact, multicolor"
			else if count == 7 then  color_names_7() + ", artifact, multicolor"
			else                     "artifact, multicolor"

		else if hybrid == "" and contains(type, match:"Artifact") then
			# not a hybrid, but snow costed and artifact
			if      count == 0 then  "artifact, snow"
			else if count == 1 then  color_names_1() + ", artifact, snow"
			else if set.set_info.use_gradient_multicolor == "no"  then "artifact, snow, multicolor" # stop here
			else if count == 2 then  color_names_2() + ", artifact, snow, multicolor"
			else if set.set_info.use_gradient_multicolor != "yes" then "artifact, snow, multicolor" # stop here
			else if count == 3 then  color_names_3() + ", artifact, snow, multicolor"
			else if count == 4 then  color_names_4() + ", artifact, snow, multicolor"
			else if count == 5 then  color_names_5() + ", artifact, snow, multicolor"
			else if count == 6 then  color_names_6() + ", artifact, snow, multicolor"
			else if count == 7 then  color_names_7() + ", artifact, snow, multicolor"
			else                     "artifact, snow, multicolor"
		else if hybrid == "" and snow == "" then
			# not a hybrid, not snow costed, not artifact
			if      count == 0 then  "colorless"
			else if count == 1 then  color_names_1()
			else if set.set_info.use_gradient_multicolor == "no"  then "multicolor" # stop here
			else if count == 2 then  color_names_2() + ", multicolor"
			else if set.set_info.use_gradient_multicolor != "yes" then "multicolor" # stop here
			else if count == 3 then  color_names_3() + ", multicolor"
			else if count == 4 then  color_names_4() + ", multicolor"
			else if count == 5 then  color_names_5() + ", multicolor"
			else if count == 6 then  color_names_6() + ", multicolor"
			else if count == 7 then  color_names_7() + ", multicolor"
			else                     "multicolor"
		else if hybrid == "" then
			# not a hybrid, not artifact, but snow costed
			if      count == 0 then  "snow"
			else if count == 1 then  color_names_1() + ", snow"
			else if set.set_info.use_gradient_multicolor == "no"  then "snow, multicolor" # stop here
			else if count == 2 then  color_names_2() + ", snow, multicolor"
			else if set.set_info.use_gradient_multicolor != "yes" then "snow, multicolor" # stop here
			else if count == 3 then  color_names_3() + ", snow, multicolor"
			else if count == 4 then  color_names_4() + ", snow, multicolor"
			else if count == 5 then  color_names_5() + ", snow, multicolor"
			else if count == 6 then  color_names_6() + ", snow, multicolor"
			else if count == 7 then  color_names_7() + ", snow, multicolor"
			else                     "snow, multicolor"
		else if snow == "" and contains(type, match:"Artifact") then
			# hybrid, and artifact, but not snow costed
			if count == 0 then "colorless"
			else if count == 1 then color_names_1() + ", artifact"
			else if count == 2 then  color_names_2() + ", artifact"
			else if count == 3 then  color_names_3() + ", artifact"
			else if count == 6 then
				if color_names_6() == "blue, red, green, yellow, purple, orange" then color_names_6() + ", artifact"
				else "artifact, multicolor"
			else                     "artifact, multicolor"
		else if contains(type, match:"Artifact") then
			# hybrid, and snow costed, and artifact
			if count == 0 then "artifact, snow"
			else if count == 1 then color_names_1() + ", artifact, snow"
			else if count == 2 then  color_names_2() + ", artifact, snow"
			else if count == 3 then  color_names_3() + ", artifact, snow"
			else if count == 6 then
				if color_names_6() == "blue, red, green, yellow, purple, orange" then color_names_6() + ", artifact, snow"
				else "artifact, snow, multicolor"
			else                     "artifact, snow, multicolor"
		else if snow == "" then
			# hybrid, not artifact, and not snow costed
			if count == 0 then "colorless"
			else if count == 1 then color_names_1()
			else if count == 2 then  color_names_2() + ", hybrid"
			else if count == 6 then
				if color_names_6() == "blue, red, green, yellow, purple, orange" then color_names_6() + ", hybrid"
				else "multicolor"
			else                     "multicolor"
		else
			# hybrid and snow costed, but not artifact
			if count == 0 then "snow"
			else if count == 1 then color_names_1() + ", snow"
			else if count == 2 then  color_names_2() + ", snow, hybrid"
			else if count == 6 then
				if color_names_6() == "blue, red, green, yellow, purple, orange" then color_names_6() + ", snow, hybrid"
				else "snow, multicolor"
			else                     "snow, multicolor"
	}
	
	# Look for a CDA that defines colors
	text_to_color := {
		# Note: running filter_text is quite slow, do a quick 'contains' check first
		if contains(match: card_name) then (
		  text := filter_text(match: regex_escape(card_name)+"(</[-a-z]+>)? is (colorless|all colors|((blue|white|green|red|black|yellow|purple|orange|brown|pink)((,|,? and) (blue|white|green|red|black|yellow|purple|orange|brown|pink))*))\\.")
		  if text != "" then (
		    if contains(text, match: "all colors") then (
			colors := "WUBRGLPOEK"
			if land == "land" then land_multicolor()
			else mana_to_color(hybrid: "")
		    ) else (
			colors := ""
			if contains(text, match: "white") then colors := colors + "W"
			if contains(text, match: "blue")  then colors := colors + "U"
			if contains(text, match: "black") then colors := colors + "B"
			if contains(text, match: "red")   then colors := colors + "R"
			if contains(text, match: "green") then colors := colors + "G"
			if contains(text, match: "yellow") then colors := colors + "L"
			if contains(text, match: "purple") then colors := colors + "P"
			if contains(text, match: "orange") then colors := colors + "O"
			if contains(text, match: "brown") then colors := colors + "E"
			if contains(text, match: "pink") then colors := colors + "K"
			if land == "land" then land_multicolor()
			else mana_to_color(hybrid: "")
		    )
		  )
		  else ""
		)
		else ""
	}
	
	card_color := {
		# usually the color of mana
		text_color := text_to_color(rules_text, land: is_land(type));
		if text_color == "" then (
			mana_color := mana_to_color(colors: color_filter(casting_cost), hybrid: color_filterH(casting_cost), snow: color_filterS(casting_cost))
			if      mana_color == "colorless" and is_land    (type)  then land_to_color(watermark)
			else if mana_color == "colorless" and is_artifact(type)  then "artifact"
			else mana_color
		)
		else text_color
	};

	# Number of colors in a card_color
	card_color_color_count := count_chosen@(choices: "white,blue,black,red,green,yellow,purple,orange,brown,pink,artifact,snow")
	# Clean up color field
	card_color_filter := {
		colors := card_color_color_count()
		if colors > 2 then
			input := remove_choice(choice: "overlay")
		if colors > 1 then (
			input := require_choice(choices: "multicolor, hybrid, land, artifact, snow, spectral")
			input := exclusive_choice(choices: "multicolor, hybrid, spectral")
			input := require_exclusive_choice(choices: "horizontal, vertical, radial, diagonal, overlay")
		) else
			input := remove_choice(choices: "radial, horizontal, vertical, diagonal, overlay, hybrid, reversed")
			input := exclusive_choice(choices: "multicolor, spectral")
		if chosen(choice:"overlay") then
			input := remove_choice(choice: "reversed")
		input
	}
	
	############################################################## Card number
	
	# Index for sorting, white cards are first, so white->A, blue->B, .. ,
	# The code consists of 4 parts:
	#   normal/token,  color,  shifted,   split
	hybrid_color_pair_sort := {
		colors := sort_text(casting_cost, order: "<WUBRGLPOEK>")
		if not set.sort_hybrid_in_pairs then "HK"
		else if colors == "WU" then "HA"
		else if colors == "UB" then "HB"
		else if colors == "BR" then "HC"
		else if colors == "RG" then "HD"
		else if colors == "WG" then "HE"
		else if colors == "WB" then "HF"
		else if colors == "UR" then "HG"
		else if colors == "BG" then "HH"
		else if colors == "WR" then "HI"
		else if colors == "UG" then "HJ"
		else if colors == "WP" then "HJA"
		else if colors == "UP" then "HJB"
		else if colors == "BP" then "HJC"
		else if colors == "RP" then "HJD"
		else if colors == "GP" then "HJE"
		else if colors == "WO" then "HJF"
		else if colors == "UO" then "HJG"
		else if colors == "BO" then "HJH"
		else if colors == "RO" then "HJI"
		else if colors == "GO" then "HJM"
		else if colors == "PO" then "HJN"
		else "HK"
	}
	multi_color_pair_sort := {
		colors := sort_text(casting_cost, order: "<WUBRGLPOEK>")
		if not set.sort_multicolor_in_pairs then "GK"
		else if colors == "WU" then "GA"
		else if colors == "UB" then "GB"
		else if colors == "BR" then "GC"
		else if colors == "RG" then "GD"
		else if colors == "WG" then "GE"
		else if colors == "WB" then "GF"
		else if colors == "UR" then "GG"
		else if colors == "BG" then "GH"
		else if colors == "WR" then "GI"
		else if colors == "UG" then "GJ"
		else if colors == "WP" then "GJA"
		else if colors == "UP" then "GJB"
		else if colors == "BP" then "GJC"
		else if colors == "RP" then "GJD"
		else if colors == "GP" then "GJE"
		else if colors == "WO" then "GJF"
		else if colors == "UO" then "GJG"
		else if colors == "BO" then "GJH"
		else if colors == "RO" then "GJI"
		else if colors == "GO" then "GJM"
		else if colors == "PO" then "GJN"
		else if contains(card.casting_cost, match:"/") then "GL"
		else "GK"
	}
	color_of_card := {
		card_color := card.card_color
		casting_cost := card.casting_cost
		type := card.super_type
		if card.shape == "split" and
		   card_color != card.card_color_2 then "I"                              # Diff Color Splits
		else if chosen(choice: "land", card_color) then (                   # Lands
			if card.rarity != "basic land" then "L"                          # Nonbasic Land
			else basic_land_sort()                                           # Basic Land
		) else if is_null_cost(casting_cost) then (                         # Non-Land Cards with no or zero costs.
			if chosen(choice: "colorless", card_color) then "A"              # Clear Colorless
			else if chosen(choice: "hybrid", card_color)    then "HK"        # Hybrids
			else if is_multicolor(card_color)          then "GK"             # Multicolor
			else if chosen(choice:"white", card_color) then "B"              # White
			else if chosen(choice:"blue", card_color)  then "C"              # Blue
			else if chosen(choice:"black", card_color) then "D"              # Black
			else if chosen(choice:"red", card_color)   then "E"              # Red
			else if chosen(choice:"green", card_color) then "F"              # Green
			else                                            "J"              # Artifact
		) else (
			                                                            # Cards with costs.
			colors := sort_text(casting_cost, order: "<WUBRGLPOEK>")
			if colors == "" and contains(type, match:"Artifact") then "J"    # Artifact
			else if colors == ""  then "A"                                   # Clear Colorless
			else if colors == "W" then "B"                                   # White
			else if colors == "U" then "C"                                   # Blue
			else if colors == "B" then "D"                                   # Black
			else if colors == "R" then "E"                                   # Red
			else if colors == "G" then "F"                                   # Green
			else if colors == "L" then "FTA"                                 # Yellow
			else if colors == "P" then "FTB"                                 # Purple
			else if colors == "O" then "FTC"                                 # Orange
			else if colors == "E" then "FTD"                                 # Brown
			else if colors == "K" then "FTE"                                 # Pink
			else if is_hybrid_cost() then hybrid_color_pair_sort()           # Hybrid (by pairs)
			else if contains(casting_cost, match:"/") and contains(type, match:"Artifact") then "I" # Hybrid Artifacts
			else                       multi_color_pair_sort()               # Multicolor (by pairs)
		)
	}
	
	############################################################## Utilities for keywords
	# replaces — correctly
	for_mana_costs := format_cost := {
		if input.separator_before == "—" and contains(input.param, match: " ") then (
			if contains(input.param, match:",") then (
				if match(match: "^[HSCAMTQXYZIWUBRGLPOEK0-9,/|]+,", input.param) then
					"{add}<param-cost>{combined_cost(input.param)}</param-cost>"
				else "<param-cost>{combined_cost(input.param)}</param-cost>"
			) else
				"<param-cost>{alternative_cost(input.param)}</param-cost>"
		) else
			"{add}<param-mana>{input.param}</param-mana>"
	}
	combined_cost := replace@(match:", [A-Z]", replace: { to_lower() })+
		replace@(match:",", replace:" and")+
		replace@(match:"^[HSCAMTQXYZIWUBRGLPOEK0-9,/|]", in_context: "(^|[[:space:]])<match>", replace: "<sym-auto>&</sym-auto>")+
		replace@(match:"^[A-Z]", replace: { to_lower() })
	
	############################################################## The text box
	
	# Filters for the text box
	# context in which mana symbols are found
	mana_context :=
		"(?ix)				# case insensitive, ignore whitespace
		 (^|[[:space:]\"(“'])		# start of a word
		 (  <match>:			# G: something
		 |  <match>,			# G, tap: something
		 |  <match>[ ]can[ ]be[ ]pay
		 |  (pays?|additional|costs?|the	# pay X. creatures cost 1 less. pay an additional G.
		    |adds?|pay(ed)?[ ](with|using)
		    )
		    ([ ]either)?			 # pay either X or Y
		    ([ ](<sym[^>]*>)?[HSCAMTQXYZIWUBRGLPOEK0-9,/|]+(</sym[^>]*>)?,)* # pay X, Y or Z
		    ([ ](<sym[^>]*>)?[HSCAMTQXYZIWUBRGLPOEK0-9,/|]+(</sym[^>]*>)?[ ](and|or|and/or))* # pay X or Y
		    [ ]<match>
		    ([,.)]|$				# (end of word)
		    |[ ][^ .,]*$			# still typing...
		    |[ ]( or | and | in | less | more | to ) # or next word is ...
		    )
		    )
		 |  <param-mana><match></param-mana>		# keyword argument that is declared as mana
		 |  <param-cost>[ ]*<match></param-cost>	# keyword argument that is declared as cost
		 |  <param-cost><match>,			# keyword argument that is declared as cost
		 ";
	# the rule text filter
	#  - adds mana symbols
	#  - makes text in parentheses italic
	text_filter :=
		# step 1 : remove all automatic tags
		remove_tag@(tag: "<sym-auto>") +
		remove_tag@(tag: "<i-auto>")   +
		remove_tag@(tag: "<b-auto>")   +
		remove_tag@(tag: "<error-spelling") +
		remove_tag@(tag: "<nospellcheck") +
		# step 2 : reminder text for keywords
		expand_keywords@(
			condition: {
				correct_case or (mode != "pseudo" and not used_placeholders)
			}
			default_expand: {
				chosen(choice:if correct_case then mode else "lower case", set.automatic_reminder_text)
			},
			combine: {
				keyword  := "<nospellcheck>{keyword}</nospellcheck>"
				reminder := process_english_hints(reminder)
				if mode == "pseudo" then "<i-auto>{keyword}</i-auto>"
				else keyword + if expand then "<atom-reminder-{mode}> ({reminder})</atom-reminder-{mode}>"
			}) +
		# step 2b : move action keywords' reminder text to the end of the line
		replace@(
			match: "(<atom-reminder-action>(?:(?!<kw-).)*</atom-reminder-action></kw[^>]*>)(((?!<atom-reminder| ?<kw-)[^\n(])+)",
			replace: "\\2\\1"
			) +
		# step 2c : remove duplicate reminder text
		replace@(
			match: "(<atom-reminder-[^>]*>[^)]+[)]</atom-reminder-[^>]*>)([^\n]+)\\1"
			replace: "\\2\\1"
			) +
		# step 3a : expand shortcut word CARDNAME
		replace@(
			match: "CARDNAME",
			in_context: "(^|[[:space:]]|\\()<match>", # TODO: Allow any punctuation before
			replace: "<atom-cardname></atom-cardname>"
			) +
		# step 3b : expand shortcut word LEGENDNAME
		replace@(
			match: "LEGENDNAME",
			in_context: "(^|[[:space:]]|\\()<match>", # TODO: Allow any punctuation before
			replace: "<atom-legname></atom-legname>"
			) +
		# step 3c : fill in atom fields
		tag_contents@(
			tag: "<atom-cardname>",
			contents: { "<nospellcheck>" + (if card_name=="" then "CARDNAME" else card_name) + "</nospellcheck>" }
			) +
		tag_contents@(
			tag: "<atom-legname>",
			contents: { "<nospellcheck>" + (if card_name=="" then "LEGENDNAME" else legend_filter(card_name)) + "</nospellcheck>" }
			) +
		# step 4 : explict non mana symbols
		replace@(
			match: "\\][HSCAMTQXYZIWUBRGLPOEK0-9/|]+\\[",
			replace: {"<nosym>" + mana_filter_t() + "</nosym>"} ) +
		# step 5 : add mana & tap symbols
		replace@(
			match: "\\b[HSCAMTQXYZIWUBRGLPOEK0-9/|]+\\b",
			in_context: mana_context,
			replace: {"<sym-auto>" + mana_filter_t() + "</sym-auto>"} ) +
		# step 5b : add explict mana symbols
		replace@(
			match: "\\[[HSCAMTQXYZIWUBRGLPOEK0-9/|]+\\]",
			replace: {"<sym>" + mana_filter_t() + "</sym>"} ) +
		# step 6a : curly double quotes
		replace@(
			match: "[[.quotation-mark.]]|”",
			in_context: "[ ]<match>+|^<match>",
			replace: "“" )+
		replace@(
			match: "[[.quotation-mark.]]",
			replace: "”" )+
		# step 7 : italicize text in parenthesis
		replace@(
		 	match: "[(]([^)\n]|[(][^)\n]*[)])*[)]?",
			in_context: "(^|[[:space:]])<match>|<atom-keyword><match></",
		 	replace: "<i-auto>&</i-auto>") +
		# step 8 : automatic capitalization, but not after "("
		replace@(
			match: "([ ]*: |—| — )" # preceded by this
			     + "([[:lower:]])" # match this
			     + "(?![)])",      # not followed by this
			replace: { _1 + to_upper(_2) }) +
		#curly_quotes +
		# step 9 : spellcheck
		{ if set.mark_errors then
			check_spelling(
				language: language().spellcheck_code,
				extra_dictionary: "/magic.mse-game/magic-words",
				extra_match: additional_text_words
			)
		  else input
		}
	
	############################################################## Other boxes
	colorless_color := {
		if contains(styling.extras, match:"colored xyz mana") and card.card_color=="white" then "w"
		else if contains(styling.extras, match:"colored xyz mana") and card.card_color=="blue" then "u"
		else if contains(styling.extras, match:"colored xyz mana") and card.card_color=="black" then "b"
		else if contains(styling.extras, match:"colored xyz mana") and card.card_color=="red" then "r"
		else if contains(styling.extras, match:"colored xyz mana") and card.card_color=="green" then "g"
		else if contains(styling.extras, match:"colored xyz mana") and card.card_color=="colorless" and contains(card.casting_cost, match:"L") then "l"
		else if contains(styling.extras, match:"colored xyz mana") and card.card_color=="colorless" and contains(card.casting_cost, match:"P") then "p"
		else if contains(styling.extras, match:"colored xyz mana") and card.card_color=="colorless" and contains(card.casting_cost, match:"O") then "o"
		else if contains(styling.extras, match:"colored xyz mana") and card.card_color=="colorless" and contains(card.casting_cost, match:"E") then "e"
		else if contains(styling.extras, match:"colored xyz mana") and card.card_color=="colorless" and contains(card.casting_cost, match:"K") then "k"
		else "c"
	}
	
	typesymbol_for :=
		to_text +
		replace@(match: "(Legendary|Basic|Snow|World| )", replace: "") +
		{ if input == "Creature" then "creature"
		  else if input == "Sorcery" then "sorcery"
		  else if input == "Instant" then "instant"
		  else if input == "Artifact" then "artifact"
		  else if input == "Enchantment" then "enchantment"
		  else if input == "Land" then "land"
		  else if input == "Planeswalker" then "planeswalker"
		  else if input == "Structure" then "structure"
		  else                                "multitype"
		}
		
	############################################################## Statistics utilities
	# Converted mana cost
	is_half_mana    := match@(match: "1/2|[|][HSCAMWUBRGLPOEK]")
	is_colored_mana := match@(match: "[WUBRGLPOEK]")
	cmc_split := break_text@(match: "(?ix) 1/2 | [|][WUBRGLPOEK] | [0-9,]+(?!/[WUBRGHSCAMLPOEKCTQ2]) | [WUBRGHSCAMLPOEK0-9,.](/[WUBRGHSCAMLPOEK])\{0,4} ")
	
	primary_card_color := {
		artifact := chosen(choice:"artifact") and not (chosen(choice:"white") or chosen(choice:"blue") or chosen(choice:"black") or chosen(choice:"red") or chosen(choice:"green"))
		land     := chosen(choice:"land")
		multi    := chosen(choice:"multicolor")
		hybrid   := chosen(choice:"hybrid")
		white    := chosen(choice:"white")
		blue     := chosen(choice:"blue")
		black    := chosen(choice:"black")
		red      := chosen(choice:"red")
		green    := chosen(choice:"green")
		if      land                                      then "land"
		else if multi                                     then "multicolor"
		else if hybrid                                    then "hybrid"
		else if artifact                                  then "artifact"
		else if white                                     then "white"
		else if blue                                      then "blue"
		else if black                                     then "black"
		else if red                                       then "red"
		else if green                                     then "green"
		else                                                   input
	}
	
############################################################## Set info fields
set info style:
	symbol:
		variation:
			name: invertedcommon
			border radius: 0.10
			fill type: solid
			fill color:   rgb(255,255,255)
			border color: rgb(0,0,0)
		variation:
			name: watermark
			border radius: 0.10
			fill type: solid
			fill color:   rgb(255,255,255)
			border color: rgba(0,0,0,0)
############################################################## Extra style options
styling field:
	type: choice
	name: artifact style
	description: Choose the style of artifacts: light = before Fifth Dawn, dark = used since Fifth Dawn, brown = old rust style.
	initial: dark
	choice: light
	choice: dark
	choice: brown
styling field:
	type: boolean
	name: saturated multicolor
	description: Should multicolor cards be more saturated? This is done on real cards.
	initial: yes
styling field:
	type: boolean
	name: grey hybrid name
	description: Use a grey background for the name and type line on hybrid cards. This is done on real cards.
styling field:
	type: boolean
	name: colored multicolor land name
	description: Use a colored background for the name and type on multicolor land cards with a basic land type. This is done on real cards.
styling field:
	type: boolean
	name: use guild mana symbols
	description: Use the Ravnica guild symbols instead of the official half/half circles for hybrid mana.
	initial: no
styling field:
	type: package choice
	name: text box mana symbols
	match: magic-mana-*.mse-symbol-font
	initial: magic-mana-small-extra.mse-symbol-font
styling field:
	type: package choice
	name: pt box symbols
	match: magic-pt-symbols-*.mse-symbol-font
	initial: magic-pt-symbols-extra.mse-symbol-font
styling field:
	type: choice
	name: tap symbol
	description: What tap and untap symbols should be used on cards?
	initial: modern
	choice: modern
	choice: old
	choice: diagonal T
styling field:
	type: choice
	name: center text
	description: When to center text (short text only means only on one-line cards with no flavor text)
	choice: always
	choice: short text only
	choice: never
	initial: no
styling field:
	type: boolean
	name: alpha style blending
	description: Use Alpha-style dual blending
	initial: no
styling field:
	type: boolean
	name: color indicator
	description: Should there be a color indicator dot?
	initial: no
styling field:
	type: boolean
	name: inverted common symbol
	description: Should the common rarity symbol be inverted, like in Coldsnap?
	initial: no
styling field:
	type: choice
	name: image size
	description: Should the art extend into a transparent textbox?
	initial: standard
	choice: standard
	choice: extended
	choice: full
styling field:
	type: color
	name: artist font color
	description: The default artist and copyright line font color for cards
	choice:
		name: black
		color: rgb(0,0,0)
	choice:
		name: white
		color: rgb(255,255,255)
styling field:
	type: text
	name: card creator
	description: The default creator of the set.
styling field:
	type: package choice
	name: overlay
	description: Should there be an overlay applied, such as foil?
	match: magic-overlay-*.mse-include
	required: false
styling field:
	type: choice
	name: overlay combine type
	description: What type of combine should the overlay use? Only works if overlay is enabled.
	choice: normal
	choice: add
	choice: subtract
	choice: stamp
	choice: difference
	choice: negation
	choice: multiply
	choice: darken
	choice: lighten
	choice: color dodge
	choice: color burn
	choice: screen
	choice: overlay
	choice: hard light
	choice: soft light
	choice: reflect
	choice: glow
	choice: freeze
	choice: heat
	choice: and
	choice: or
	choice: xor
	choice: shadow
	choice: symmetric overlay
styling field:
	type: boolean
	name: foil art
	description: Should the illustration on a card be covered by the foil layer?
	initial: yes
styling field:
	type: choice
	name: overlay hybrid type
	description: What type of combine should the overlay hybrid use? Only affects overlay hybrids. Symmetric overlay is normal.
	initial: symmetric overlay
	choice: normal
	choice: add
	choice: subtract
	choice: stamp
	choice: difference
	choice: negation
	choice: multiply
	choice: darken
	choice: lighten
	choice: color dodge
	choice: color burn
	choice: screen
	choice: overlay
	choice: hard light
	choice: soft light
	choice: reflect
	choice: glow
	choice: freeze
	choice: heat
	choice: and
	choice: or
	choice: xor
	choice: shadow
	choice: symmetric overlay
styling field:
	type: choice
	name: outer color
	description: Should the outside of the frame be a special color?
	choice: default
	choice: white
	choice: blue
	choice: black
	choice: red
	choice: green
	choice: yellow
	choice: purple
	choice: orange
	choice: brown
	choice: pink
	choice: artifact
	choice: snow
	choice: multicolor
	choice: spectral
	choice: colorless
styling field:
	type: choice
	name: trim color
	description: Should the trim of the frame be a special color?
	choice: default
	choice: white
	choice: blue
	choice: black
	choice: red
	choice: green
	choice: yellow
	choice: purple
	choice: orange
	choice: brown
	choice: pink
	choice: artifact
	choice: snow
	choice: multicolor
	choice: spectral
	choice: colorless
styling field:
	type: choice
	name: inner color
	description: Should the inside of the frame be a special color?
	choice: default
	choice: white
	choice: blue
	choice: black
	choice: red
	choice: green
	choice: yellow
	choice: purple
	choice: orange
	choice: brown
	choice: pink
	choice: artifact
	choice: snow
	choice: multicolor
	choice: spectral
	choice: colorless
styling field:
	type: multiple choice
	name: extras
	description: Which extra options would you like to use?
	choice: clock watermark
	choice: scales watermark
	choice: mtgsalvation rarity
	choice: type symbol with name
	choice: spell-land hybrid
	choice: colorless-colored hybrid
	choice: tinged artifact hybrid
	choice: holiday text
	choice: colored xyz mana
	choice: unsorted casting cost
styling field:
	type: choice
	name: separated watermark
	description: Should the watermark be separated from the text?
	choice: no
	choice: yes, above text
	choice: yes, below text
styling field:
	type: text
	name: popout image style
	description: The styling instructions for the popout image field, formatted as "left,top,width,height,". The text MUST end with a comma.
styling style:
	artifact style:
		render style: both
		choice images:
			light: /magic-new.mse-style/oacard.jpg
			dark:  /magic-new.mse-style/acard.jpg
			brown: /magic-new.mse-style/bacard.jpg
	use guild mana symbols:
		choice images:
			yes: /magic-mana-small.mse-symbol-font/mana_guild_rg.png
			no:  /magic-mana-small.mse-symbol-font/mana_rg.png
	tap symbol:
		render style: both
		choice images:
			modern:     /magic-mana-large.mse-symbol-font/mana_t.png
			old:        /magic-mana-large.mse-symbol-font/mana_t_old.png
			diagonal T: /magic-mana-large.mse-symbol-font/mana_t_older.png
	extras:
		render style: checklist
		direction: vertical
############################################################## Card fields
card style:
	############################# Background stuff
	border color:
		left: 0
		top: 0
		width: 375
		height:	523
		radius: 18
		left width: 17
		right width: 17
		top width: 17
		bottom width: 18
		z index: 7
	############################# Name line
	name:
		left:
			{ if card.card_symbol=="none" and (card.type_symbol=="none" or not contains(styling.extras, match:"type symbol with name")) then 32
			else if card.card_symbol == "none" then 49
			else if card.type_symbol == "none" or typesymbol_type() == "none" then 51
			else 68}
		top: 30
		right: { 341 - card_style.casting_cost.content_width }
		height: 23
		alignment: bottom shrink-overflow
		padding bottom: 0
		z index: 4
		font:
			name: Matrix
			size: 17
			weight: bold
			color: rgb(0,0,0)
	casting cost:
		right: 343
		top : 31
		width: { max(30, card_style.casting_cost.content_width) + 5 }
		height: 23
		alignment: middle right
		font:
			name: MPlantin
			size: 15
		symbol font:
			name: magic-mana-large-extra
			size: 15
			alignment: middle right
		always symbol: true
		z index: 5
		padding top: 0
	card symbol:
		left:
			{if card.card_symbol == "none" then 20
			else if card.type_symbol == "none" or not contains(styling.extras, match:"type symbol with name") then 32
			else 50}
		top: {if card.card_symbol == "none" then 42 else 31}
		height: 20
		width: 14
		z index: 5
		render style: image
		choice images:
			tombstone: /magic-new.mse-style/tombstone.png
	type symbol:
		left: {if card.type_symbol == "none" or not contains(styling.extras, match:"type symbol with name") then 18 else 30}
		top: {if card.type_symbol == "none" or not contains(styling.extras, match:"type symbol with name") then 22 else 32}
		width: 21
		height: 20
		z index: 5
		render style: image
		alignment: middle center
		visible: { contains(styling.extras, match:"type symbol with name") }
		choice images:
			artifact: /magic-future-common.mse-include/artifact_black.png
			creature: /magic-future-common.mse-include/creature_black.png
			enchantment: /magic-future-common.mse-include/enchantment_black.png
			instant: /magic-future-common.mse-include/instant_black.png
			land: /magic-future-common.mse-include/land_black.png
			multitype: /magic-future-common.mse-include/multitype_black.png
			sorcery: /magic-future-common.mse-include/sorcery_black.png
			planeswalker: /magic-future-common.mse-include/planeswalker_black.png
			structure: structure_black.png
	############################# Image
	image:
		left: { if styling.image_size == "full" then 17 else 32 }
		top: { if styling.image_size == "full" then 17 else 62 }
		width: { if styling.image_size == "full" then 341 else 311 }
		height: { if styling.image_size == "extended" then 408 else if styling.image_size == "full" then 488 else 228 }
		z index: 2
		mask: { ( if styling.image_size == "full" then "imagemask_" else "/magic-new.mse-style/imagemask_") + styling.image_size + ".png" }
		default: {default_image(card.card_color)}
	image 2:
		left: {if comma_count(styling.popout_image_style) == ",,,," then split_text(match:",", styling.popout_image_style).0 else "0"}
		top: {if comma_count(styling.popout_image_style) == ",,,," then split_text(match:",", styling.popout_image_style).1 else "0"}
		width: {if comma_count(styling.popout_image_style) == ",,,," then split_text(match:",", styling.popout_image_style).2 else "0"}
		height: {if comma_count(styling.popout_image_style) == ",,,," then split_text(match:",", styling.popout_image_style).3 else "0"}
		z index: 3
	############################# Card type
	type:
		left: { if has_identity() then "55" else "35" }
		top: 298
		width: { (if has_identity() then "288" else "308") - max(22,card_style.rarity.content_width) }
		height: 20
		alignment: bottom shrink-overflow
		z index: 4
		padding top: 4
		font:
			name: Matrix
			size: 14
			color: rgb(0,0,0)
			separator color: rgb(128,128,128)
	rarity:
		right: 342
		top : 297
		width: 44
		height: 22
		z index: 5
		render style: image
		alignment: middle right
		visible: { not contains(styling.extras, match:"mtgsalvation rarity") }
		choice images:
			# Images based on the set symbol
			basic land:
				script:
					if styling.inverted_common_symbol then symbol_variation(symbol: set.symbol, variation: "invertedcommon")
					else symbol_variation(symbol: set.symbol, variation: "common")
			common:
				script:
					if styling.inverted_common_symbol then symbol_variation(symbol: set.symbol, variation: "invertedcommon")
					else symbol_variation(symbol: set.symbol, variation: "common")
			uncommon:   script: symbol_variation(symbol: set.symbol, variation: "uncommon")
			rare:       script: symbol_variation(symbol: set.symbol, variation: "rare")
			mythic rare:       script: symbol_variation(symbol: set.symbol, variation: "mythic rare")
			special:    script: symbol_variation(symbol: set.symbol, variation: "special")
	############################# Text box
	text:
		left: 31
		top: { if contains(styling.separated_watermark, match:"above") then 399 else 328 }
		width: 311
		height: { if contains(styling.separated_watermark, match: "no") then 142 else 71 }
		font:
			name: MPlantin
			italic name: MPlantin-Italic
			size: 14
			scale down to: 6
			color: rgb(0,0,0)
		symbol font:
			name: { styling.text_box_mana_symbols }
			size: 14
		alignment:
			script:
				if (styling.center_text == "short text only" and
				   not contains(match:"\n", card.rule_text) and
				   card.flavor_text == "<i-flavor></i-flavor>" and
				   card_style.text.content_lines <= 2) or
				   styling.center_text == "always"
				then "middle center"
				else "middle left"
		z index: 5
		padding left:   6
		padding right:  4
		line height hard: 1.2
		line height line: 1.5
		line height soft: 0.9
		line height hard max: 1.3
		line height line max: 1.6
	############################# PT
	pt:
		z index: 5
		left:	284
		top:	466
		width:	60
		height:	28
		alignment: center middle shrink-overflow
		font:
			name: ModMatrix
			size: 17
			weight: bold
			color: rgb(0,0,0)
			separator color: rgb(200,0,0)
		symbol font:
			name: {styling.pt_box_symbols}
			size: 8
			alignment: middle right
	############################# Card sorting / numbering
	############################# Copyright stuff
	illustrator:
		left: 56
		top : 478
		width: 217
		height: 16
		z index: 4
		font:
			name: Matrix
			size: 10
			weight: bold
			color: { styling.artist_font_color }
	copyright line:
		left: 30
		top : 493
		width: 247
		height: 12
		z index: 4
		font:
			name: MPlantin
			size: 6.5
			color: { styling.artist_font_color }
############################################################## Extra card fields
extra card field:
	type: multiple choice
	name: identity
	empty choice: colorless
	choice: white
	choice: blue
	choice: black
	choice: red
	choice: green
	choice: yellow
	choice: purple
	choice: orange
	choice: brown
	choice:
		name: pink
		line below: true
	choice: artifact
	choice: snow
	choice: land
	choice: multicolor
	choice: spectral
	choice:
		name: hybrid
		line below: true
	choice:
		name: horizontal
		type: radio
	choice:
		name: vertical
		type: radio
	choice:
		name: radial
		type: radio
	choice:
		name: diagonal
		type: radio
	choice:
		name: overlay
		type: radio
	choice:
		name: reversed
	script: card_color_filter(value)
	default: card_color(casting_cost: card.casting_cost, rules_text: card.rule_text, type: card.super_type, watermark: card.watermark, card_name: card.name)
extra card field:
	type: multiple choice
	name: pt box
	empty choice: colorless
	choice: white
	choice: blue
	choice: black
	choice: red
	choice: green
	choice: yellow
	choice: purple
	choice: orange
	choice: brown
	choice:
		name: pink
		line below: true
	choice: artifact
	choice: snow
	choice: land
	choice: multicolor
	choice: spectral
	choice:
		name: hybrid
		line below: true
	choice:
		name: horizontal
		type: radio
	choice:
		name: vertical
		type: radio
	choice:
		name: radial
		type: radio
	choice:
		name: diagonal
		type: radio
	choice:
		name: overlay
		type: radio
	choice:
		name: reversed
	script: card_color_filter(value)
	default: card_color(casting_cost: card.casting_cost, rules_text: card.rule_text, type: card.super_type, watermark: card.watermark, card_name: card.name)
extra card field:
	type: choice
	name: emblem
	include file: /magic-watermarks-extra.mse-include/watermark-names
extra card field:
	type: choice
	name: foil layer
	choice: foil
	save value: false
	editable: false
extra card field:
	type: multiple choice
	name: frame
	empty choice: colorless
	choice: white
	choice: blue
	choice: black
	choice: red
	choice: green
	choice: yellow
	choice: purple
	choice: orange
	choice: brown
	choice:
		name: pink
		line below: true
	choice: artifact
	choice: snow
	choice: land
	choice: multicolor
	choice: spectral
	choice:
		name: hybrid
		line below: true
	choice:
		name: horizontal
		type: radio
	choice:
		name: vertical
		type: radio
	choice:
		name: radial
		type: radio
	choice:
		name: diagonal
		type: radio
	choice:
		name: overlay
		type: radio
	choice:
		name: reversed
	script: card_color_filter(value)
	default: card_color(casting_cost: card.casting_cost, rules_text: card.rule_text, type: card.super_type, watermark: card.watermark, card_name: card.name)
extra card field:
	type: text
	name: creator computer
	save value: false
	editable: false
	show statistics: false
	script: ":"
extra card field:
	type: text
	name: creator
	save value: false
	script: styling.card_creator
	show statistics: false
	editable: false
extra card field:
	type: text
	name: value
	save value: true
	description: The treasure value or poison value of the card.
extra card field:
	type: choice
	name: value box
	save value: true
	description: The type of value for the value field.
	choice: none
	choice: treasure
	choice: poison
	default: default_value_box(value)
extra card field:
	type: text
	name: promo label
	save value: true
	description: The golden promo label.
extra card field:
	type: choice
	name: clock watermark
	save value: false
	editable: false
	script: "clock"
extra card field:
	type: choice
	name: scales watermark
	save value: false
	editable: false
	script: "scales"
extra card field:
	type: choice
	name: mtgs rarity 1
	choice: mtgs
	save value: false
	editable: false
extra card field:
	type: choice
	name: mtgs rarity 2
	choice: mtgs
	save value: false
	editable: false
extra card field:
	type: choice
	name: mtgs rarity 3
	choice: mtgs
	save value: false
	editable: false
extra card field:
	type: choice
	name: mtgs rarity 4
	choice: mtgs
	save value: false
	editable: false
extra card field:
	type: choice
	name: mtgs rarity 5
	choice: mtgs
	save value: false
	editable: false
extra card style:
	pt box:
		left:	271
		top:	461
		width:	81
		height:	42
		z index: 1
		mask: /magic-new.mse-style/ptmask.png
		visible: { card.pt != "" }
		render style: image
		image: { card_ptbox() }
	emblem:
		left: 117
		top: { if styling.separated_watermark == "no" then 321 else if contains(styling.separated_watermark, match: "above") then 328 else 399 }
		top: 321
		width: 138
		height: { if contains(styling.separated_watermark, match: "yes") then 71 else 156 }
		z index: 4
		render style: image
		alignment: middle center
		include file: /magic-watermarks-extra.mse-include/watermarks
	frame:
		left:	0
		top:	0
		width:	375
		height:	523
		z index: 0
		render style: image
		popup style: in place
		image: { card_background() }
	foil layer:
		left: 0
		top : 0
		width: 375
		height: 523
		z index: 6
		render style: image
		mask: {if not styling.foil_art then "no_art_foil_mask.png" else nil}
		image: {if styling.overlay == "" then nil else set_combine(input: styling.overlay + "/overlay.png", combine: styling.overlay_combine_type)}
	creator computer:
		left: { 60 + card_style.illustrator.content_width }
		top: 478
		width: 20
		height: 16
		z index: 5
		visible: { styling.card_creator != "" }
		font:
			name: Wingdings
			size: 11
			weight: bold
			color: { styling.artist_font_color }
	creator:
		left: { if styling.card_creator != "" then 78 + card_style.illustrator.content_width else 400}
		top: 478
		width: { 195 - card_style.illustrator.content_width }
		height: 16
		z index: 5
		font:
			name: Matrix
			size: 10
			weight: bold
			color: { styling.artist_font_color }
	value:
		#left: 328 <- this puts the value in the upper right corner
		left: 23
		top : 67
		width: 15
		height: 23
		alignment: middle center
		font:
			name: ModMatrix
			size: 17
			shadow color: rgb(255,255,255)
			shadow blur: 6
			shadow displacement x: 0
			shadow displacement y: 0
		z index: 5
	value box:
		#left: 318 <- this puts the value in the upper right corner
		left: 13
		top : 64
		width: 35
		height: 29
		alignment: middle center
		render style: image
		popup style: in place
		z index: 4
		choice images:
			treasure: treasure.png
			poison: poison.png
	promo label:
		left: 40
		top : 262
		width: 295
		height: 29
		alignment: middle right
		z index: 4
		font:
			name: { if contains(styling.extras, match:"holiday text") then "MagicMedieval" else "ModMatrix" }
			size: 14
			color: { if contains(styling.extras, match:"holiday text") then rgb(217,0,0) else rgb(223,169,41) }
	clock watermark:
		left: 30
		top: 327
		width: 312
		height: 143
		z index: 4
		render style: image
		image: clock_watermark.png
		visible: { contains(styling.extras, match: "clock watermark") }
	scales watermark:
		left: 30
		top: 327
		width: 312
		height: 143
		z index: 4
		render style: image
		image: {set_alpha("scales_watermark.png", alpha: 0.5)}
		visible: { contains(styling.extras, match: "scales watermark") }
	mtgs rarity 1:
		right: 342
		top : 297
		width: 44
		height: 22
		z index: 4
		render style: image
		alignment: middle right
		visible: { contains(styling.extras, match:"mtgsalvation rarity") }
		image: 
			script:
				symbol_variation(
					symbol: "mtgs1.mse-symbol",
					fill_type: "linear gradient",
					border_radius: 0.07,
					border_color_1: rgb(0,0,0),
					border_color_2: rgb(0,0,0),
					fill_color_1: rgb(63,119,188),
					fill_color_2: rgb(135,178,231),
					center_x: 0.5,
					center_y: 0.5,
					end_x: 0.4,
					end_y: 0.4
				)
	mtgs rarity 2:
		right: 342
		top : 297
		width: 44
		height: 22
		z index: 4
		render style: image
		alignment: middle right
		visible: { contains(styling.extras, match:"mtgsalvation rarity") }
		image: 
			script:
				symbol_variation(
					symbol: "mtgs2.mse-symbol",
					fill_type: "linear gradient",
					border_radius: 0.07,
					border_color_1: rgb(0,0,0),
					border_color_2: rgb(0,0,0),
					fill_color_1: rgb(133,133,133),
					fill_color_2: rgb(205,204,204)
					center_x: 0.5,
					center_y: 0.5,
					end_x: 0.4,
					end_y: 0.4
				)
	mtgs rarity 3:
		right: 342
		top : 297
		width: 44
		height: 22
		z index: 4
		render style: image
		alignment: middle right
		visible: { contains(styling.extras, match:"mtgsalvation rarity") }
		image: 
			script:
				symbol_variation(
					symbol: "mtgs3.mse-symbol",
					fill_type: "linear gradient",
					border_radius: 0.07,
					border_color_1: rgb(0,0,0),
					border_color_2: rgb(0,0,0),
					fill_color_1: rgb(193,32,38),
					fill_color_2: rgb(220,117,122)
					center_x: 0.5,
					center_y: 0.5,
					end_x: 0.4,
					end_y: 0.4
				)
	mtgs rarity 4:
		right: 342
		top : 297
		width: 44
		height: 22
		z index: 4
		render style: image
		alignment: middle right
		visible: { contains(styling.extras, match:"mtgsalvation rarity") }
		image: 
			script:
				symbol_variation(
					symbol: "mtgs4.mse-symbol",
					fill_type: "linear gradient",
					border_radius: 0.07,
					border_color_1: rgb(0,0,0),
					border_color_2: rgb(0,0,0),
					fill_color_1: rgb(56,184,74),
					fill_color_2: rgb(117,217,131)
					center_x: 0.5,
					center_y: 0.5,
					end_x: 0.4,
					end_y: 0.4
				)
	mtgs rarity 5:
		right: 342
		top : 297
		width: 44
		height: 22
		z index: 4
		render style: image
		alignment: middle right
		visible: { contains(styling.extras, match:"mtgsalvation rarity") }
		image: 
			script:
				symbol_variation(
					symbol: "mtgs5.mse-symbol",
					fill_type: "linear gradient",
					border_radius: 0.07,
					border_color_1: rgb(0,0,0),
					border_color_2: rgb(0,0,0),
					fill_color_1: rgb(183,174,68),
					fill_color_2: rgb(250,237,92)
					center_x: 0.5,
					center_y: 0.5,
					end_x: 0.4,
					end_y: 0.4
				)
	identity:
		left: 34
		top: 299
		width: 17
		height: 17
		z index: 2
		render style: image
		visible: { has_identity() }
		image: { card_identity() }
