#### Localization
#### Common files
#### Versioning
#### Common filters
#### Utility scripts
#### Card characteristics
#### Sorting mana symbols
#### Mainframe mana
#### Determine card color
#### Card number
#### Statistics utilities
#### Keyword utilities
#### The text box
#### Face code
#### Level margins
#### Saga witchery
#### Typelines
#### Modal DFC flag hints
#### Flavor bar
#### Watermarks
#### Other scripted fields
#### Custom corner symbols
#### Custom fonts
#### Custom rarity symbol
#### Card column sorting
#### Custom index
#### Skeleton generator
#### Hashes

############################################################## Localization
include file: language
############################################################## Common files
include file: statistics_script
include file: /magic-blends.mse-include/new-blends
############################################################## Versioning
version_date := {"2025-02-01 Template Pack 3.1.c: Mainframe Battles - isfront Face Code"}
version := version_date
############################################################## Common filters
############################################################## Utility
comma_count :=     filter_text@(match:",")
semicolon_count := filter_text@(match:";")

split_comma :=     split_text@(match: " *, *")
split_semicolon := split_text@(match: " *; *")
line_count :=      split_text@(match:"\n+",include_empty:false) + length
px_split :=        split_text@(match:"p?x",include_empty:false)

word_count :=      break_text@(match:"[^[:space:]]+") + length

has_png :=         contains@(match:".png")
has_none :=        contains@(match: "none")

starts_vowel :=    match@(match:"[aâäàáeêëèéiîïìíoôöòóuûüùúAÂÄÀÁEÊËÈÉIÎÏÌÍOÔÖÒÓUÛÜÙÚ]")
ends_dash :=       match@(match: "/$")

remove_comma :=    replace@(match: ",", replace: "")
long_dash :=       replace@(match:"-", replace:"—")
softline_ripper := replace@(match:"</?soft-line>", replace:"")
un_png :=          replace@(match:".png", replace: "")
to_title :=        replace@(match:"(^| )([A-z])([^ ]*)", replace:{_1+ to_upper(_2) + to_lower(_3)})
to_sentence :=     replace@(match:"(^|\n)([A-z])([^\n]*)", replace:{_1+ to_upper(_2) + to_lower(_3)})
remove_zwsp :=     replace@(match:"​", replace:"")

#### Replace spaces by a spacer
separate_words :=  remove_tags + trim + replace@(match:" ", replace: {spacer})
zwsp :=            "​" # this is a zero-width space not blank
is_blank := { input == "" or input == zwsp }

############################################################## Type
is_creature :=     lang_setting("is_creature")
is_tribal :=       lang_setting("is_tribal")
is_kindred :=      lang_setting("is_kindred")
is_artifact :=     lang_setting("is_artifact")
is_land :=         lang_setting("is_land")
is_enchantment :=  lang_setting("is_enchantment")
is_spell :=        lang_setting("is_spell")
is_sorcery :=      lang_setting("is_sorcery")
is_instant :=      lang_setting("is_instant")
is_planeswalker := lang_setting("is_planeswalker")
is_legendary :=    lang_setting("is_legendary")
match_vehicle :=   lang_setting("is_vehicle")
match_snow :=      lang_setting("is_snow")
is_aura :=         match@(match: "(?i)Aura")
is_creaturish :=   { is_creature(input) or match_vehicle(input) }
is_battle :=       lang_setting("is_battle")
is_dungeon :=      lang_setting("is_dungeon")
is_emblem :=       lang_setting("is_emblem")
is_plane :=        lang_setting("is_plane")
############################################################## Text
is_modal :=        contains@(match:"<li>")

############################################################## Utility scripts
reverse_elements := {for element from 1 to length(input) do input[length(input) - element] + " "}
clamp := {
	number := to_number(input)
	if number < minimum then minimum
	else if number > maximum then maximum
	else number
}
to_number_lax := { to_number(input) or else to_number(trim(input)) or else 0 }
round_near := { if input < 0 then to_int(input-0.5) else to_int(input+0.5) }
#### 0.99999999999999 == 1, leave the 8
round_up := {
	if input < 0
		then to_int(input-0.99999999999998)
	else to_int(input+0.99999999999998)
}

#### type_name("string") returns string ("string") so fix that
#### type_name(nil) is fine
remove_paren := replace@(match:" \\(.*", replace:"")
type_of := {
	remove_paren(type_name(input))
}
#### reads from a comma separated list like an array
pull_comma_array := {
	array := split_comma(input)
	if cell >= (length(comma_count(input)) + (1 - to_number(end)))
		then default
	else if array[cell] == "" or array[cell] == nil or array[cell] == "-"
		then default
	else array[cell]
}@(default:0, end: 1, cell:0)
#### standard is pull_comma_array("X,Y,Z,", cell: 0)
#### returns "X"
#### end true for coordinates (requires a final divider to ensure element is complete)
#### end false for moving (doesn't require divider, moving 1 then 11 is fine)
#### can also add default to return in case of errors

#### a workaround for the crop offset function that doesn't appear to work
#### slice_crop(input:image, height:(final height), width:(final width), distance:(length from bottom to top of final image))
slice_crop := {
	img := flip_vertical(input)
	img := crop(img, height:distance, width:width, offset_x:0, offset_y:0)
	img := flip_vertical(img)
	img
	if(height != 0 and height != distance) then
		img := crop(img, height:height, width:width, offset_x:0, offset_y:0)
	img
}@(height:0)
#### a crop function that checks bounds first to avoid a crash
crop_safe :=
{
	if		offset_x < 0
		or	offset_y < 0
		or	width < 1
		or	height < 1
		or	offset_x + width > max_x
		or	offset_y + height > max_y
	then ""
	else crop(input, offset_x: offset_x, offset_y: offset_y, width: width, height: height)
}
#### pad a string from the front or back or both idk i'm not your dad
fill_len := {
	output := to_string(input)
	if output == "" then output := "0"
	fill := max(0,fill_to - length(output))
	for x from 1 to fill do output := lead + output + follow;
	output	
}@(fill_to:2, lead:"", follow:"")

#### simple array join function
join := {
	len := length(input)-1
	if len < 0
		then ""
	else for x from 0 to len do input[x] + (if x == len then "" else sep)
}@(sep:",")
#### join array into list format
join_list := {
	string := ""
	if length(input) == 2 then spacer := " "
	if length(input) == 1 then closing := ""
	for x from 0 to length(input)-1 do
		string := string + (if x == length(input)-1 then closing else "") + input[x] + (if x == length(input)-1 then "" else spacer)
	string
}@(spacer:", ", closing:"and ")

#### workarounds cause position() is broken for text arrays
#### where reasonable, you can use position(of:["str"], in:[["list"], ["of"], ["str"]]) instead
contains_element := {
	if input == [] then false else length(filter_list(input, filter:{input == element})) > 0
}
ar_position := {
	pos := -1
	for x from 0 to length(in)-1 do (
		if in[x] == of then pos := x;
	)
	pos
}
includes := {ar_position(of:input in:array) != -1}
unique_elements := {
	e1 := []
	e2 := []
	e1 := e1 + for x from 0 to length(of)-1 do if ar_position(of:of[x], in:from) == -1 then [of[x]]
}

#### This blends a map of images together
#### i dont remember why
#### i think i tested it for dungeons
#### example img_map := ["up":"test/up.png" "down":"test/down.png" "left":"test/left.png" "right":"test/right.png"]
multi_choice_image := {
	#### input   = option string
	#### img_map = map of image links
	coll := split_text(input, match:", ?")
	imgs := for each x in coll do if img_map[x] or else false != false then [img_map[x]]
	len := length(imgs)
	if len == 0 then
		""
	else if len == 1 then
		imgs[0]
	else if len == 2 then
		combine_blend(image1:imgs[0] image2:imgs[1], combine:combine)
	else mass_combine(imgs:imgs, combine:combine)
		
}@(combine:"and")
mass_combine := {
	base := combine_blend(image1:imgs[0] image2:imgs[1], combine:combine)
	for x from 2 to length(imgs)-1 do (
		base := combine_blend(image1:base image2:imgs[x] combine:combine)
		"" #### this is junk output so it doesn't try to add the images as strings
	)
	base
}@(combine:"and")

get_alpha_percentage :=
{
	alpha_value :=	if input == "" then default
					else to_number(input) or else default
	if alpha_value < 0 then 0.0
	else if alpha_value <= 100 then alpha_value/100.0
	else 1.0
}


############################################################## For the user
#### Remove card codes
cc_filter := replace@(match:"^[CURMSL][WUBRGMZACL][0-9]+ ?[-—]? ?", replace:"")
has_alchemy := contains@(match:"alchemy")
strip_card_codes := {
	save := input
	input := cc_filter(input)
	input := if input == "" or input == " " then save else input
	if atom and has_alchemy(card.card_symbol)
		then "<sym>A-</sym>" + input
	else input
}@(atom:false)
name_default := { "" }
name_checker := {if not set.remove_card_codes then input else strip_card_codes(input)}

#### Print fix
rare_width := {
	cw := card_style.rarity.content_width
	cw := if cw > 44 then (if set.print_fix != "" then set.print_fix else 22) else if cw < 22 then 22 else cw
	if card_style.rarity.width == 0 then 0 else cw
}

############################################################## Card characteristics
############################################################## Name
has_two_names := {
	sh := card.shape
		contains(sh, match:"adventure")
	or	contains(sh, match:"aftermath")
	or	contains(sh, match:"double faced")
	or	contains(sh, match:"flip")
	or	contains(sh, match:"split")
}
card_full_name_default := { if has_two_names() then card.name + " // " + card.name_2 else card.name }
card_full_name := { if has_two_names() then card.name + " // " + card.name_2 else card.name }
#### exportname
exporter_name_filter := filter_text@(match:"!exporte?r?name [^\n!]+")
exporter_name_grabber := replace@(match:"!exporte?r?name ", replace:"")
export_name := { exporter_name_grabber(exporter_name_filter(card.notes)) }
clean_name := remove_tags + 
	replace@(match:"(\n| +$|^ +)", replace:"") +
	replace@(match:"’", replace:"'")
	
card_name := { 
	test_name := export_name()
	if test_name == "" then test_name := card.name
	clean_name(test_name)
}
dfc_splitter_name := {
	back_name := card.name_2
	full_name := card_name()
	if back_name != "" then full_name := full_name + "_" + clean_name(back_name)
	full_name
}
############################################################## Special text
special_text :=                  { "" }
special_text2 :=                 { "" }
transfer_levels :=               {true}
transfer_levels_2 :=             {true}
a_saga :=                        {false}
saga_reminder :=                 { "As this Saga enters and after your draw step, add a lore counter. Sacrifice after III." }
b_saga :=                        {false}
saga_reminderb :=                { "As this Saga enters and after your draw step, add a lore counter. Sacrifice after III." }
is_mainframe :=                  { false }
mainframe_walker :=              {false}
mainframe_walker_text_script :=  {combined_editor(field1: card.level_1_text, separator1: "<line>\n</line>", field2: card.level_2_text, separator2: "<line>\n</line>", field3: card.level_3_text)}
mainframe_walkerb :=             {false}
mainframe_walker_text_scriptb := {combined_editor(field1: card.level_5_text, separator1: "<line>\n</line>", field2: card.level_6_text, separator2: "<line>\n</line>", field3: card.level_7_text)}
mainframe_walkerc :=             {false}
mainframe_walker_text_scriptc := {combined_editor(field1: card.level_9_text, separator1: "<line>\n</line>", field2: card.level_10_text, separator2: "<line>\n</line>", field3: card.level_11_text)}
mainframe_walkerd :=             {false}
mainframe_walker_text_scriptd := {combined_editor(field1: card.level_13_text, separator1: "<line>\n</line>", field2: card.level_14_text, separator2: "<line>\n</line>", field3: card.level_15_text)}
alt_text :=                      {false}
alt_text_script :=               {false}
alt_textb :=                     {false}
alt_text_scriptb :=              {false}
alt_textc :=                     {false}
alt_text_scriptc :=              {false}
alt_textd :=                     {false}
alt_text_scriptd :=              {false}

############################################################## Shape
#### Shape of cards, can be changed in style files
card_shape := { "normal" }
token_shape := {
	case input of
		"token": true,
		"emblem": true,
		"counter": true,
		"rulestip": true,
		"checklist": true,
		else: false;
}
#### used by pack scripts
is_token_card :=   { token_shape(card.shape) }
is_shifted_card := { contains(card.shape, match:"shifted") }
is_masterpiece :=  { card.rarity == "masterpiece" }
is_promo :=        { false }
rarity_field :=    { if input <= 1 then card.rarity else card["rarity_" + input] }
is_rare :=
{
	rarity := rarity_field(field)
	rarity == "rare" or rarity == "mythic rare" or rarity == "masterpiece"
}@(field: 1)

type_field :=
{
	if input <= 1 then card.type else card["type" + input]
}

is_walker :=
{ 
	lang_setting("is_planeswalker")(type_field(face))
}@(face:1)

is_legend :=
{ 
	lang_setting("is_legendary")(type_field(face))
}@(face:1) 
############################################################## Identity
cull_directions := replace@(match:", (horizontal|vertical|radial|overlay|reversed)", replace:"")
cull_noncolors := replace@(match:"(, )?(artifact|land|multicolor|hybrid|colorless)", replace:"")
colors_from_mana_symbols := {
	str := []
	if contains(input, match:"W") then str := str + ["white"]
	if contains(input, match:"U") then str := str + ["blue"]
	if contains(input, match:"B") then str := str + ["black"]
	if contains(input, match:"R") then str := str + ["red"]
	if contains(input, match:"G") then str := str + ["green"]
	
	join(str, sep:", ")
}
has_identity_general := {
	tag := if face == 1 then "" else "_" + face
	indicator_field := card["indicator"+tag]
	culled_indicator := cull_noncolors(cull_directions(indicator_field))

	if culled_indicator == ""
		then false ## invalid indicator, don't show it
	else (
		color_field 	:= card["card_color"+tag]
		cost_field 		:= card["casting_cost"+tag]
		culled_color	:= cull_directions(cull_noncolors(color_field))

		default_from_casting_cost := colors_from_mana_symbols(cost_field)
		default_from_card_color := if chosen(color_field, choice:"colorless")
				then ""							## colorless
			else if default_from_casting_cost == "" and chosen(color_field, choice:"land")
				then ""							## land
			else if chosen(color_field, choice:"multicolor") and culled_color == ""
				then default_from_casting_cost	## 3+ multicolor
			else culled_color					## normal color
		
		color_cost_disagree := default_from_card_color != default_from_casting_cost
		color_indicator_disagree := default_from_card_color != culled_indicator and indicator_field != color_field

		color_cost_disagree or color_indicator_disagree
	)
}
has_identity   := { has_identity_general(face:1) }
has_identity_2 := { has_identity_general(face:2) }
has_identity_3 := { has_identity_general(face:3) }
############################################################## Exporter utility
exporter_num_filter := filter_text@(match:"!num [^\n!]+")
exporter_num_grabber := replace@(match:"!num ", replace:"")
trim_zeroes := replace@(match: "^00?", replace: "")+
	replace@(match: "a?/[0-9b]+", replace: "")
corrected_card_number := { if exporter_num_grabber(exporter_num_filter(card.notes)) != "" then exporter_num_grabber(exporter_num_filter(card.notes)) else if card.custom_card_number != "" then trim_zeroes(card.custom_card_number) else card_number() }

crop_multi_image := {
	image_map := hash_new()
	sts := card.stylesheet
	if sts == nil then sts := set.stylesheet
	m3in1 := sts.full_name == "M15 Style Meld cards (3-in-1)"
	three_cards := false
	cs := get_card_styling(card)
	if m3in1 and cs.three_cards or else false then three_cards := true
	card_image := to_card_image(card)
	len := length(sts.card_regions)
	for i from 0 to len-1 do (
		region_info := sts.card_regions[i]
		if m3in1 and three_cards and (region_info.name == "front" or region_info.name == "meldback")
			then ""
		else if m3in1 and (not three_cards) and (region_info.name != "front" and region_info.name != "meldback")
			then ""
		else (
			region := crop(card_image, height:region_info.height, width:region_info.width, offset_x:region_info.x, offset_y:region_info.y)
			image_map := hash_create(image_map, key:region_info.name, value:region);
			"dummy return"
		)
	)
	image_map
}

############################################################## Sorting mana symbols
#### correctly sort a mana symbol (no guild mana)
mana_sort := sort_text@(order: "\\?XYZI[0123456789]VLHSFCAIE(WUBRG)") 
#### correctly sort wedge mana
mana_sort_wedge := sort_text@(order: "\\?XYZI[0123456789]VLHSFCAIE(WBGUR)")
#### sort nothing
mana_unsort := sort_text@(order:"[/\\?XYZI0123456789VLHSCAIEOPKMWUBRG]")
#### correctly sort guild mana
mana_sort_guild := sort_text@(order: "[\\?XYZI01234567890VLHSFCAIEWUBRG/|]") +
		replace@(
			#### No lookbehind :(
			#match: "(?<!/)(./.|././.|./././.|.[|])(?!/)",
			match: "./.|././.|./././.|.[|]",
			in_context: "(^|[^/])<match>($|[^/])",
			replace: {sort_text(order:"in_place((WUBRG))")}
		)
#### mana filter helpers
mana_has_guild := match@(match: "[/|]") #### Is there guild or half mana in the input?
mana_is_wedge := { chosen(set.mana_cost_sorting, choice: "tarkir wedge sorting") and ( number_of_items(in: sort_text(order:"<WUBRG>", input), filter: "<WUBRG>") == 3 ) }
mana_has_wedge := {  
	wedge_check := sort_text(order:"<WUBRG>", input)
	mana_is_wedge() and (wedge_check == "WUR" or wedge_check == "WBR" or wedge_check == "WBG" or wedge_check == "UBG" or wedge_check == "URG")
}

#### A mana cost can contain both normal and guild mana
mana_filter := to_upper + {
	if chosen(set.mana_cost_sorting, choice: "unsorted") then mana_unsort()
	else if mana_has_guild() then mana_sort_guild()
	else if mana_has_wedge(input) then mana_sort_wedge(input)
	else                     mana_sort()
}
#### prevent infinite tap symbol glitch
tap_reduction :=
	replace@(match:"T+", replace:"T")+
	replace@(match:"Q+", replace:"Q")
#### only allow tickets
ticket_isolate := filter_text@(match:"(TK)+")
#### remove ticket Ts from tap filter
tap_filter := replace@(match:"(TK)+", replace:"")+
	sort_text@(order: "<TQ>")
#### Like mana filter, only also allow tap symbols:
mana_filter_t := replace@(               #### Remove [] used for forcing mana symbols
			match: "[\\[\\]]",
			replace: ""
		) + { tap_reduction(tap_filter()) + mana_filter() }


card_is_wedge := {
	color_string := card_color_to_letters(input)
	if color_string == "WUR" or color_string == "WBR" or color_string == "WBG" or color_string == "UBG" or color_string == "URG" then true else false
}

############################################################## Symbol font defaults
mana_t :=
{
	field := styling.tap_symbol or else "new"
	if field == "diagonal T" then "older"
	else if field == "old" then "old"
	else "new"
}
mana_s := { "new" }
small_mana_t := "mana_t.png"
symbol_font_color := { rgb(0,0,0) }
symbol_font_alpha := { 1.0 }
guild_mana :=
{
	styling.use_guild_mana_symbols or else false
}
ancestral_mana :=
{
	field := styling.other_options or else nil
	if field == nil then (styling.use_ancestral_mana_symbols or else false)
	else contains(field, match:"ancestral generic")
}
white_text := { false }
symbol_font_small_color := { body_font_color() }

#### Script to make magic-mana-future compatible w/ other templates
colorless_color := {
	cc := card.card_color
	if contains(cc, match:"hybrid") or contains(cc, match:"multicolor") then "c"
	else if cc == "white" then "w"
	else if cc == "blue" then "u"
	else if cc == "black" then "b"
	else if cc == "red" then "r"
	else if cc == "green" then "g"
	else "c"
}

############################################################## Mainframe mana
use_v_mana := {contains(set.custom_mana_symbol_name, match:".png")}
use_large_v_mana := { use_v_mana() and chosen(set.mana_symbol_options, choice:"enable in casting costs")}
use_small_v_mana := { use_v_mana() and chosen(set.mana_symbol_options, choice:"enable in text boxes")}
use_color_v_mana := { use_v_mana() and chosen(set.mana_symbol_options, choice:"colored mana symbols") and not use_hybrid_v_mana()}
use_hybrid_v_mana := { use_v_mana() and chosen(set.mana_symbol_options, choice:"hybrid with colors")}
v_mana_name := {if not use_v_mana() then "" else replace(set.custom_mana_symbol_name, match:"(.+/|\\.png)", replace:"")}
v_mana_loc := {if not use_v_mana() then "" else replace(set.custom_mana_symbol_name, match:"{v_mana_name()}\\.png", replace:"")}
v_mana_num := {max(to_number(set.number_hybrid_variants),0) or else -1}
############################################################## Determine card color
#### Names of colors
color_name := {
	if      input == "W" then "white"
	else if input == "U" then "blue"
	else if input == "B" then "black"
	else if input == "R" then "red"
	else if input == "G" then "green"
	else                     ""
}
mana_name := {
	if      input == "white" then "W"
	else if input == "blue" then "U"
	else if input == "black" then "B"
	else if input == "red" then "R"
	else if input == "green" then "G"
	else                     "C"
}
color_names_1 := { color_name(colors.0) }
color_names_2 := { color_name(colors.0) + ", " + color_name(colors.1) }
color_names_3 := { color_name(colors.0) + ", " + color_name(colors.1) + ", " + color_name(colors.2) }
color_names_4 := { color_name(colors.0) + ", " + color_name(colors.1) + ", " + color_name(colors.2) + ", " + color_name(colors.3) }
color_names_5 := { color_name(colors.0) + ", " + color_name(colors.1) + ", " + color_name(colors.2) + ", " + color_name(colors.3) + ", " + color_name(colors.4) }
#### color based on mana cost, input == a mana cost
color_filter := sort_text@(order: "<WUBRG>")
color_filterH := sort_text@(order: "</>")
mana_to_color := {
	count := number_of_items(in: colors)
	if hybrid == "" and contains(type, match:"Artifact") then
		#### not a hybrid, but artifact
		if      count == 0 then  "artifact"
		else if count == 1 then  color_names_1() + ", artifact"
		else if set.set_info.use_gradient_multicolor == "no"  then "artifact, multicolor" #### stop here
		else if count == 2 then  color_names_2() + ", artifact, multicolor"
		else if set.set_info.use_gradient_multicolor != "yes" then "artifact, multicolor" #### stop here
		else if count == 3 then  color_names_3() + ", artifact, multicolor"
		else if count == 4 then  color_names_4() + ", artifact, multicolor"
		else if count == 5 then  color_names_5() + ", artifact, multicolor"
		else                     "artifact, multicolor"
	else if hybrid == "" then
		#### not a hybrid, not artifact
		if      count == 0 then  "colorless"
		else if count == 1 then  color_names_1()
		else if set.set_info.use_gradient_multicolor == "no"  then "multicolor" #### stop here
		else if count == 2 then  color_names_2() + ", multicolor"
		else if set.set_info.use_gradient_multicolor != "yes" then "multicolor" #### stop here
		else if count == 3 then  color_names_3() + ", multicolor"
		else if count == 4 then  color_names_4() + ", multicolor"
		else if count == 5 then  color_names_5() + ", multicolor"
		else                     "multicolor"
	else if contains(type, match:"Artifact") then
		#### hybrid, but artifact
		if count == 0 then "artifact"
		else if count == 1 then color_names_1() + ", artifact"
		else if count == 2 then  color_names_2() + ", artifact"
		else                     "artifact, multicolor"
	else
		#### hybrid, not artifact
		if count == 0 then "colorless"
		else if count == 1 then color_names_1()
		else if count == 2 then  color_names_2() + ", hybrid"
		else                     "multicolor"
}

#### color based on land text box, input == textbox contents
color_text_filter :=
	#### remove activation costs
	replace@(
		match: "<sym[^>]*>[^<]+</sym[^>]*>"
		in_context: "(?ix) (\\n|^)[^:]*<match>(,|:) | (pays?|additional|costs?)[ ]<match>",
		replace: ""
	) +
	#### keep only mana
	filter_text@(match: "<sym[^>]*>([^<]+)") + color_filter;
#### get the land frame for a "WUBRG"-style input.
land_multicolor := {
	count := number_of_items(in: colors)
	if      count == 0 then "land"
	else if count == 1 then color_names_1() + ", land"
	else if count == 2 then color_names_2() + ", land"
	else                    "land, multicolor"
}
land_to_color := {
	#### Based on watermark
	if      watermark == "mana symbol white" then "white, land"
	else if watermark == "mana symbol blue"  then "blue, land"
	else if watermark == "mana symbol black" then "black, land"
	else if watermark == "mana symbol red"   then "red, land"
	else if watermark == "mana symbol green" then "green, land"
	else land_multicolor(colors:color_text_filter(input: rules))
}@(rules:card.rule_text)

#### Look for a CDA that defines colors
text_to_color := {
	#### Note: running filter_text is quite slow, do a quick 'contains' check first
	if contains(match: card_name + " is") then (
		text := filter_text(match: "is (colorless|all colors|((blue|white|green|red|black)((,|,? and) (blue|white|green|red|black))*))", in_context: regex_escape(card_name)+"(</[-a-z]+>)* <match>\\.")
		if text != "" then (
			if contains(text, match: "all colors") then (
				colors := "WUBRG"
				if land == true then land_multicolor()
				else mana_to_color(hybrid: "")
			) else (
				colors := ""
				if contains(text, match: "white") then colors := colors + "W"
				if contains(text, match: "blue")  then colors := colors + "U"
				if contains(text, match: "black") then colors := colors + "B"
				if contains(text, match: "red")   then colors := colors + "R"
				if contains(text, match: "green") then colors := colors + "G"
				if land == true then land_multicolor()
				else mana_to_color(hybrid: "")
			)
		)
		else ""
	)
	else ""
}
#### The color of a card
card_color := {
	#### usually the color of mana
	text_color := text_to_color(rules_text, land: is_land(type));
	if text_color == "" then (
		mana_color := mana_to_color(colors: color_filter(casting_cost), hybrid: color_filterH(casting_cost))
		if		mana_color == "colorless" and is_land    (type)  then land_to_color(watermark, rules:rules_text)
		else if	mana_color == "colorless" and is_artifact(type)  then "artifact"
		else if	mana_color == "colorless" and contains(card.shape, match:"flip") then default
		else mana_color
	)
	else text_color
};
#### Number of colors in a card_color
card_color_color_count := count_chosen@(choices: "white,blue,black,red,green,artifact")
#### Clean up color field
card_color_filter := {
	colors := card_color_color_count()
	if colors > 2 then
		input := remove_choice(choice: "overlay")
	if colors > 1 then (
		input := require_choice(choices: "multicolor, hybrid, land, artifact")
		input := exclusive_choice(choices: "multicolor, hybrid")
		input := require_exclusive_choice(choices: "horizontal, vertical, radial, overlay")
	) else
		input := remove_choice(choices: "radial, horizontal, vertical, overlay, hybrid, reversed")
	if chosen(choice:"overlay") then
		input := remove_choice(choice: "reversed")
	input
}
#### convert card color to "white, blue, and black" etc for reminder text
list_colors := {
	list := trim_colors(input)
	cc := length(comma_count(list))
	if cc == 1 then
		list := replace(list, match:", ", replace:" and ")
	if cc > 1 then
		list := replace(list, match:", ", replace:", and ", in_context:"<match>[^ ]+$")
	list
}
#### convert card_color to WUBRG
card_color_to_letters := {
	color_string := trim_colors(input)
	 (if contains(color_string, match:"white") then "W" else "")
	+(if contains(color_string, match:"blue") then "U" else "")
	+(if contains(color_string, match:"black") then "B" else "")
	+(if contains(color_string, match:"red") then "R" else "")
	+(if contains(color_string, match:"green") then "G" else "")
}
card_color_field := { if input <= 1 then card.card_color else card["card_color_" + input] }

############################################################## Card number
#### The code consists of 4 parts:
####   partition, rarity tier, color, card name
#### remove filler text from partition select
partition_filter := replace@(match:"(before normal|after normal, main set|after main set|help.*) ?", replace:"")
partition_index := { 
	ind := partition_filter(card.partition_select)
	if ind == "" then ind := "A"
	ind
}
default_partition := {"A"}
#### determine if a card is "over-partition", ie should be excluded from the main set count
over_partition := {
	mn_pos := if set.last_main_partition == "" then "M" else to_upper(substring(set.last_main_partition, end:1))
	(partition_scores[partition_index()] or else 10) > (partition_scores[mn_pos] or else 22)
}
partition_scores := [
	0:0, 1:1, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:9,
	A:10, B:11, C:12, D:13, E:14, F:15, G:16, H:17, I:18,
	J:19, K:20, L:21, M:22, N:23, O:24, P:25, Q:26, R:27,
	S:28, T:29, U:30, V:31, W:32, X:33, Y:34, Z:35
]
#### MSE doesn't do "A" > "B" like some languages do
#### Originally this put partition_index() and mn_pos in an array and sorted that
#### but that crashed mse on startup once it was added to sort the card number column
#### but you also couldn't use position() because it inherits order_by and filter from card_number()
#### and MSE yells at you if you do that and you're not sorting a set
#### and replacing them with nil doesn't work, it still complains if they're nil???
#### so instead hard-coded map of indices
#### you'll never catch me i'm behind seven workarounds

#### Index for sorting, white cards are first, so white->A, blue->B, .. ,
sort_index := {
	color_of_card() +
	(if contains(card.shape, match:"shifted") then "S" else " ") + #### planeshifted cards come after normal ones
	(if contains(card.shape, match:"split")   then "S" else " ") + #### split cards come after normal ones
	":"
}
#### A code for the color of the card
color_of_card := {
	card_color := card.card_color
	casting_cost := card.casting_cost
	#type := card.super_type
	artifact := chosen(card_color, choice:"artifact")
	if	contains(card.shape, match: "split") and
		card_color != card.card_color_2 then "I"                         #### Diff Color Splits
	else if chosen(choice: "land", card_color) then (                    #### Lands
		if card.rarity != "basic land" then "L"                          #### Nonbasic Land
		else basic_land_sort()                                           #### Basic Land
	) else if is_null_cost(casting_cost) then (                          #### Non-Land Cards with no or zero costs.
		if chosen(choice: "colorless", card_color) then "A"              #### Clear Colorless
		else if chosen(choice: "hybrid", card_color)    then "HK"        #### Hybrids
		else if is_multicolor(card_color)          then "GK"             #### Multicolor
		else if chosen(choice:"white", card_color) then "B"              #### White
		else if chosen(choice:"blue", card_color)  then "C"              #### Blue
		else if chosen(choice:"black", card_color) then "D"              #### Black
		else if chosen(choice:"red", card_color)   then "E"              #### Red
		else if chosen(choice:"green", card_color) then "F"              #### Green
		else                                            "J"              #### Artifact
	) else (
		                                                                 #### Cards with costs.
		colors := sort_text(casting_cost, order: "<WUBRG>")
		if colors == "" and artifact then "J"    						#### Artifact
		else if colors == ""  then "A"                                   #### Clear Colorless
		else if colors == "W" then "B"                                   #### White
		else if colors == "U" then "C"                                   #### Blue
		else if colors == "B" then "D"                                   #### Black
		else if colors == "R" then "E"                                   #### Red
		else if colors == "G" then "F"                                   #### Green
		else if is_hybrid_cost() then hybrid_color_pair_sort()           #### Hybrid (by pairs)
		else if contains(casting_cost, match:"/") and artifact then "I"  #### Hybrid Artifacts
		else                       multi_color_pair_sort()               #### Multicolor (by pairs)
	)
}
is_null_cost := { input == "" or input == "0" }
is_multicolor := { chosen(choice: "multicolor") and input != "artifact, multicolor" }
is_hybrid_cost := { 
	casting_cost := card.casting_cost
	contains(casting_cost, match: "W/") or contains(casting_cost, match: "U/") or contains(casting_cost, match: "B/") or contains(casting_cost, match: "R/") or contains(casting_cost, match: "G/")
}
basic_land_sort := {
	name := card.name
	if contains(name, match:"Plains")        then "MB"      #### Plains
	else if contains(name, match:"Island")   then "MC"      #### Islands
	else if contains(name, match:"Swamp")    then "MD"      #### Swamps
	else if contains(name, match:"Mountain") then "ME"      #### Mountains
	else if contains(name, match:"Forest")   then "MF"      #### Forests
	else                                               "MA"      #### other basic lands
}
hybrid_color_pair_sort := {
	colors := sort_text(casting_cost, order: "<WUBRG>")
	if not set.sort_hybrid_in_pairs then "HK"
	else if colors == "WU" then "HA"
	else if colors == "UB" then "HB"
	else if colors == "BR" then "HC"
	else if colors == "RG" then "HD"
	else if colors == "WG" then "HE"
	else if colors == "WB" then "HF"
	else if colors == "UR" then "HG"
	else if colors == "BG" then "HH"
	else if colors == "WR" then "HI"
	else if colors == "UG" then "HJ"
	else "HK"
}
multi_color_pair_sort := {
	colors := sort_text(casting_cost, order: "<WUBRG>")
	if not set.sort_multicolor_in_pairs then "GK"
	else if colors == "WU" then "GA"
	else if colors == "UB" then "GB"
	else if colors == "BR" then "GC"
	else if colors == "RG" then "GD"
	else if colors == "WG" then "GE"
	else if colors == "WB" then "GF"
	else if colors == "UR" then "GG"
	else if colors == "BG" then "GH"
	else if colors == "WR" then "GI"
	else if colors == "UG" then "GJ"
	else if contains(card.casting_cost, match:"/") then "GL"
	else "GK"
}

#### Sort the card into its rarity tier
#### unsorted, regular cards, "after other cards" specials
#### "separate numbering" specials, masterpieces
#### tokens, emblems, rulestips, counters checklists
rarity_sort := {
	shape := card.shape
	if is_unsorted() then "R0"
	else if shape == "token" then "T1"
	else if shape == "emblem" then "T2"
	else if shape == "rulestip" then "T3"
	else if shape == "counter" then "T4"
	else if shape == "checklist" then "T5"
	else if is_masterpiece() then "S2"
	else if set.sort_special_rarity == "separate numbering" and card.rarity == "special" then "S1"
	else if set.sort_special_rarity == "with the rest" or card.rarity != "special" then "R1"
	else "R2"
}
#### do this to accurate represent partition sorting for the card number sorting column
rarity_partition_sort := {
	main := rarity_sort()
	main.0 + partition_index() + main.1
}

#### Process the name for sorting rules
sort_name :=
	#### Remove "The", "A", and "An" at the beginning
	replace@(match: "^(The|An?) ", replace: "") +
	#### Remove commas and apostrophes
	replace@(match: "(,|'|’)", replace: "") +
	#### Remove bold and italic tags
	replace@(match: "(<b>|<i>|</b>|</i>)", replace: "") +
	#### Make lowercase
	to_lower

#### given a card, return the function that returns all other cards that impact its card number
set_filter := {
	if is_unsorted() then 
		{ is_unsorted() }
	else if card.shape == "token" or card.shape == "emblem" then
		{ card.shape == "token" or card.shape == "emblem" }
	else if card.shape == "rulestip" then
		{ card.shape == "rulestip" }
	else if card.shape == "counter" then
		{ card.shape == "counter" }
	else if card.shape == "checklist" then
		{ card.shape == "checklist" }
	else if is_masterpiece() and not token_shape(card.shape) then
		{ is_masterpiece() and not token_shape(card.shape) }
	else if set.sort_special_rarity != "separate numbering" then
		{ not is_unsorted() and not token_shape(card.shape) and not is_masterpiece() }
	else if card.rarity == "special" then
		{ not is_unsorted() and not token_shape(card.shape) and card.rarity == "special" and not is_masterpiece() }
	else
		{ not is_unsorted() and not token_shape(card.shape) and card.rarity != "special" and not is_masterpiece() }
}
#### over-partition cards need to be counted during the card number count
#### but need to be skipped during the card count count
#### so this is a copy of set_filter but it skips over-partition cards
set_filter_under_partition := {
	if is_unsorted() then 
		{ is_unsorted() }
	else if card.shape == "token" or card.shape == "emblem" then
		{ card.shape == "token" or card.shape == "emblem" and not over_partition() }
	else if card.shape == "rulestip" then
		{ card.shape == "rulestip" and not over_partition() }
	else if card.shape == "counter" then
		{ card.shape == "counter" and not over_partition() }
	else if card.shape == "checklist" then
		{ card.shape == "checklist" and not over_partition() }
	else if is_masterpiece() and not token_shape(card.shape) then
		{ is_masterpiece() and not token_shape(card.shape) and not over_partition() }
	else if set.sort_special_rarity != "separate numbering" then
		{ not is_unsorted() and not token_shape(card.shape) and not over_partition() and not is_masterpiece() }
	else if card.rarity == "special" then
		{ not is_unsorted() and not token_shape(card.shape) and card.rarity == "special" and not over_partition() and not is_masterpiece() }
	else
		{ not is_unsorted() and not token_shape(card.shape) and card.rarity != "special" and not over_partition() and not is_masterpiece() }
}

#### user configurable additions to the set totals
card_number_offset := {pull_comma_array(set.card_number_offsets, cell:0, end:false, default:0)}
set_number_offset := {pull_comma_array(set.card_number_offsets, cell:1, end:false, default:0)}
#### the raw numbers, these aren't typically used directly
card_number := {
	position (
		of: card
		in: set
		order_by: { partition_index() + rarity_sort() + sort_index() + sort_name(card.name) + sort_name(export_name())}
		filter:   set_filter()
	) + 1 + to_number(card_number_offset())
}
card_count := {
	number_of_items(in: set, filter: set_filter_under_partition()) + to_number(set_number_offset())
}
#### Starting with M15, pad the collector number to three digits
card_number_m15 := {
	num := card_number()
	(if num < 100 then "0" else "") + (if num < 10 then "0" else "") + num
}
card_count_m15 := {
	num := card_count()
	(if num < 100 then "0" else "") + (if num < 10 then "0" else "") + num
}
#### Starting with MOM, pad the collector number to four digits
card_number_mom := {
	num := card_number()
	(if num < 1000 then "0" else "") + (if num < 100 then "0" else "") + (if num < 10 then "0" else "") + num
}
card_count_mom := {
	num := card_count()
	(if num < 1000 then "0" else "") + (if num < 100 then "0" else "") + (if num < 10 then "0" else "") + num
}
#### Determine a rarity code for M15 styles.
rarity_code := {
	rarity := card.rarity
	if not set.rarity_codes then ""
	else if is_promo() then "P"
	else if is_masterpiece() then "S"
	else if contains(card.shape, match:"token") then "T"
	else if contains(card.shape, match:"emblem") then "E"
	else if rarity == "common" then "C"
	else if rarity == "uncommon" then "U"
	else if rarity == "rare" then "R"
	else if rarity == "mythic rare" then "M"
	else if rarity == "special" then "S"
	else if rarity == "basic land" then "L" 
	else ""
}
is_unsorted := { false }
############################################################## Statistics utilities
#### Converted mana cost
is_half_mana :=    match@(match: "1/2|[|][WUBRGS]")
is_half_generic := match@(match: "1/2")
is_colored_mana := match@(match: "[WUBRG]")
only_numbers :=    filter_text@(match: "^[0123456789]+")
cmc_split :=       break_text@(match: "(?ix) 1/2 | [|][WUBRGC] | TK | [0-9](/[WUBRGCVLHSCETQ2]) | [0-9]+(?!/[WUBRGCVLHSCETQ2]) | [WUBRGCVLHS0-9](/[WUBRGCVLHS])\{0,4} ")
cmc := {to_number(
	for each sym in cmc_split(to_text()) do (
		numbers := only_numbers(sym)
		if is_half_mana(sym)  then 0.5
		else if numbers != "" then to_int(numbers)
		else                       1 #### all other symbols are 1
	))
}
mana_value := cmc
#### Remove supertypes or types to look at parts of the super_type field by themselves.
remove_supertype := replace@(match: "(Legendary|Basic|Snow|World|Tribal|Token)", replace: "")+
	replace@(match: "[ ]+", in_context: "^<match>", replace: "")+
	replace@(match: "[ ]+", in_context: "<match>$", replace: "")
remove_type := replace@(match: "(Artifact|Creature|Enchantment|Instant|Land|Planeswalker|Sorcery)", replace: "")+
	replace@(match: "[ ]+", in_context: "^<match>", replace: "")+
	replace@(match: "[ ]+", in_context: "<match>$", replace: "")

write_wubrg := {
	(if match(input, match:"white") then "W" else "")+
	(if match(input, match:"blue") then "U" else "")+
	(if match(input, match:"black") then "B" else "")+
	(if match(input, match:"red") then "R" else "")+
	(if match(input, match:"green") then "G" else "")
}
colored_mana := {to_number(
	for each sym in cmc_split(to_text()) do (
		numbers := only_numbers(sym)
		if is_colored_mana(sym) then
			if is_half_mana(sym) then 0.5 else 1
		else 0
	))
}
generic_mana := {to_number(
	for each sym in cmc_split(to_text()) do (
		numbers := only_numbers(sym)
		if is_half_generic(sym)  then 0.5
		else if numbers != "" then to_int(numbers)
		else                       0 #### all other symbols are 1
	))
}

primary_card_color := {
	artifact :=    chosen(choice:"artifact") and not (chosen(choice:"white") or chosen(choice:"blue") or chosen(choice:"black") or chosen(choice:"red") or chosen(choice:"green"))
	land :=        chosen(choice:"land")
	multi :=       chosen(choice:"multicolor")
	hybrid :=      chosen(choice:"hybrid")
	white :=       chosen(choice:"white")
	blue :=        chosen(choice:"blue")
	black :=       chosen(choice:"black")
	red :=         chosen(choice:"red")
	green :=       chosen(choice:"green")
	multi_color := count_chosen(choices:"white, blue, black, red, green")
	if      land                                           then "land"
	else if multi                                          then "multicolor"
	else if multi_color == 2 and chosen(choice:"artifact") then "hybrid"		#### hybrid artifacts would show as their first color
	else if hybrid                                         then "hybrid"
	else if artifact                                       then "artifact"
	else if white                                          then "white"
	else if blue                                           then "blue"
	else if black                                          then "black"
	else if red                                            then "red"
	else if green                                          then "green"
	else                                                        input
}
sparker_card_color := {
	artifact :=    chosen(choice:"artifact") and not (chosen(choice:"white") or chosen(choice:"blue") or chosen(choice:"black") or chosen(choice:"red") or chosen(choice:"green"))
	land :=        chosen(choice:"land")
	multi :=       chosen(choice:"multicolor")
	hybrid :=      chosen(choice:"hybrid")
	white :=       chosen(choice:"white")
	blue :=        chosen(choice:"blue")
	black :=       chosen(choice:"black")
	red :=         chosen(choice:"red")
	green :=       chosen(choice:"green")
	multi_color := count_chosen(choices:"white, blue, black, red, green")
	if      land                                           then "colorless"
	else if multi                                          then "multicolor"
	else if multi_color >= 2                               then "multicolor"
	else if hybrid                                         then "multicolor"
	else if artifact                                       then "artifact"
	else if white                                          then "white"
	else if blue                                           then "blue"
	else if black                                          then "black"
	else if red                                            then "red"
	else if green                                          then "green"
	else                                                        "colorless"
}

############################################################## Keyword utilities
trim_reminder_x := replace@(match: ". X can’t be 0.", replace: "")
has_cc :=          { card.casting_cost != "" }
has_pt :=          { card.power != "" or card.toughness != "" }
is_spell :=        { 
	type := if input != "" then input else card.type
	is_instant(type) or is_sorcery(type)
}@(input:"")
contains_target := match@(match:"(?i)([^a-z]|^)targets?([^a-z]|$)")
is_targeted :=     { contains_target(card.rule_text) }

#### convert color word to mana symbol
color_to_mana := replace@(match: "white", replace: "[W]")+
	replace@(match: "blue", 	replace: "[U]")+
	replace@(match: "black", 	replace: "[B]")+
	replace@(match: "red", 		replace: "[R]")+
	replace@(match: "green", 	replace: "[G]")

#### convert number word to digit
digital_number := {
	input := replace(input, match:"up to ", replace:"")
	result := input
	two_part := filter_text(input, match:"(twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety)")
	one_part := filter_text(input, match:"(zero|a|an|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen)\\b")
	if two_part != "" and one_part != "" then
		result := (digital_map[two_part] + digital_map[one_part]) or else input
	else if two_part != "" then
		result := digital_map[two_part] or else input
	else if one_part != "" then
		result := digital_map[input] or else input
	result
}
#### convert once, twice, "[number] times" to digit
iterate_digits := {
	trimmed := iterate_fix(input)
	if trimmed == "" then 1 else digital_map[trimmed] or else trimmed
}
iterate_fix := remove_tags
	+replace@(match: "^\\.", replace:"")
	+replace@(match: "^,", replace:"")
	+replace@(match: "^[ ]", replace:"")
	+replace@(match:" ti?m?e?s?$", replace:"")
iterate_string := {
	str := iterate_fix(input)
	if str == ""
		then empty_lead + empty + empty_follow
	else non_empty_lead + str + non_empty_follow
}@(non_empty_lead:" ", non_empty_follow:"", empty_lead:"", empty_follow:"", empty:"")
digital_map := [
	"zero": 0,
	"one": 1,
	"once": 1,
	"a": 1,
	"an": 1,
	"two": 2,
	"twice": 2,
	"three": 3,
	"thrice": 3,
	"four": 4,
	"five": 5,
	"six": 6,
	"seven": 7,
	"eight": 8,
	"nine": 9,
	"ten": 10,
	"eleven": 11,
	"twelve": 12,
	"thirteen": 13,
	"fourteen": 14,
	"fifteen": 15,
	"sixteen": 16,
	"seventeen": 17,
	"eighteen": 18,
	"nineteen": 19,
	"twenty": 20,
	"thirty": 30,
	"forty": 40,
	"fifty": 50,
	"sixty": 60,
	"seventy": 70,
	"eighty": 80,
	"ninety": 90
]
#### If the 'input' parameter is a mana costs, then adds 'add'
for_mana_costs := {
	if input.separator_before == "—" and contains(input.param, match: " ") then (											#### multi word
		if comma_count(input.param) == "," then (																			#### two part
			if match(match: "^[VLHSCAIETKQ\\?XYZIWUBRG0-9/|]+,", input.param) then													#### starts with mana
				"{add}<param-cost>{alternative_cost(input.param, trim:combined_cost, s:action)}</param-cost>"					#### "add" mana 
			else "<param-cost>{alternative_cost(input.param, trim:combined_cost, s:action)}</param-cost>{non}"					#### else cost "non"
		) else if contains(input.param, match: ",") then (																	#### three+ parts
			if match(match: "^[VLHSCAIETKQ\\?XYZIWUBRG0-9/|]+,", input.param) then													#### starts with mana
				"{add}<param-cost>{alternative_cost(input.param, trim:long_cost, s:action)}</param-cost>"						#### "add" mana with long formatting
			else "<param-cost>{alternative_cost(input.param, trim:long_nomana_cost, s:action)}</param-cost>{non}"				#### else cost "non" with long formatting
		) else
			"<param-cost>{alternative_cost(input.param, s:action, trim:lower_first)}{non}</param-cost>"						#### one, nonmana, part
	) else if match(match: "^[VLHSCAIETKQ\\?XYZIWUBRG0-9/|]+$", input.param) then											#### one word
		"{add}<param-mana>{input.param}</param-mana>"																		#### mana
	else
		"<param-cost>{alternative_cost(input.param, trim:combined_cost, s:action)}</param-cost>{non}"						#### nonmana
}@(non:" in addition to any other costs", action:false, add:"")

#### Convert extra costs
long_cost := replace@(match:", [A-Z]", replace: { to_lower() } )
long_nomana_cost := replace@(match:"[A-Z]", replace: { to_lower() })
#### Convert first character to lower case
lower_first := replace@(match:"^[A-Z]", replace: { to_lower() })
combined_cost := replace@(match:", [A-Z]", replace: { to_lower() })+
	replace@(match:",", replace:" and")+
	replace@(match:"^[VLHSCETKQ\\?XYZIWUBRG0-9/|]+", in_context: "(^|[[:space:]])<match>(?![a-z])", replace: "<sym-auto>&</sym-auto>")+
	replace@(match:"^[A-Z]", replace: { to_lower() })
alternative_cost := {
	input := trim(input)
	if s then
		input := actionize(input)
	input
}@(trim: lower_first, s:false, trim:{input})
actionize := replace@(match:"(activate|ante|cast|choose|create|destroy|discard|double|draw|exchange|exile|fight|mill|play|put|regenerate|return|reveal|sacrifice|shuffle|tap|untap|transform|vote|exert|pay)(?=($| |,|\\.))", replace:"\\1s")
	+replace@(match:"(attach)", replace:"\\1es")
	+replace@(match:"scry", replace:"scries")
	+replace@(match:"your", replace:"their")

#### determine if a reminder text should refer to this card or that card
this_or_that := {
	this :=  if upper then "This" else "this"
	that := if upper then "That" else "that"
	#### inherit type, creature override, or given type
	type := if input == "type"
				then to_lower(main_type(card.type))
			else if input != "card" and is_creaturish(card.type)
				then "creature"
			else input;

	this_that := if input == "creature" and not is_creaturish(card.type)
					then that #### ex. "Equipped creature has wither."
				else if is_spell(card.type) and not is_spell(type)
					then that #### ex. "Target creature gains wither."
				else this;

	#### sanitize
	type := if type == ""
				then "permanent"
			else if this_that == this and type == "artifact" and not is_artifact(card.type)
				then "permanent" #### ex. an enchantment with crew
			else if this_that == this and type == "land" and not is_land(card.type)
				then "permanent" #### ex. an enchantment with hideaway before they changed it
			else type;

	this_that + " " + type
}@(upper:false)
#### see if a keyword should have different text because it's merged with another reminder text
#### handle_merged_rt("Its a", moved:"A Food token is")
handle_merged_rt := {
	"<use-if-moved>" + moved + "</use-if-moved><otherwise>" + input + "</otherwise>"
}
#### see if an action keyword should have different text because its distant from the keyword
#### handle_action_rt(to:"forage", "Exile")
handle_action_rt := {
	"<use-if-bumped>To " + to + ", " + to_lower(input) + "</use-if-bumped><otherwise>" + input + "</otherwise>"
}
handle_action_rt_single := {
	"<use-if-bumped>" + prefix + " " + to_lower(input) + "</use-if-bumped><otherwise>" + input + "</otherwise>"
}
############################################################## Complex reminder texts
self_pro_check := match@(match:"You ha(ve|s) <kw-A><nospellcheck>protection")
protection_code := {
	output :=	if match(input, match:"(artifacts|battles|creatures|enchantments|instants|kindreds|lands|planeswalkers|sorceries|planes|schemes|emblems|conspiracies|^[A-Z]|^[^ ]* named)") then replace(input, match:"and from", replace:"or", in_context:" <match> ")
				else if match(input, match:"^(converted|mana|power|toughness)") then "anything with " + replace(input, match:"and from", replace:"or", in_context:" <match> ")
				else if contains(input, match:"the chosen player") then "anything " + replace(input, match:"the chosen", replace:"controlled by that")
				else if contains(input, match:"the chosen") then "anything with " + replace(input, match:"the chosen", replace:"that")
				else if contains(input, match:"all colors") then "anything " + replace(input, match:"all colors", replace:"that's white, blue, black, red, or green")
				else if match(input, match:"^you$") then "anything you control"
				else if match(input, match:"^its owner$") then "anything its owner controls"
				else if match(input, match:"^(each of )?your opponents$") then "anything " + replace(input, match:"(each of )?your opponents", replace:"controlled by those players")
				else if match(input, match:"(the|a) [^\n]* of your choice") then "anything " + replace(input, match:"(the|a) ([^\n]*) of your choice", replace:"of that \\2")
				else if input == "colorless" then "anything colorless"
				else "anything " + replace(english_singular(input), match:"and from", replace:"or", in_context:" <match> ")
	output := " targeted, dealt damage, enchanted, equipped by " + output
	if match(output, match:"(artifacts|creatures|instants|lands|planeswalkers|sorceries|tribals|planes|schemes|emblems|conspiracies|by [A-Z])") and not match(output, match:"(enchantmentsAura|Curse)") then
		output := replace(output, match:", enchanted", replace:"")
		else output := output
	if match(output, match:"(enchantments|creatures|instants|lands|planeswalkers|sorceries|tribals|planes|schemes|emblems|conspiracies|by [A-Z])") and not match(output, match:"(artifacts|Equipment)") then
		output := replace(output, match:" equipped", replace:"")
		else output := output
	if match(output, match:"equipped by") then output := replace(output, match:"equipped by", replace:"or equipped by")
	else if match(output, match:"enchanted, by") then output := replace(output, match:"enchanted, by", replace:"or enchanted by")
	else if match(output, match:"dealt damage, by") then output := replace(output, match:"dealt damage, by", replace:"or dealt damage by")
	else ""
	if match(output, match:"^ targeted, or dealt damage by") then output := replace(output, match:"^ targeted, or dealt damage by", replace:" targeted or dealt damage by")
	if match(output, match:"anything [A-Z]") then output := replace(output, match:"anything ", replace:"")
	if match(output, match:"or les") then output := replace(output, match:"or les$", replace:"or less")
	if match(output, match:"(anything )?everything") then output := replace(output, match:"(anything )?everything", replace:"anything")
	output := (if self_pro_check(card.text) then "You can't be" else if is_spell(card.type) then "It can't be blocked," else if is_creaturish(card.type) then "This creature can't be blocked," else "This permanent can't be") + output
	output
}
phy_reminder := {
	phy_match := filter_text(input, match:"(/[WUBRG])+", in_context:"H<match>")
	letters := split_text(phy_match, match:"/")
	reminder_text := ""
	if length(letters) == 2 then 
		reminder_text := "[H/" + letters[1] + "] can be paid with [" + letters[1] + "] or 2 life."
	else if length(letters) > 2 then 
		reminder_text := "[H/" + letters[1] + "/" + letters[2] + "] can be paid with [" + letters[1] + "], " + "[" + letters[2] + "], or 2 life."
	else
		reminder_text := ""
	reminder_text
}
#### includes localization ability
craft_code := {
	[
		"en": {
			#### beginning
			rem := param2.value + ", Exile this artifact, Exile ";
			
			#### check if a number is given
			count := filter_text(param1.value, match:"^(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|[0-9]+)(-(one|two|three|four|five|six|seven|eight|nine))? (or more)?");

			#### replace trailing space
			count := trim(count)

			#### check how many commas are given
			commas := filter_text(param1.value, match:",");

			#### check if this starts with a vowel
			vowel := match(param1.value, match:"^[aeiouAEIOU]");

			#### if we have a comma separated list, use the number of elements as the count
			#### this doesn't support like, Craft with two Islands and two Mountains
			#### you've done that to yourself
			if commas != "" then count := english_number(length(commas)+1);
			
			#### unused style (craft with three)
			#### param1 == "three" count == "three"
			#### counting style (craft with one or more); (craft with six artifacts)
			#### param1 == "one or more" count == "one"; param1 == "six artifacts" count == "six"
			#### singular style (craft with creature)
			#### param1 == "creature" count == ""
			if count == param1.value then
			(
				#### Exile three other...
				rem := 	rem
						+ param1.value
						+ " other permanents you control and/or cards from your graveyard: "
			)
			else if count != "" then
			(
				#### Exile one or more from among...
				#### Exile the six from among...
				rem := 	rem
						+ (if count == "one or more" then param1.value else "the " + count)
						+ " from among other permanents you control and/or cards in your graveyard: "
			)
			else
			(
				#### Exile another creature you control or...
				rem := 	rem
						+ "another " + param1.value + " you control or "
						+ (if vowel then "an " else "a ") + param1.value + " card from your graveyard: "
			)
			
			#### ending and return
			rem := rem + "Return this card transformed under its owner's control. Craft only as a sorcery."
			rem
		},
		"de": {
			#### beginning
			rem := param2.value + ", schnicke dieses Artefakt ins Exil, schicke ";
			
			#### check if a number is given
			count := filter_text(param1.value, match:"^(zwanzig|dreiβig|vierzig|fünfzig|sechzig|siebzig|achtzig|neunzig|eine[mr]|eins?|zwei|drei|vier|fünf|sechs?|sieben|sieb|acht|neun|zehn|elf|zwölf|[0-9]+)(und)?(zehn|zwanzig|dreiβig|vierzig|fünfzig|sechzig|siebzig|achtzig|neunzig)?( oder mehr(eren)?)? ?");

			#### save the thing we're exiling
			target := trim(replace(param1.value, match:count, replace:""))
			alt_target := if length(target) > 15 then "Permanente" else target

			#### format count
			count := replace(count, match:"eine[mr]", replace:"eins")
			count := trim(count)

			#### check how many commas are given
			commas := filter_text(param1.value, match:",");

			#### check if this starts with a vowel
			vowel := match(target, match:"^[aäeiouüAÄEIOUÜ]");

			#### if we have a comma separated list, use the number of elements as the count
			#### this doesn't support eg Craft with two Islands and two Mountains
			#### you've done that to yourself
			if commas != "" then (
				count := german_number(length(commas)+2);
				alt_target := "Permanente"
			)

			#### unused style (craft with three)
			#### param1 == "three" count == "three"
			#### counting style (craft with one or more); (craft with six artifacts)
			#### param1 == "one or more" count == "one"; param1 == "six artifacts" count == "six"
			#### singular style (craft with creature)
			#### param1 == "creature" count == ""

			if count == param1.value then
			(
				#### Exile three other...
				rem := 	rem
						+ param1.value
						+ " weiteren Permanente, die du kontrollierst und/oder Karten aus deinem Friedhof ins Exil: "
			)
			else if count != "eins" then
			(
				#### with one or more...
				#### with four or more
				#### with two+...
				rem := 	rem
						+ (
							if count == "eins oder mehreren" then "ein oder mehrere weitere "
							else if contains(count, match:"oder") then "die " + count + " weireren "
							else "die " + count + " oder mehr weiteren "
							#### todo this should list the denumbered param1.value instead
						)
						+ alt_target
						+ (if vowel then ", das du" else ", die du")
						+ " kontrollierst und/oder Karten aus deinem Friedhof ins Exil: "
			)
			else
			( 
				#### with einem Artefakt
				#### with einem Kreatur
				rem := 	rem
						+ (if target == "Artefakt" then "ein weiteres " else "ein ")
						+ target
						+ ", "
						+ (if vowel then "das du" else "die du")
						+ " kontrollierst, oder "
						+ (if vowel then "eines " else "eine ") + target
						+ (if target == "Kreatur" then "en-karte" else "-karte")
						+" aus deinem Friedhof ins Exile: "
			)
			
			#### ending and return
			rem := rem + "Bringe diese Karte transformiert unter der Kontrolle ihres Besitzers ins Spiel zurück. Spiele Anfertigung wie eine Herexi."
			rem
		}
	][lang_setting("code") or else "en"]()
}
############################################################## The text box
#### Filters for the text box
#### context in which mana symbols are found
mana_context :=
	"(?ix)                                                      #### case insensitive, ignore whitespace
	 (^|[[:space:]\"(“'])                                       #### start of a word
		(
				<match>:                                        #### G: something
			|	<match>,                                        #### G, tap: something
			|   [+][ ]?<match>[ ]?—                             #### Spree
			|	or[ ]<match>                                    #### Add X, Y, or Z.
			|	<match>[ ]to[ ]your                             #### Add X, Y, or Z to your mana pool.
			|	you[ ]get[ ]<match>                             #### You get E, you get TK
			|	<match>[ ]was[ ]spent                           #### if G was spent to cast
			|	<match>[ ]can[ ]be[ ]paid
			|	(pays?|additional|costs?|the|adds?|pay(ed)?[ ](with|using)) #### pay X. creatures cost 1 less. pay an additional G.
				([ ]either)?                                                                            #### pay either X or Y
				([ ](<sym[^>]*>)?[-+=]?[VLHSCETKQ\\?XYZIEWUBRG0-9/|]+(</sym[^>]*>)?,)*                  #### pay X, Y or Z
				([ ](<sym[^>]*>)?[-+=]?[VLHSCETKQ\\?XYZIEWUBRG0-9/|]+(</sym[^>]*>)?[ ](and|or|and/or))* #### pay X or Y
				[ ]<match>
				(
						[,.)\"”]|$                              #### (end of word)
					|	[ ][^ .,]*$                             #### still typing...
					|	[ ]( or | and | in | less | more | to ) #### or next word is ...
				)
		)
	 |  <param-mana><match></param-mana>                        #### keyword argument that is declared as mana
	 |  <param-cost>[ ]*<match></param-cost>                    #### keyword argument that is declared as cost
	 |  <param-cost><match>,                                    #### keyword argument that is declared as cost
	";
#### remove false positives
mana_un_context := "(mana values? <match>|converted mana costs? <match>|<match> life)"

#### atoms
#### truncates the name of legends
legend_filter := replace@(match:"(, | of | the | \"| “).*", replace: "" )
#### does this frame support Alchemy Rebalanced mana symbol in names?
#### set tab insert atoms
inserts_values := { split_text(set.inserts+";;;;;;;;;", match:";") }
inserts_count := { clamp(length(semicolon_count(set.inserts)), minimum:1, maximum:9) }
custom_auto_reminder := {""}
auto_reminder := {
	level := filter_text(input, match:"[0-9]+")
	if level == "" then level := "1"
	tag := name_tag_for_level(to_number(level))
	type_field := card["type"+tag]
	cost_field := card["casting_cost"+tag]
	if custom_auto_reminder()
		then custom_auto_reminder()
	else if lang_setting("is_saga")(type_field)
		then saga_reminder_script(tag:tag)
	else if lang_setting("is_class")(type_field)
		then "<i-auto>(Gain the next level as a sorcery to add its ability.)</i-auto>"
	else if contains(cost_field, match:"/")
		then hybrid_reminder(cost_field)
	else if lang_setting("is_room")(type_field)
		then "<i-auto>(You may cast either half. That door unlocks on the battlefield. As a sorcery, you may pay the mana cost of a locked door to unlock it.)</i-auto>"
	else ""
}
saga_map := [
	1: "I",
	2: "II",
	3: "III",
	4: "IV",
	5: "V",
	6: "VI",
	7: "VII",
	8: "VIII",
	9: "IX",
	10: "X"
]
saga_reminder_script := {
	ch := "III"
	ch_src := ""
	ch_extra := ""
	ch_extra_name := if styling.extra_chapter_name or else "" == "" then "C" else styling.extra_chapter_name
	if tag == "_2" then (
		ch_src := styling.snap_chapter_to_back_box or else ""
		ch_extra := replace(styling.custom_chapter_coordinate or else "", match:"^[^,]*,", replace:"")
	)
	else(
		ch_src := styling.snap_chapter_to_box or else ""
		ch_extra := styling.custom_chapter_coordinate or else ""
	)
	
	if ch_extra
		then ch := ch_extra_name
	else (
		ch_count := if ch_src == "" then 3 else length(filter_text(ch_src, match:"[0-9]"))
		ch := saga_map[ch_count] or else ch_count
	)
		
	"<i-auto>(As this Saga enters and after your draw step, add a lore counter. Sacrifice after {ch}.)</i-auto>"
}
hybrid_reminder := {
	first_hybrid := replace(
		input,
		match:"(([^ ])/([^ ])(?:/([^ ]))?).*", ## _1 hybrid, _2 sym1, _3 sym2, _4 sym3
		replace: {
			if _4 != "" then (
				if _2 == "2" then
					"<i-auto>(<sym-auto>{_1}</sym-auto> can be paid with any two mana, <sym-auto>{_3}</sym-auto>, or <sym-auto>{_4}</sym-auto>. This card's mana value is {english_number(cmc(input))}.)</i-auto>"
				else if _2 == "H" then
					"<i-auto>(<sym-auto>{_1}</sym-auto> can be paid with <sym-auto>{_3}</sym-auto>, <sym-auto>{_4}</sym-auto>, or 2 life.)</i-auto>"
				else "<i-auto>(<sym-auto>{_1}</sym-auto> can be paid with either <sym-auto>{_2}</sym-auto>, <sym-auto>{3}</sym-auto>, or <sym-auto>{3}</sym-auto>.)</i-auto>"
			)
			else (
				if _2 == "2" then
					"<i-auto>(<sym-auto>{_1}</sym-auto> can be paid with any two mana or with <sym-auto>{_3}</sym-auto>. This card's mana value is {english_number(cmc(input))}.)</i-auto>"
				else if _2 == "H" then
					"<i-auto>(<sym-auto>{_1}</sym-auto> can be paid with either <sym-auto>{_3}</sym-auto> or 2 life.)</i-auto>"
				else "<i-auto>(<sym-auto>{_1}</sym-auto> can be paid with either <sym-auto>{_2}</sym-auto> or <sym-auto>{_3}</sym-auto>.)</i-auto>"
			)
		}
	)
}
#### these are considered a correct 'word' for spellchecking in the text box:
additional_text_words := match@(match:
	"(?ix)^(?:                         #### match whole word
	  <atom-[^>]*>.*?</atom-[^>]*>     #### cardnames and stuff
	| [+-]?[0-9X]+ / [+-]?[0-9X]+      #### '3/3', '+X/+X'
	)$")

#### Automatically correct errant syntax
auto_correct :=
	replace@(match:" it’s (controller|owner|power|toughness|converted|other)", replace:" its \\1")
	+replace@(match:"Then, if" replace:"Then if")
	+replace@(match:"([Ff]irst|[Dd]ouble) Strike" replace:"\\1 strike")
	+replace@(match:"Splice (Ont|unt|int)" replace:"Splice ont")
	+replace@(match:"(ecomes?) the Monarch" replace:"\\1 the monarch")
	+replace@(match:"does (combat|[X0-9]+) damage" replace:"deals \\1 damage")
	+replace@(
		match: "(gains |gain |have |has )" #### preceded by this
		     + "(<kw-[^<]><nospellcheck>)" #### inside a kw
			 + "([A-Z])"                   #### match this
		replace: { _1 + _2 + to_lower(_3)})
	+replace@(
		match: "([^ ]: |—| — )"            #### preceded by this
		     + "([[:lower:]])"             #### match this
		     + "(?![)])",                  #### not followed by this
		replace: { _1 + to_upper(_2) })

#### Automatically apply errata
auto_errata :=
	replace@(match:"converted mana cost", replace:"mana value")
	+replace@(match:"(?i)(Totem armor|Totembeistand|Armadura tótem|totémique|Armatura totem|Armadura de totem|族霊鎧|替身甲)", replace:{errata_map[_1] or else _1})
	+replace@(match:"hen shuffle your library", replace:"hen shuffle")
	+replace@(match:"this (?:ability )?(?:only )?(?:any ?time you could cast|as) a", in_context: "(Activate|Play) <match>n? (instant|sorcery)", replace:"only as a")
	+replace@(match:"(enters?) the battlefield( under your control)?", replace: {
		(if _2 != "" then "you control " else "") + _1
	})
#### can be localized via errata_map
errata_map := [
	"Totem armor": "Umbra armor",
	"Totem Armor": "Umbra armor",
	"totem armor": "umbra armor",
	"Totembeistand": "Schattenbeistand",
	"totembeistand": "schattenbeistand",
	"Armadura tótem": "Armadura umbra",
	"armadura tótem": "armadura umbra",
	"Armure totémique": "Armure d’ombre",
	"armure totémique": "armure d’ombre",
	"Armatura totem": "Armatura essenza",
	"armatura totem": "armatura essenza",
	"族霊鎧": "陰影鎧",
	"替身甲": "本影甲",
	"Armadura de totem": "Armadura de sombra",
	"armadura de totem": "armadura de sombra"
]

#### the rule text filter
####  - adds reminder text
####  - fills in CARDNAME and INSERT
####  - adds mana symbols
####  - makes text in parentheses italic
####  - indents modals
####  - runs auto correct/errata
####  - spellchecks
####  - margins aren't applied here; they're patched onto this by templates that use them
text_filter :=
	#### step 1 : remove all automatic tags
	remove_tag@(tag: "<sym-auto>") +
	remove_tag@(tag: "<i-auto>") +
	remove_tag@(tag: "<b-auto>") +
	remove_tag@(tag: "<error-spelling") +
	remove_tag@(tag: "<nospellcheck") +
	remove_tag@(tag: "<li>") +
	remove_tag@(tag: "<bullet>") +
	remove_tag@(tag: "<align") +
	remove_tag@(tag: "<margin") +
	remove_tag@(tag: "<moved>") +
	remove_tag@(tag: "<blob>") +
	remove_tag@(tag: "<key>") +
	#### step 1b : remove zero-width space used for level spacers
	replace@(match:"​", replace:"") +
	#### step 2a : temp fix for formatting buttons
	replace@(
		match:"<b></b>",
		replace:"BOLDAROUND"
	) +
	replace@(
		match:"<i></i>",
		replace:"ITALAROUND"
	) +
	replace@(
		match:"<sym></sym>",
		replace:"SYMAROUND"
	) +
	#### step 2a : reminder text for keywords
	expand_keywords@(
		condition: {
			correct_case or (mode != "pseudo" and not used_placeholders)
		}
		default_expand: {
			chosen(choice:if correct_case or mode == "action" then mode else "lower case", set.automatic_reminder_text) and chosen(choice:mode, set.automatic_reminder_text)
		},
		combine: {
			keyword := "<nospellcheck><key>{keyword}</key></nospellcheck>"
			reminder := process_english_hints(reminder)
			if mode == "pseudo" then "<i-auto>{keyword}</i-auto>"
			else keyword + if expand then "<atom-reminder-{mode}> ({reminder})</atom-reminder-{mode}>" else ""
		}
	) +
	#### step 2b : apply face_code
	replace@(
		match: "face_(.*?)_end",
		replace: {face_code(_1)}
	) +
	#### step 2c : move action keywords' reminder text to the end of the line
	replace@(
		match: "(<atom-reminder-[^>]+> (?:(?!</kw).*?)</atom-reminder-[^>]+></kw[^>]*>)([^\n]*)", #### removed "| ?<kw-" from lookahead
		replace: "\\2\\1"
	) +
	#### step 2d : when there's an action keyword and another one, then move that to the end of the line
	replace@(
		match: "(<atom-reminder-[^>]+> (?:(?!</kw)[^\n]*?)</atom-reminder-[^>]+></kw[^>]*>)([^\n]*?)(<atom-reminder-[^>]+> (?:(?!</kw).*?)</atom-reminder-[^>]+></kw[^>]*>)([^\n]*)",
		replace: "\\2<blob>\\4\\3<moved>\\1</moved></blob>"
	) +
	#### step 2da : apply multikeyword reminder edits
		#### A Food token is... vs It's a...
		#### this one moved
	replace@(
		match: "(<moved><atom-reminder[^>]*> [(])<use-if-(?:moved|bumped)>(.*?)</use-if-(?:moved|bumped)><otherwise>(.*?)</otherwise>",
		replace: "\\1\\2"
	) +
		#### this one didn't
	replace@(
		match: "<use-if-moved>(.*?)</use-if-moved><otherwise>(.*?)</otherwise>",
		replace: "\\2"
	) +
		#### To forage, exile... vs Exile...
		#### this was put in a combined rt
	replace@(
		match: "(<blob>.*?)<use-if-bumped>(.*?)</use-if-bumped><otherwise>(.*?)</otherwise>",
		replace: "\\1\\2"
	) +
		#### this one wasn't bumped
	replace@(
		match: "(</key></nospellcheck>[.]?<atom-reminder[^>]*> [(])<use-if-bumped>(.*?)</use-if-bumped><otherwise>(.*?)</otherwise>",
		replace: "\\1\\3"
	) +
		#### this one was bumped
	replace@(
		match: "<use-if-bumped>(.*?)</use-if-bumped><otherwise>(.*?)</otherwise>",
		replace: "\\1"
	) +
	#### step 2e : allow a sentence after lowercase reminder text for equips etc.
	#replace@(
	#	match: "(<kw[^>]+><nospellcheck>[a-z][^<]+</nospellcheck>)(<atom-reminder-(?:expert|custom|old|core)>(?:(?!<kw-).)*</atom-reminder-(?:expert|custom|old|core)></kw[^>]*>)([^\n]+)$",
	#	replace: "\\1\\3\\2"
	#	) +
	#### step 2f : remove duplicate reminder text
	replace@(
		match: "(<atom-reminder-[^>]*>[^)]+[)]</atom-reminder-[^>]*>)([^\n]+)\\1"
		replace: "\\2\\1"
	) +
	#### step 2g : combine reminder texts
	replace@(
		match: "[)](</atom-reminder-[^>]+></kw-[^>]>(?:</?moved>)?<atom-reminder-[^>]+> )[(]"
		replace: "\\1"
	) +
	#### step 2h : temp fix for formatting buttons
	replace@(
		match:"BOLDAROUND",
		replace:"<b></b>"
	) +
	replace@(
		match:"ITALAROUND",
		replace:"<i></i>"
	) +
	replace@(
		match:"SYMAROUND",
		replace:"<sym></sym>"
	) +
	replace@(
		match:"-\n-"
		replace:"<soft-line>\n</soft-line>"
	) +
	#### step 3a : expand shortcut word CARDNAME
	replace@(
		match: "CARDNAME>?", #### >? is here so after replacement, the mouse snaps to the end of </atom>
		in_context: "(^|[[:space:]]|\\(|,|\\.|:|“|\"|'|‘|-|—|/|​)<match>", #### TODO: Allow any punctuation before
		replace: "<atom-cardname></atom-cardname>"
	) +
	#### step 3a : expand shortcut word THIS
	replace@(
		match: "THIS>?", #### >? is here so after replacement, the mouse snaps to the end of </atom>
		in_context: "(^|[[:space:]]|\\(|,|\\.|:|“|\"|'|‘|-|—|/|​)<match>", #### TODO: Allow any punctuation before
		replace: "<atom-printname></atom-printname>"
	) +
	#### step 3b : expand shortcut word LEGENDNAME
	replace@(
		match: "LEGENDNAME>?",
		in_context: "(^|[[:space:]]|\\(|,|\\.|:|“|\"|'|‘|/|​)<match>", #### TODO: Allow any punctuation before
		replace: "<atom-legname></atom-legname>"
	) +
	#### step 3b : expand shortcut word AUTOREM
	replace@(
		match: "AUTOREM>?",
		in_context: "(^|[[:space:]]|\\(|,|\\.|:|“|\"|'|‘|/|​)<match>", #### TODO: Allow any punctuation before
		replace: "<atom-autorem></atom-autorem>"
	) +
	#### step 3bb : debug atom fields
	replace@(
		match: "<atom-name>([^<]+)</atom-(card|print)",
		replace: "<atom-\\2name>\\1</atom-\\2"
	) +
	replace@(
		match: "<atom-name>",
		replace: ""
	) +
	#### step 3c : fill in atom fields
	tag_contents@(
		tag: "<atom-cardname>",
		contents: { "<nospellcheck>" + (if card_name=="" then "CARDNAME" else strip_card_codes(card_name, atom:true)) + "</nospellcheck>" }
	) +
	tag_contents@(
		tag: "<atom-printname>",
		contents: { "<nospellcheck>" + reverse_name_for(card_name, margin_code:margin_code) + "</nospellcheck>" }
	) +
	#### capitalize This type when appropriate
	replace@(
		match:"([•.:]) <atom-(card|print)name><nospellcheck>this",
		replace:"\\1 <atom-\\2name><nospellcheck>This"
	) +
	replace@(
		match:"([\"“'])<atom-(card|print)name><nospellcheck>this",
		replace:"\\1<atom-\\2name><nospellcheck>This"
	) +
	replace@(
		match:"^<atom-(card|print)name><nospellcheck>this",
		replace:"<atom-\\1name><nospellcheck>This"
	) +
	tag_contents@(
		tag: "<atom-legname>",
		contents: { "<nospellcheck>" + (if card_name=="" then "LEGENDNAME" else legend_filter(strip_card_codes(card_name, atom:true))) + "</nospellcheck>" }
	) +
	tag_contents@(
		tag: "<atom-autorem>"
		contents: { auto_reminder(margin_code) }
	) +
	replace@(
		match:"(E+)(</sym(-auto)?>)? <atom-autorem></atom-autorem>",
		replace: {
			num := english_number(length(_1))
			str := if num == "one" then "an energy counter" else num + " energy counters"
			_1 + _2 + " <atom-autorem><i-auto>({str})</i-auto></atom-autorem>"
		}
	) +
	replace@(
		match: "INS([1-9])",
		in_context: "(^|[[:space:]]|\\(|,|\\.|:|“|\"|'|‘|/|​)<match>",
		replace: "<atom-insert\\1></atom-insert\\1>"
	) +
	{
		out := input
		for x from 1 to inserts_count() do
			out := tag_contents(out,
				tag: "<atom-insert"+x+">",
				contents: { "<nospellcheck>" + (if inserts_values()[x-1] == "" then "INS"+x else inserts_values()[x-1]) + "</nospellcheck>" }
			)
		out
	} +
	#### step 4 : explict non mana symbols
	replace@(
		match: "\\][-+=]?[VLHSCETQ\\?XYZIWUBRG0-9/|]+\\[",
		replace: {"<nosym>" + mana_filter_t() + "</nosym>"}
	) +
	#### step 5 : add mana & tap symbols
	replace@(
		match: "(?<!\\/)([+=-][XYZ0-9|]+)(?!\\/)",
		in_context: mana_context,
		replace: {"<sym-auto>" + _1 + "</sym-auto>"}
	) +
	replace@(
		match: "\\b((TK)+)(T)?\\b",
		in_context: mana_context,
		replace: {"<sym-auto>" + _1 + "</sym-auto>" + _3}
	) +
	replace@(
		match: "\\b[VLHSCETQ\\?XYZIWUBRG0-9/|]+\\b",
		in_context: mana_context,
		replace: {"<sym-auto>" + mana_filter_t() + "</sym-auto>"}
	) +
	#### step 5b : remove false positive mana & tap symbols
	replace@(
		match: "<sym-auto>([VLHSCETQ\\?XYZIWUBRG0-9/|]+)</sym-auto>",
		in_context: mana_un_context,
		replace: "\\1"
	) +
	#### step 5c : add explicit mana symbols
	replace@(
		match: "\\[[-+=]?[VLHSCETQE\\?XYZIWUBRG0-9/|]+\\]",
		replace: {"<sym>" + mana_filter_t() + "</sym>"}
	) +
	#### step 6 : curly quotes
	{
		if set.curly_quotes then curly_quotes(input) else input
	} +
	#### step 7 : italicize text in parenthesis
	replace@(
		match: "[(]([^)\n]|[(][^)\n]*[)])*[)]?",
		in_context: "(^|[[:space:]])<match>|<atom-keyword><match></",
		replace: "<i-auto>&</i-auto>"
	) +
	#### step 7b : indent bullets
	replace@(
		match: "^(• )([^\n]+\n?)",
		replace: {"<li><bullet>" + _1 + "</bullet>" + _2 + "</li>"}
	) +
	#### step 7c : clean up modals
	{
		if is_modal(input)
			then bump_text(softline_ripper(input))
		else input
	} +
	#### step 8 : automatic capitalization, but not after "("
	#replace@(
	#	match: "([^ ]: |—| — )" #### preceded by this
	#	     + "([[:lower:]])"  #### match this
	#	     + "(?![)])",       #### not followed by this
	#	replace: { _1 + to_upper(_2) }) +
	#### step 9 : spellcheck
	{
		if set.auto_correct then
			auto_correct(input)
		else input
	} +
	{
		if set.auto_errata then
			auto_errata(input)
		else input
	} +
	{
		if language().code == "ja" or language().code == "zht" or language().code == "zhs" then input
		else if set.mark_errors then
		check_spelling(
			language: language().spellcheck_code,
			extra_dictionary: "/magic.mse-game/dictionary/magic-words",
			extra_match: additional_text_words
		)
		else input
	}

#### the flavor text filter
####  - makes all text italic
flavor_text_filter_default := { "<i-flavor></i-flavor>" }
flavor_text_filter :=
	#### step 1 : remove italic tags
	remove_tag@(tag: "<i-flavor>") +
	#### step 2 : surround by <i> tags
	{ "<i-flavor>" + input + "</i-flavor>" } +
	#### curly quotes
	{ if set.curly_quotes then curly_quotes(input) else input } +
	#### spellcheck
	{
		if set.mark_errors
		then check_spelling(language:language().spellcheck_code)
		else input
	}
############################################################## Face code
#### this is a workaround to let reminder code access the proper face of a card
card_face := {
	front := card[input]
	back := if card[input+"_2"] or else "" != "" then card[input+"_2"] else card[input]
	if match(margin_code, match:"(text[2456]|lv[5678])") then back else front
}
face_code := {
	face := ""
	if margin_code == "text2" or margin_code == "lv5" or margin_code == "lv6" or margin_code == "lv7" or margin_code == "lv8" then face := "_2"
	output := face_scripts[input](face) or else if_parse(input, face:face) or else input
	output
}
flip_face := {
	if input == "_2" then "" else "_2"
}
face_scripts := [
	iscreature: {is_creature(card["type"+face])},
	iscreaturish: {is_creaturish(card["type"+face])},
	isenchantment: {is_enchantment(card["type"+face])},
	isartifact: {is_artifact(card["type"+face])},
	island: {is_land(card["type"+face])},
	isspell: {is_spell(card["type"+face])},
	istarget: {is_targeted(card["text"+face])},
	subtypes: {separate_words(card["sub_type"+face], spacer: " ")}
	contains: {
		contains(card[field+face], match:query)
	},
	notcontains: {not contains(card[field+face], match:query)},
	name: {card["name"+face]},
	cost: {card["casting_cost"+face]},
	altname: {card["name"+flip_face(face)]},
	altcost: {card["casting_cost"+flip_face(face)]},
	isfront: {face == ""},
	isback: { face == "_2"}
]

expand_facecodes := [
	subtype: "sub_type",
	castingcost: "casting_cost",
	manacost: "casting_cost"
]
if_parse := replace@(
	match: "if_(.*)_then_(.*)_else_(.*)",
	replace: {if_scripts(_1, t:_2, f:_3)}
)
if_scripts := {
	contCheck := split_text(input, match:"_")
	func := contCheck[0]
	field := ""
	query := "^$"
	if length(contCheck) == 3 then (
		field := contCheck[0]
		func := contCheck[1]
		query := contCheck[2]
	)
	field := expand_facecodes[field] or else field
	if face_scripts[func](face, field:field, query:query) or else false then t else f
}
############################################################## Level Margins
#### these will be determined by the style affecting the margins and otherwise be 0
margin_left := {0}
margin_right := {0}
margin_top := {0}
remove_margins := replace@(
	match: "</?margin:[0-9]+(:+[0-9]+)?(:+[0-9]+)?>",
	replace:""
)
#### remove 0 margins and margins with no text
cull_margins := replace@(match:"</?margin:0(:+0)?(:+0)?>", replace:"")+
	replace@(match:"<margin:[0-9]+:?[0-9]*:?[0-9]*></margin:[0-9]+:?[0-9]*:?[0-9]*>", replace:"")
	
#### this gives a big array so we can grab_margins()["lv1"] etc anywhere
grab_margins :=
{[
	lv1:	[margin_left("lv1"),	margin_right("lv1"),	margin_top("lv1")], 
	lv2:	[margin_left("lv2"),	margin_right("lv2"),	margin_top("lv2")], 
	lv3:	[margin_left("lv3"),	margin_right("lv3"),	margin_top("lv3")], 
	lv4:	[margin_left("lv4"),	margin_right("lv4"),	margin_top("lv4")], 
	lv5:	[margin_left("lv5"),	margin_right("lv5"),	margin_top("lv5")], 
	lv6:	[margin_left("lv6"),	margin_right("lv6"),	margin_top("lv6")], 
	lv7:	[margin_left("lv7"),	margin_right("lv7"),	margin_top("lv7")], 
	lv8:	[margin_left("lv8"),	margin_right("lv8"),	margin_top("lv8")], 
	lv9:	[margin_left("lv9"),	margin_right("lv9"),	margin_top("lv9")], 
	lv10:	[margin_left("lv10"),	margin_right("lv10"),	margin_top("lv10")], 
	lv11:	[margin_left("lv11"),	margin_right("lv11"),	margin_top("lv11")], 
	lv12:	[margin_left("lv12"),	margin_right("lv12"),	margin_top("lv12")], 
	lv13:	[margin_left("lv13"),	margin_right("lv13"),	margin_top("lv13")], 
	lv14:	[margin_left("lv14"),	margin_right("lv14"),	margin_top("lv14")], 
	lv15:	[margin_left("lv15"),	margin_right("lv15"),	margin_top("lv15")], 
	lv16:	[margin_left("lv16"),	margin_right("lv16"),	margin_top("lv16")], 
	lv17:	[margin_left("lv17"),	margin_right("lv17"),	margin_top("lv17")], 
	lv18:	[margin_left("lv18"),	margin_right("lv18"),	margin_top("lv18")], 
	lv19:	[margin_left("lv19"),	margin_right("lv19"),	margin_top("lv19")], 
	lv20:	[margin_left("lv20"),	margin_right("lv20"),	margin_top("lv20")], 
	lv21:	[margin_left("lv21"),	margin_right("lv21"),	margin_top("lv21")], 
	lv22:	[margin_left("lv22"),	margin_right("lv22"),	margin_top("lv22")], 
	text:	[margin_left("text"),	margin_right("text"),	margin_top("text")], 
	text2:	[margin_left("text2"),	margin_right("text2"),	margin_top("text2")], 
	text3:	[margin_left("text3"),	margin_right("text3"),	margin_top("text3")], 
	text4:	[margin_left("text4"),	margin_right("text4"),	margin_top("text4")], 
	text5:	[margin_left("text5"),	margin_right("text5"),	margin_top("text5")],
	text6:	[margin_left("text6"),	margin_right("text6"),	margin_top("text6")],
	flavor_text:	[margin_left("flavor_text"),	margin_right("flavor_text"),	margin_top("flavor_text")],
	flavor_text2:	[margin_left("flavor_text2"),	margin_right("flavor_text2"),	margin_top("flavor_text2")],
	flavor_text3:	[margin_left("flavor_text3"),	margin_right("flavor_text3"),	margin_top("flavor_text3")],
	flavor_text4:	[margin_left("flavor_text4"),	margin_right("flavor_text4"),	margin_top("flavor_text4")],
	combined_text:	[margin_left("combined_text"),	margin_right("combined_text"),	margin_top("combined_text")],
	combined_text2:	[margin_left("combined_text2"),	margin_right("combined_text2"),	margin_top("combined_text2")],
	combined_text3:	[margin_left("combined_text3"),	margin_right("combined_text3"),	margin_top("combined_text3")],
	combined_text4:	[margin_left("combined_text4"),	margin_right("combined_text4"),	margin_top("combined_text4")],
	chapter_text:	[margin_left("chapter_text"),	margin_right("chapter_text"),	margin_top("chapter_text")],
	chapter_text2:	[margin_left("chapter_text2"),	margin_right("chapter_text2"),	margin_top("chapter_text2")],
	unknown: [0,0,0]
]}
#### then with apply_margins(field, name:fieldname), add the margins into the text
apply_margins := {
	margin_data := grab_margins()[name] or else [0,0,0]
	cull_margins("<margin:" + margin_data[0] + ":" + margin_data[1] + ":" + margin_data[2] + ">" + remove_margins(input) + "</margin:" + margin_data[0] + ":" + margin_data[1] + ":" + margin_data[2] + ">")
}

bump_text := {
	blocks := split_text(input, match:"\n");
	new_text := blocks[0];
	for x from 1 to length(blocks)-1 do new_text := new_text + "\n" + bumper(blocks[x])
	new_text
}
bumper := {
	#### if this text isn't modal, add a 5 px margin
	if is_modal(input) then input else
	cull_margins("<margin:0:0:5>" + remove_margins(input) + "</margin:0:0:5>")
}
############################################################## Saga witchery
#### number of chapter symbols each chapter textbox has
#### example, symbols on abilities 2,2,3 returns [0,2,1]
saga_lore_count := {
	one := 0
	two := 0
	three := 0
	four := 0
	five := 0
	six := 0
	seven := 0
	eight := 0
	for x from 0 to length(input)-1 do
		if input[x] == "1" then one := one +1
		else if input[x] == "2" then two := two +1
		else if input[x] == "3" then three := three +1
		else if input[x] == "4" then four := four +1
		else if input[x] == "5" then five := five +1
		else if input[x] == "6" then six := six +1
		else if input[x] == "7" then seven := seven +1
		else eight := eight +1
	[one, two, three, four, five, six, seven]
}
#### index of given chapter number in above array
#### example, 2,2,3, returns 1,2,1
#### i tried to make this shorter but this is the only one that deigned to function
saga_ch_placement := {
	box1 := 0
	box2 := 0
	box3 := 0
	box4 := 0
	one := 0
	two := 0
	three := 0
	four := 0
	five := 0
	six := 0
	seven := 0
	len := length(input)
	if len >= 1 then (
		if input[0] == "1" then (
			box1 := box1 +1
			one := box1+0
		)else if input[0] == "2" then (
			box2 := box2 +1
			one := box2+0
		)else if input[0] == "3" then (
			box3 := box3 +1
			one := box3+0
		)else if input[0] == "4" then (
			box4 := box4 +1
			one := box4+0
		)else (one := one)
	)else (one := one)
	if len >= 2 then (
		if input[1] == "1" then (
			box1 := box1 +1
			two := box1+0
		)else if input[1] == "2" then (
			box2 := box2 +1
			two := box2+0
		)else if input[1] == "3" then (
			box3 := box3 +1
			two := box3+0
		)else if input[1] == "4" then (
			box4 := box4 +1
			two := box4+0
		)else (two := two)
	)else (two := two)
	if len >= 3 then (
		if input[2] == "1" then (
			box1 := box1 +1
			three := box1+0
		)else if input[2] == "2" then (
			box2 := box2 +1
			three := box2+0
		)else if input[2] == "3" then (
			box3 := box3 +1
			three := box3+0
		)else if input[2] == "4" then (
			box4 := box4 +1
			three := box4+0
		)else (three := three)
	)else (three := three)
	if len >= 4 then (
		if input[3] == "1" then (
			box1 := box1 +1
			four := box1+0
		)else if input[3] == "2" then (
			box2 := box2 +1
			four := box2+0
		)else if input[3] == "3" then (
			box3 := box3 +1
			four := box3+0
		)else if input[3] == "4" then (
			box4 := box4 +1
			four := box4+0
		)else (four := four)
	)else (four := four)
	if len >= 5 then (
		if input[4] == "1" then (
			box1 := box1 +1
			five := box1+0
		)else if input[4] == "2" then (
			box2 := box2 +1
			five := box2+0
		)else if input[4] == "3" then (
			box3 := box3 +1
			five := box3+0
		)else if input[4] == "4" then (
			box4 := box4 +1
			five := box4+0
		)else (five := five)
	)else (five := five)
	if len >= 6 then (
		if input[5] == "1" then (
			box1 := box1 +1
			six := box1+0
		)else if input[5] == "2" then (
			box2 := box2 +1
			six := box2+0
		)else if input[5] == "3" then (
			box3 := box3 +1
			six := box3+0
		)else if input[5] == "4" then (
			box4 := box4 +1
			six := box4+0
		)else (six := six)
	)else (six := six)
	if len >= 7 then (
		if input[6] == "1" then (
			box1 := box1 +1
			seven := box1+0
		)else if input[6] == "2" then (
			box2 := box2 +1
			seven := box2+0
		)else if input[6] == "3" then (
			box3 := box3 +1
			seven := box3+0
		)else if input[6] == "4" then (
			box4 := box4 +1
			seven := box4+0
		)else (seven := seven)
	)else (seven := seven)
	[one, two, three, four, five, six, seven]
}
############################################################## Typelines
#### Move the cursor past the separator in the p/t and type boxes
type_over_pt := replace@(match:"/$", replace:"")
type_over_type := replace@(match:" ?[-:]$", replace:"")
super_type_filter_default := { "" }
super_type_filter := {
	input := remove_tag(tag: "<word-list-")
	input := type_over_type()
	tag := "word-list-type-" + lang_setting("code")
	"<{tag}>{input}</{tag}>"
}

sub_type_filter_default := { "" }
split_at_spaces := split_text@(match: " +")
remove_leading_spaces := replace@(match: "^ +", replace: "")
remove_trailing_soft_tags := replace@(match: "<soft>.*?</soft>$", replace: "")
replace_soft_tags := replace@(match: "<soft>.*?</soft>", replace: " ")
sub_type_filter :=
{
	subtype_separator := lang_setting("subtype_separator")
	code := lang_setting("code")
	input := remove_tag(input, tag: "<word-list")
	input := remove_trailing_soft_tags(input)
	input := replace_soft_tags(input)
	#### What word list to use?
	list_type_rest :=	if		is_creature(type) or is_kindred(type)		then	"class-"+code
						else if	is_land(type)								then	"land"
						else if	is_artifact(type)							then	"artifact"
						else if	is_enchantment(type)						then	"enchantment"
						else if	is_spell(type)								then	"spell"
						else if	is_planeswalker(type) or is_emblem(type)	then	"planeswalker"
						else if	is_plane(type)								then	"plane-"+code
						else if	is_battle(type)								then	"battle"
						else if	is_dungeon(type)							then	"dungeon"
						else														nil
	if list_type_rest != nil then
	(
		#### Transform subtype_separators into spaces, we'll transform them back later
		input := replace(input, match: subtype_separator, replace: " ")
		input := replace(input, match: remove_tag(subtype_separator, tag: "<atom-sep"), replace: " ")
		input := remove_leading_spaces(input)
		#### Use race list for first sub type of creatures
		list_type_first :=	if lang_setting("is_creature")(type) or lang_setting("is_kindred")(type)
							then "race-"+code
							else list_type_rest
		#### Wrap wordlist tag around each part
		replace_spaced_sub_type := replace_spaced_sub_type_map[code]
		max_count := 2*length(split_at_spaces(input))-1		#### We iterate on the words and the spaces
		sub_types := for i from 0 to max_count do
		(
			if input == "" then "" else (
			#### Check for leading spaces
			new_input := remove_leading_spaces(input)
			if new_input != input then
			(
				spaces := replace(input, match: regex_escape(new_input) + "$", replace: "")
				input := new_input
				spaces
			) else (
			#### Check for space separated sub types
			new_input := replace_spaced_sub_type(input)
			if new_input != input then
			(
				sub_type := replace(input, match: regex_escape(new_input) + "$", replace: "")
				input := new_input
				if i == 0 then "<word-list-{list_type_first}>" + sub_type + "</word-list-{list_type_first}>"
				else "<word-list-{list_type_rest}>" + sub_type + "</word-list-{list_type_rest}>"
			) else (
			#### Check for single word sub types
			split := split_at_spaces(input)
			input := if length(split) > 1 then replace(input, match: "^" + regex_escape(split.0), replace: "") else ""
			if i == 0 then "<word-list-{list_type_first}>" + split.0 + "</word-list-{list_type_first}>"
			else "<word-list-{list_type_rest}>" + split.0 + "</word-list-{list_type_rest}>")))
		)
		#### Add separators between types, keep additional spaces if there are more than one
		sub_types := replace(sub_types, match: "(</word-list[^>]*>)( *)(<word-list)" replace: { substring(_2, begin: 1) + _1 + subtype_separator + _3})
		#### Add a new wordlist box at the end
		if sub_types == "" then "<word-list-{list_type_first}></word-list-{list_type_first}>"
		else sub_types + "<soft>" + subtype_separator + "</soft><word-list-{list_type_rest}></word-list-{list_type_rest}>"
	)
	else input	#### Do nothing if we don't know the type
}
#### all sub types, for word list
space_to_comma := replace@(match:" ", replace:",")
only_first := replace@(match:" .*", replace:"")
only_next :=  replace@(match:"^[^ ]* ?", replace:"")
all_sub_types := {
	for each card in set do
		if lang_setting(setting)(card.super_type) then "," + space_to_comma(to_text(card.sub_type)) else ""
}
all_races := {
	for each card in set do
		if is_creature(card.super_type) or is_kindred(card.super_type) then
			"," + only_first(to_text(card.sub_type))
		else ""
}
all_classes := {
	for each card in set do
		if is_creature(card.super_type) then
			"," + space_to_comma(only_next(to_text(card.sub_type)))
		else ""
}
############################################################## Modal DFC flag hints
auto_flags := {true}
front_modal_hint := {
	if not auto_flags() then ["", ""]
	else if remove_tags(card.sub_type_2) != "" then [card.sub_type_2, "<sym>"+card.casting_cost_2+"</sym>"]
	else if card.casting_cost_2 != "" then [main_type(card.super_type_2), "<sym>"+card.casting_cost_2+"</sym>"]
	else [main_type(card.super_type_2), mana_ability(card.rule_text_2)]
}
back_modal_hint := {
	if not auto_flags() then ["", ""]
	else if remove_tags(card.sub_type) != "" then [card.sub_type, "<sym>"+card.casting_cost+"</sym>"]
	else if card.casting_cost != "" then [main_type(card.super_type), "<sym>"+card.casting_cost+"</sym>"]
	else [main_type(card.super_type), mana_ability(card.rule_text)]
}
mana_ability := {
	abils := break_text(input, match:"(</?sym(-auto)?>)?T(</?sym(-auto)?>)?: Add (</?sym(-auto)?>)?(W|U|B|R|G|C)(</?sym(-auto)?>)?(, | or )?(</?sym(-auto)?>)?(W|U|B|R|G|C)?(</?sym(-auto)?>)?(, or )?(</?sym(-auto)?>)?(W|U|B|R|G|C)?(</?sym(-auto)?>)?.")
	abils[0] or else ""
}
main_type := {
	types := main_types(input)
	if length(types) == 0 then ""
	else if includes("Creature", array:types)
		then "Creature"
	else if includes("Land", array:types)
		then "Land"
	else types[0]
}
main_types := {
	types := break_text(input, match:"(Land|Instant|Sorcery|Artifact|Enchantment|Creature|Planeswalker)")
	types or else [""]
}
#### TODO we'll be able to remove this once transform corners are a card field
node_script := { if card.shape == "double faced" then "transform day"  else "none" }
############################################################## Flavor bar
bar_equation := {if card_style.text.layout.blocks[1].bottom or else 0 > 0 then card_style.text.top + 0.5*(card_style.text.layout.blocks[0].bottom+card_style.text.layout.blocks[1].top) else old_bar_equation()}
bar_equation2 := {if card_style.text_2.layout.blocks[0].bottom or else 0 > 0 then card_style.text_2.top + 0.5*(card_style.text_2.layout.blocks[0].bottom+card_style.text_2.layout.blocks[1].top) else old_bar_equation2()}
bar_equation3 := {if card_style.text_3.layout.blocks[0].bottom or else 0 > 0 then card_style.text_3.top + 0.5*(card_style.text_3.layout.blocks[0].bottom+card_style.text_3.layout.blocks[1].top) else old_bar_equation3()}
#### As of MSE 2.1.2 ^that is all we need to do
#### Previous versions needed the noise down below
#### Which is kept for backwards compatibility
#### And a record of the before times
chop_top := {0}
chop_bot := {0}
bar_offset := {0}
offset_lines := {0}
chop_top2 := {0}
chop_bot2 := {0}
bar_offset2 := {0}
offset_lines2 := {0}
chop_top3 := {0}
chop_bot3 := {0}
bar_offset3 := {0}
offset_lines3 := {0}

#### Set chop_top(), chop_bot(), bar_offset(), and offset_lines to 0 to reduce replacements in chopping frames
#### Full equations to use in chopping templates below
## chop_top := {if styling.chop_top == "" then 0 else if comma_count(styling.chop_top) == "," or comma_count(styling.chop_top) == ",," then split_text(match:",", styling.chop_top).0 else styling.chop_top}
## chop_bot := {if comma_count(styling.chop_top) == ",," then split_text(match:",", styling.chop_top).1 else if styling.chop_bottom == "" then 0 else styling.chop_bottom}
## bar_offset := {if styling.flavor_bar_offset == "-" or styling.flavor_bar_offset == "+" then 0 else to_number(styling.flavor_bar_offset)}
## offset_lines := {offset_counter(styling.flavor_bar_offset)}

top_of_textbox := {card_style.text.top }
bottom_of_textbox := {card_style.text.bottom }
top_of_textbox2 := {card_style.text_2.top }
bottom_of_textbox2 := {card_style.text_2.bottom }
top_of_textbox3 := {card_style.text_3.top }
bottom_of_textbox3 := {card_style.text_3.bottom }
offset_counter := {length(filter_text(input, match:"u")) - length(filter_text(input, match:"d"))}
paragraph_count := filter_text@(match:"\n")
hard_paragraph_count := 
	replace@(match:"<soft-line>\n", replace:"")+				#### count hard breaks for their extra space
	filter_text@(match:"\n")
soft_break_filter :=
	filter_text @(match:"<", in_context: "<match>soft-line>")	#### count soft breaks for quotes
word_split := split_text@(match:" ")							#### split words to better calculate line lengths
small_filter := filter_text@(match:"[\\.,\\?!il’]")				#### grab the tiny characters
fb_length := {length(input) - 0.3 * length(small_filter(input))}#### reduce the effect of tiny characters
calc_lines := { sum := 0										#### estimate lines by character limit
	lines := 1													#### minimum of 1
	for e from 0 to length(input)-1 do (
		sum := sum + fb_length(input[e]);
		if sum > char then (									#### if new word is over the limit
			lines := lines + 1;									#### add new line
			sum := fb_length(input[e]))							#### reset the sum
		else
			sum := sum + 1;										#### else add it and a space to the sum
	)
	lines														#### return number of lines
}
lines_of_text := {												#### estimate lines in break blocks
	lines := 0													#### further improves the previous eq
	for x from 0 to length(input)-1 do
		if input[x] or else "" != "" then						#### if the break isn't empty, check it
			lines := lines + calc_lines(word_split(input[x]), char:char)
	lines
}
flavor_text := {split_text(match:"\n", remove_tags(card.flavor_text+"\n"))}						#### remove tags, add \n so .1 doesn't explode
hard_flavor_break := { if not contains(card.flavor_text, match:"\n") then 0 else if contains(card.flavor_text, match:"<soft-line>\n") then 0 else if lines_of_rules() >= 3 then -3 else -2}
font_size := {min(14,round_near(card_style.text.content_height / card_style.text.content_lines) - 8)}	#### approximate font size
adj_char_width := {7.35 * min(14, font_size()+0.95) / 14}										#### average char width, adjusted for font size
char_per_line := {min(52,round_up(card_style.text.content_width / adj_char_width())+1.5)}		#### approximate character limit. very rarely over 52 but standard eq can reach 60+
lines_of_flavor := {lines_of_text(flavor_text(), char:char_per_line())}												
lines_of_rules := { card_style.text.content_lines - lines_of_flavor() }							#### rules of lines for ratio weirdness
line_height := {(card_style.text.content_height / card_style.text.content_lines)}
padding_height := { 0.5*(bottom_of_textbox() - top_of_textbox() - card_style.text.content_height) }	#### space between top of textbox and text
linebreak_height := { 2*length(hard_paragraph_count(card.rule_text)) }
#### correction for ratio of rules/flavor causing weirdness
uneven_correction := { if lines_of_flavor() == 1 then max(4, (card_style.text.content_lines - (2*lines_of_flavor()))) else (card_style.text.content_lines - (2*lines_of_flavor())) }
#### add it all up
#### old_bar_equation is compatibilty for 2.0.0
old_bar_equation := { top_of_textbox() + padding_height() + card_style.text.content_height - line_height()*(lines_of_flavor() + offset_lines()) + linebreak_height() - uneven_correction() + front_corr() + bar_offset() + hard_flavor_break() +1 }
	
flavor_text2 := {split_text(match:"\n", remove_tags(card.flavor_text_2+"\n"))}						#### remove tags, add \n so .1 doesn't explode
hard_flavor_break2 := { if not contains(card.flavor_text_2, match:"\n") then 0 else if contains(card.flavor_text_2, match:"<soft-line>\n") then 0 else if lines_of_rules2() >= 3 then -3 else -2}
font_size2 := {min(14,round_near(card_style.text_2.content_height / card_style.text_2.content_lines) - 8)}	#### approximate font size
adj_char_width2 := {7.35 * min(14, font_size2()+0.95) / 14}										#### average char width, adjusted for font size
char_per_line2 := {min(52,round_up(card_style.text_2.content_width / adj_char_width2())+1.5)}		#### approximate character limit. very rarely over 52 but standard eq can reach 60+
lines_of_flavor2 := {lines_of_text(flavor_text2(), char:char_per_line2())}												
lines_of_rules2 := { card_style.text_2.content_lines - lines_of_flavor2() }							#### rules of lines for ratio weirdness
line_height2 := {(card_style.text_2.content_height / card_style.text_2.content_lines)}
padding_height2 := { 0.5*(bottom_of_textbox2() - top_of_textbox2() - card_style.text_2.content_height) }	#### space between top of textbox and text
linebreak_height2 := { 2*length(hard_paragraph_count(card.rule_text_2)) }
#### correction for ratio of rules/flavor causing weirdness
uneven_correction2 := { if lines_of_flavor2() == 1 then max(4, (card_style.text_2.content_lines - (2*lines_of_flavor2()))) else (card_style.text_2.content_lines - (2*lines_of_flavor2())) }
#### add it all up
old_bar_equation2 := { top_of_textbox2() + padding_height2() + card_style.text_2.content_height - line_height2()*(lines_of_flavor2() + offset_lines2()) + linebreak_height2() - uneven_correction2() + back_corr() + bar_offset2() + hard_flavor_break2() +1 }

flavor_text3 := {split_text(match:"\n", remove_tags(card.flavor_text_3+"\n"))}						#### remove tags, add \n so .1 doesn't explode
hard_flavor_break3 := { if not contains(card.flavor_text_3, match:"\n") then 0 else if contains(card.flavor_text_3, match:"<soft-line>\n") then 0 else if lines_of_rules3() >= 3 then -3 else -2}
font_size3 := {min(14,round_near(card_style.text_3.content_height / card_style.text_3.content_lines) - 8)}	#### approximate font size
adj_char_width3 := {7.35 * min(14, font_size3()+0.95) / 14}										#### average char width, adjusted for font size
char_per_line3 := {min(52,round_up(card_style.text_3.content_width / adj_char_width3())+1.5)}		#### approximate character limit. very rarely over 52 but standard eq can reach 60+
lines_of_flavor3 := {lines_of_text(flavor_text3(), char:char_per_line3())}												
lines_of_rules3 := { card_style.text_3.content_lines - lines_of_flavor3() }							#### rules of lines for ratio weirdness
line_height3 := {(card_style.text_3.content_height / card_style.text_3.content_lines)}
padding_height3 := { 0.5*(bottom_of_textbox3() - top_of_textbox3() - card_style.text_3.content_height) }	#### space between top of textbox and text
linebreak_height3 := { 2*length(hard_paragraph_count(card.rule_text_3)) }
#### correction for ratio of rules/flavor causing weirdness
uneven_correction3 := { if lines_of_flavor3() == 1 then max(4, (card_style.text_3.content_lines - (2*lines_of_flavor3()))) else (card_style.text_3.content_lines - (2*lines_of_flavor3())) }
#### add it all up
old_bar_equation3 := { top_of_textbox3() + padding_height3() + card_style.text_3.content_height - line_height3()*(lines_of_flavor3() + offset_lines3()) + linebreak_height3() - uneven_correction3() + third_corr() + bar_offset3() + hard_flavor_break3() +1 }

#### long correction coefficient based off several sets of data
front_corr := {correction_coeff(lof:lines_of_flavor(), lor:lines_of_rules(), lbh:linebreak_height())}
back_corr := {correction_coeff(lof:lines_of_flavor2(), lor:lines_of_rules2(), lbh:linebreak_height2())}
third_corr := {correction_coeff(lof:lines_of_flavor3(), lor:lines_of_rules3(), lbh:linebreak_height3())}
correction_coeff := {
	(if lor == 1 then
		(if lof == 1 then 3
		else if lof == 2 then 1
		else if lof == 3 then 1.5
		else if lof == 4 then 0
		else 5 - lof)
	else if lor == 2 and lbh == 2 then
		(if lof == 1 then 1
		else if lof == 2 then 1
		else if lof == 3 then 2
		else if lof == 4 then 2
		else 3)
	else if lor == 2 then
		(if lof == 1 then 1
		else if lof == 2 then 0
		else if lof == 3 then 0
		else if lof == 4 then 0
		else -1)
	else if lor == 3 and lbh == 2 then
		(if lof == 1 then 0
		else if lof == 2 then 0
		else if lof == 3 then 1
		else if lof == 4 then 1
		else 2)
	else if lor == 3 then
		(if lof == 1 then 0
		else if lof == 2 then -1
		else if lof == 3 then -0.5
		else if lof == 4 then -1
		else 0)
	else if lor == 4 and lbh == 2 then
		(-2 + lof)
	else if lor == 4 then
		(if lof == 1 then -1
		else if lof == 2 then 0
		else if lof == 3 then -0.5
		else -1)
	else if lor == 5 and lbh == 4 then
		(-5 + lof)
	else if lor == 5 and lbh == 2 then
		(-2 + lof)
	else if lor == 5 then
		(2 - lof)
	else if lor == 6 and lbh == 2 then
		(-1 - lof)
		else if lor == 6 then
		(2 - lof)
	else 0) + (if lbh >= 4 then 0.5*lbh-1)
}
############################################################## Watermarks
invert_watermark_1 := { false }
invert_watermark_2 := { false }
invert_watermark_3 := { false }
verify_watermark_image := {
	array := split_comma(input)
	if not has_png(array.0)
		then array.0
	else (
		wm_link := array.0
		wm_exists := exists_in_package("/magic-mainframe-extras.mse-include/"+wm_link)
		if not wm_exists then (
			wm_link + ",Not found,Ensure the file name is correct in /data/magic-mainframe-extras and reload"
		) else (
			wm_width := width_of("/magic-mainframe-extras.mse-include/"+wm_link)
			wm_height := height_of("/magic-mainframe-extras.mse-include/"+wm_link)
			if (wm_width > 1024 or wm_height > 1024)
				then wm_link + ",File found,Limit watermarks to 1024x1024px or smaller for color blending"
			else wm_link + ",File found,{wm_width}x{wm_height}px"
		)
	)
}
custom_watermark_link := {
	field := set["custom_watermark_"+input]
	array := split_comma(field)
	#### not blank, has png, is either verified or old link that's probably fine
	if array.0 != "" and (has_png(array.0) and array.1 or else "" != "Not found")
		then "/magic-mainframe-extras.mse-include/"+(if long then field else array.0)
	else "/magic-modules.mse-include/watermarks/other/planeswalker.png"
}@(long:false)
card_watermark_a := {""}
custom_card_watermark := {
	tag := if face == 1 then "" else "_" + face
	field := styling["card_watermark"+tag] or else ""
	array := split_comma(field)
	#### not blank, has png, is either verified or old link that's probably fine
	if array.0 != "" and (has_png(array.0) and array.1 or else "" != "Not found")
		then "/magic-mainframe-extras.mse-include/"+(if long then field else array.0)
	else if card_watermark_a() != "" then "/magic-mainframe-extras.mse-include/" + card_watermark_a()
	else "/magic-modules.mse-include/watermarks/other/planeswalker.png"
}@(long:false)
card_new_color := {
	if card.card_color == "white" then "w"
	else if card.card_color == "blue" then "u"
	else if card.card_color == "black" then "b"
	else if card.card_color == "red" then "r"
	else if card.card_color == "green" then "g"
	else if contains(card.card_color, match:"artifact") then "a"
	else if contains(card.card_color, match:"multi") or contains(card.card_color, match:"hybrid") then "m"
	else "c"
}
# Watermark images
wm_directory := "/magic-modules.mse-include/watermarks/"
watermark_scripts :=
[
	"none":                                               { "" }
	
	"mana symbol white":                                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_w.png", face:face) }
	"mana symbol blue":                                   { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_u.png", face:face) }
	"mana symbol black":                                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_b.png", face:face) }
	"mana symbol red":                                    { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_r.png", face:face) }
	"mana symbol green":                                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_g.png", face:face) }
	"mana symbol colorless":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_c.png", face:face) }
	"mana symbol snow":                                   { watermark_blend(wm_directory + "mana symbols/watermark_s.png", face:face) }
	
	"mana symbol old white":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_w_old.png", face:face) }
	"mana symbol old blue":                               { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_u_old.png", face:face) }
	"mana symbol old black":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_b_old.png", face:face) }
	"mana symbol old red":                                { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_r_old.png", face:face) }
	"mana symbol old green":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_g_old.png", face:face) }
	"mana symbol old colorless":                          { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_c_old.png", face:face) }
	
	"mana symbol hi res white":                           { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_w_big.png", face:face) }
	"mana symbol hi res blue":                            { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_u_big.png", face:face) }
	"mana symbol hi res black":                           { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_b_big.png", face:face) }
	"mana symbol hi res red":                             { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_r_big.png", face:face) }
	"mana symbol hi res green":                           { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_g_big.png", face:face) }
	"mana symbol hi res colorless":                       { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana symbols/watermark_c_big.png", face:face) }
	
	"mana symbol double WU":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_wu.png", face:face) }
	"mana symbol double UB":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_ub.png", face:face) }
	"mana symbol double BR":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_br.png", face:face) }
	"mana symbol double RG":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_rg.png", face:face) }
	"mana symbol double GW":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_gw.png", face:face) }
	"mana symbol double WB":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_wb.png", face:face) }
	"mana symbol double UR":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_ur.png", face:face) }
	"mana symbol double BG":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_bg.png", face:face) }
	"mana symbol double RW":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_rw.png", face:face) }
	"mana symbol double GU":                              { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_gu.png", face:face) }
	
	"transparent mana symbol white":                      { watermark_blend(colored: true, alpha: 0.45, dark_alpha: 0.30, wm_directory + "mana symbols/watermark_w.png", face:face) }
	"transparent mana symbol blue":                       { watermark_blend(colored: true, alpha: 0.35, dark_alpha: 0.30, wm_directory + "mana symbols/watermark_u.png", face:face) }
	"transparent mana symbol black":                      { watermark_blend(colored: true, alpha: 0.30, dark_alpha: 0.45, wm_directory + "mana symbols/watermark_b.png", face:face) }
	"transparent mana symbol red":                        { watermark_blend(colored: true, alpha: 0.35, dark_alpha: 0.30, wm_directory + "mana symbols/watermark_r.png", face:face) }
	"transparent mana symbol green":                      { watermark_blend(colored: true, alpha: 0.35, dark_alpha: 0.30, wm_directory + "mana symbols/watermark_g.png", face:face) }
	
	"transparent mana symbol old white":                  { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_w_old.png", face:face) }
	"transparent mana symbol old blue":                   { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_u_old.png", face:face) }
	"transparent mana symbol old black":                  { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_b_old.png", face:face) }
	"transparent mana symbol old red":                    { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_r_old.png", face:face) }
	"transparent mana symbol old green":                  { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_g_old.png", face:face) }
	"transparent mana symbol old colorless":              { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_c_old.png", face:face) }
	
	"transparent mana symbol hi res white":               { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_w_big.png", face:face) }
	"transparent mana symbol hi res blue":                { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_u_big.png", face:face) }
	"transparent mana symbol hi res black":               { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_b_big.png", face:face) }
	"transparent mana symbol hi res red":                 { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_r_big.png", face:face) }
	"transparent mana symbol hi res green":               { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_g_big.png", face:face) }
	"transparent mana symbol hi res colorless":           { watermark_blend(colored: true, alpha: 0.4, dark_alpha: 0.4, wm_directory + "mana symbols/watermark_c_big.png", face:face) }
	
	"transparent mana symbol double WU":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_wu_old.png", face:face) }
	"transparent mana symbol double UB":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_ub_old.png", face:face) }
	"transparent mana symbol double BR":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_br_old.png", face:face) }
	"transparent mana symbol double RG":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_rg_old.png", face:face) }
	"transparent mana symbol double GW":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_gw_old.png", face:face) }
	"transparent mana symbol double WB":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_wb_old.png", face:face) }
	"transparent mana symbol double UR":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_ur_old.png", face:face) }
	"transparent mana symbol double BG":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_bg_old.png", face:face) }
	"transparent mana symbol double RW":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_rw_old.png", face:face) }
	"transparent mana symbol double GU":                  { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "mana double/mana_gu_old.png", face:face) }
	
	"guild symbol The Azorius Senate (W/U)":              { watermark_blend(wm_directory + "ravnica/watermark_azorius2.png", face:face) }
	"guild symbol House Dimir (U/B)":                     { watermark_blend(wm_directory + "ravnica/watermark_dimir2.png", face:face) }
	"guild symbol The Cult of Rakdos (B/R)":              { watermark_blend(wm_directory + "ravnica/watermark_rakados2.png", face:face) }
	"guild symbol The Gruul Clans (R/G)":                 { watermark_blend(wm_directory + "ravnica/watermark_gruul2.png", face:face) }
	"guild symbol The Selesnya Conclave (G/W)":           { watermark_blend(wm_directory + "ravnica/watermark_selesnya2.png", face:face) }
	"guild symbol The Orzhov Syndicate (W/B)":            { watermark_blend(wm_directory + "ravnica/watermark_orzhov2.png", face:face) }
	"guild symbol The Izzet (U/R)":                       { watermark_blend(wm_directory + "ravnica/watermark_izzet2.png", face:face) }
	"guild symbol The Golgari (B/G)":                     { watermark_blend(wm_directory + "ravnica/watermark_golgari2.png", face:face) }
	"guild symbol The Boros Legion (R/W)":                { watermark_blend(wm_directory + "ravnica/watermark_boros2.png", face:face) }
	"guild symbol The Simic Combine (G/U)":               { watermark_blend(wm_directory + "ravnica/watermark_simic2.png", face:face) }
	
	"guild symbol originals The Azorius Senate (W/U)":    { watermark_blend(wm_directory + "ravnica/watermark_azorius.png", face:face) }
	"guild symbol originals House Dimir (U/B)":           { watermark_blend(wm_directory + "ravnica/watermark_dimir.png", face:face) }
	"guild symbol originals The Cult of Rakdos (B/R)":    { watermark_blend(wm_directory + "ravnica/watermark_rakados.png", face:face) }
	"guild symbol originals The Gruul Clans (R/G)":       { watermark_blend(wm_directory + "ravnica/watermark_gruul.png", face:face) }
	"guild symbol originals The Selesnya Conclave (G/W)": { watermark_blend(wm_directory + "ravnica/watermark_selesnya.png", face:face) }
	"guild symbol originals The Orzhov Syndicate (W/B)":  { watermark_blend(wm_directory + "ravnica/watermark_orzhov.png", face:face) }
	"guild symbol originals The Izzet (U/R)":             { watermark_blend(wm_directory + "ravnica/watermark_izzet.png", face:face) }
	"guild symbol originals The Golgari (B/G)":           { watermark_blend(wm_directory + "ravnica/watermark_golgari.png", face:face) }
	"guild symbol originals The Boros Legion (R/W)":      { watermark_blend(wm_directory + "ravnica/watermark_boros.png", face:face) }
	"guild symbol originals The Simic Combine (G/U)":     { watermark_blend(wm_directory + "ravnica/watermark_simic.png", face:face) }
	
	"guild symbol ancients The Azorius Senate (W/U)":     { watermark_blend(wm_directory + "frazier/azorius.png", face:face) }
	"guild symbol ancients House Dimir (U/B)":            { watermark_blend(wm_directory + "frazier/dimir.png", face:face) }
	"guild symbol ancients The Cult of Rakdos (B/R)":     { watermark_blend(wm_directory + "frazier/rakdos.png", face:face) }
	"guild symbol ancients The Gruul Clans (R/G)":        { watermark_blend(wm_directory + "frazier/gruul.png", face:face) }
	"guild symbol ancients The Selesnya Conclave (G/W)":  { watermark_blend(wm_directory + "frazier/selesnya.png", face:face) }
	"guild symbol ancients The Orzhov Syndicate (W/B)":   { watermark_blend(wm_directory + "frazier/orzhov.png", face:face) }
	"guild symbol ancients The Izzet (U/R)":              { watermark_blend(wm_directory + "frazier/izzet.png", face:face) }
	"guild symbol ancients The Golgari (B/G)":            { watermark_blend(wm_directory + "frazier/golgari.png", face:face) }
	"guild symbol ancients The Boros Legion (R/W)":       { watermark_blend(wm_directory + "frazier/boros.png", face:face) }
	"guild symbol ancients The Simic Combine (G/U)":      { watermark_blend(wm_directory + "frazier/simic.png", face:face) }
	
	"faction symbol mirrodin":                            { watermark_blend(wm_directory + "mirrodin/mirrodin.png", face:face) }
	"faction symbol phyrexia":                            { watermark_blend(wm_directory + "mirrodin/phyrexia.png", face:face) }
	
	"clan symbol The Abzan Houses (WBG)":                 { watermark_blend(wm_directory + "tarkir/abzan.png", face:face) }
	"clan symbol The Jeskai Way (URW)":                   { watermark_blend(wm_directory + "tarkir/jeskai.png", face:face) }
	"clan symbol The Sultai Brood (BGU)":                 { watermark_blend(wm_directory + "tarkir/sultai.png", face:face) }
	"clan symbol The Mardu Horde (RWB)":                  { watermark_blend(h:400, wm_directory + "tarkir/mardu.png", face:face) }
	"clan symbol The Temur Frontier (GUR)":               { watermark_blend(wm_directory + "tarkir/temur.png", face:face) }
	
	"brood symbol Dromoka's Brood (GW)":                  { watermark_blend(wm_directory + "tarkir/dromoka.png", face:face) }
	"brood symbol Ojutai's Brood (WU)":                   { watermark_blend(wm_directory + "tarkir/ojutai.png", face:face) }
	"brood symbol Silumgar's Brood (UB)":                 { watermark_blend(wm_directory + "tarkir/silumgar.png", face:face) }
	"brood symbol Kolaghan's Brood (BR)":                 { watermark_blend(wm_directory + "tarkir/kolaghan.png", h:400, face:face) }
	"brood symbol Atarka's Brood (RG)":                   { watermark_blend(wm_directory + "tarkir/atarka.png", face:face) }
	
	"family symbol Brokers (GWU)":                        { watermark_blend(wm_directory + "capenna/brokers.png", face:face) }
	"family symbol Cabaretti (RGW)":                      { watermark_blend(wm_directory + "capenna/cabaretti.png", face:face) }
	"family symbol Maestros (UBR)":                       { watermark_blend(wm_directory + "capenna/maestros.png", face:face) }
	"family symbol Obscura (WUB)":                        { watermark_blend(wm_directory + "capenna/obscura.png", face:face) }
	"family symbol Riveteers (BRG)":                      { watermark_blend(wm_directory + "capenna/riveteers.png", face:face) }
	
	"unstable factions Order of the Widget":              { watermark_blend(wm_directory + "unstable/widget.png", face:face) }
	"unstable factions Agents of S.N.E.A.K.":             { watermark_blend(wm_directory + "unstable/SNEAK.png", face:face) }
	"unstable factions League of Dastardly Doom":         { watermark_blend(wm_directory + "unstable/doom.png", face:face) }
	"unstable factions Goblin Explosioneers":             { watermark_blend(wm_directory + "unstable/explosioneers.png", face:face) }
	"unstable factions Crossbreed Labs":                  { watermark_blend(wm_directory + "unstable/crossbreed.png", face:face) }
	
	"colored xander hybrid mana B/R":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/brmana_colored.png", face:face) }
	"colored xander hybrid mana U/B":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/ubmana_colored.png", face:face) }
	"colored xander hybrid mana B/G":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/bgmana_colored.png", face:face) }
	"colored xander hybrid mana R/G":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/rgmana_colored.png", face:face) }
	"colored xander hybrid mana G/U":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/gumana_colored.png", face:face) }
	"colored xander hybrid mana U/R":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/urmana_colored.png", face:face) }
	"colored xander hybrid mana W/B":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/wbmana_colored.png", face:face) }
	"colored xander hybrid mana G/W":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/gwmana_colored.png", face:face) }
	"colored xander hybrid mana R/W":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/rwmana_colored.png", face:face) }
	"colored xander hybrid mana W/U":                     { watermark_blend(colored: true, alpha: 1, dark_alpha: 1, wm_directory + "xander/wumana_colored.png", face:face) }
	
	"xander hybrid mana B/R":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/brmana.png", face:face) }
	"xander hybrid mana U/B":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/ubmana.png", face:face) }
	"xander hybrid mana B/G":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/bgmana.png", face:face) }
	"xander hybrid mana R/G":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/rgmana.png", face:face) }
	"xander hybrid mana G/U":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/gumana.png", face:face) }
	"xander hybrid mana U/R":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/urmana.png", face:face) }
	"xander hybrid mana W/B":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/wbmana.png", face:face) }
	"xander hybrid mana G/W":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/gwmana.png", face:face) }
	"xander hybrid mana R/W":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/rwmana.png", face:face) }
	"xander hybrid mana W/U":                             { watermark_blend(alpha: 0.26, spotlight_alpha: 0.85, dark_alpha: 0.26, dark_spotlight_alpha: 0.85, h:266, l:266, wm_directory + "xander/wumana.png", face:face) }
	
	"future sight type symbols artifact":                 { watermark_blend(wm_directory + "future/artifact.png", face:face) }
	"future sight type symbols creature":                 { watermark_blend(wm_directory + "future/creature.png", face:face) }
	"future sight type symbols enchantment":              { watermark_blend(wm_directory + "future/enchantment.png", face:face) }
	"future sight type symbols instant":                  { watermark_blend(wm_directory + "future/instant.png", face:face) }
	"future sight type symbols land":                     { watermark_blend(wm_directory + "future/land.png", face:face) }
	"future sight type symbols multiple":                 { watermark_blend(wm_directory + "future/multiple.png", face:face) }
	"future sight type symbols planeswalker":             { watermark_blend(wm_directory + "future/planeswalker.png", face:face) }
	"future sight type symbols sorcery":                  { watermark_blend(wm_directory + "future/sorcery.png", face:face) }
	"future sight type symbols structure":                { watermark_blend(wm_directory + "future/structure.png", face:face) }
	
	"other magic symbols chaos symbol":                   { watermark_blend(h:500, l:500, wm_directory + "other/chaos.png", face:face) }
	"other magic symbols story spotlight":                { watermark_blend(h:500, l:500, wm_directory + "other/planeswalker.png", face:face) }
	"other magic symbols color spotlight":                { watermark_blend(h:500, l:500, wm_directory + "other/planeswalker.png", face:face) }
	"other magic symbols shooting star":                  { watermark_blend(h:400, l:500, wm_directory + "promo/shooting_star.png", face:face) }
	"other magic symbols color pie":                      { watermark_blend(h:500, l:500, wm_directory + "other/colorpie.png", face:face) }
	"other magic symbols judge academy":                  { watermark_blend(h:500, l:500, wm_directory + "promo/judge_academy.png", face:face) }
	"other magic symbols foretell":                       { watermark_blend(h:460, l:500, wm_directory + "other/foretell.png", face:face) }
	"other magic symbols jace consortium":                { watermark_blend(h:500, l:500, wm_directory + "other/jace-consortium.png", face:face) }
	"other magic symbols seekers of carmot":              { watermark_blend(h:500, l:500, wm_directory + "other/seekersofcarmot.png", face:face) }
	"other magic symbols desparked":                      { watermark_blend(h:500, l:500, wm_directory + "other/desparked.png", face:face) }
	"other magic symbols aetherprint":                    { watermark_blend(alpha: 0.28, spotlight_alpha: 0.55, dark_alpha: 0.28, dark_spotlight_alpha: 0.5, h:500, l:317, wm_directory + "other/aetherprint.png", face:face) }
	"other magic symbols phyrexia":                       { watermark_blend(alpha: 0.30, spotlight_alpha: 0.60, dark_alpha: 0.30, dark_spotlight_alpha: 0.5, h:217, l:115, wm_directory + "other/phyrexia.png", face:face) }
	"other magic symbols the thran":                      { watermark_blend(alpha: 0.25, spotlight_alpha: 0.55, dark_alpha: 0.28, dark_spotlight_alpha: 0.4, h:240, l:163, wm_directory + "other/thran.png", face:face) }
	"other magic symbols conspiracy stamp":               { watermark_blend(colored: true, alpha: 0.35, dark_alpha: 0.25, wm_directory + "other/conspiracy_stamp.png", face:face) }
	
	"other magic symbols innistrad provinces stensia":    { watermark_blend(wm_directory + "innistrad/stensia.png", face:face) }
	"other magic symbols innistrad provinces kessig":     { watermark_blend(wm_directory + "innistrad/kessig.png", face:face) }
	"other magic symbols innistrad provinces gavony":     { watermark_blend(wm_directory + "innistrad/gavony.png", face:face) }
	"other magic symbols innistrad provinces nephalia":   { watermark_blend(wm_directory + "innistrad/nephalia.png", face:face) }
	
	"other magic symbols theros poleis akros":            { watermark_blend(wm_directory + "theros/akros.png", face:face) }
	"other magic symbols theros poleis meletis":          { watermark_blend(wm_directory + "theros/meletis.png", face:face) }
	"other magic symbols theros poleis setessa":          { watermark_blend(wm_directory + "theros/setessa.png", face:face) }
	
	"alara symbols Bant":                                 { watermark_blend(wm_directory + "alara/bant.png", face:face) }
	"alara symbols Esper":                                { watermark_blend(wm_directory + "alara/esper.png", face:face) }
	"alara symbols Grixis":                               { watermark_blend(wm_directory + "alara/grixis.png", face:face) }
	"alara symbols Jund":                                 { watermark_blend(wm_directory + "alara/jund.png", face:face) }
	"alara symbols Naya":                                 { watermark_blend(wm_directory + "alara/naya.png", face:face) }
	
	"alara symbols colored Bant":                         { watermark_blend(colored: true, alpha: 0.25, dark_alpha: 0.25, wm_directory + "alara/bant_colored.png", face:face) }
	"alara symbols colored Esper":                        { watermark_blend(colored: true, alpha: 0.25, dark_alpha: 0.40, wm_directory + "alara/esper_colored.png", face:face) }
	"alara symbols colored Grixis":                       { watermark_blend(colored: true, alpha: 0.22, dark_alpha: 0.55, wm_directory + "alara/grixis_colored.png", face:face) }
	"alara symbols colored Jund":                         { watermark_blend(colored: true, alpha: 0.25, dark_alpha: 0.40, wm_directory + "alara/jund_colored.png", face:face) }
	"alara symbols colored Naya":                         { watermark_blend(colored: true, alpha: 0.25, dark_alpha: 0.30, wm_directory + "alara/naya_colored.png", face:face) }
	
	"college symbols Silverquill":                        { watermark_blend(wm_directory + "strixhaven/silverquill.png", face:face) }
	"college symbols Prismari":                           { watermark_blend(wm_directory + "strixhaven/prismari.png", face:face) }
	"college symbols Witherbloom":                        { watermark_blend(wm_directory + "strixhaven/witherbloom.png", face:face) }
	"college symbols Lorehold":                           { watermark_blend(wm_directory + "strixhaven/lorehold.png", face:face) }
	"college symbols Quandrix":                           { watermark_blend(wm_directory + "strixhaven/quandrix.png", face:face) }
	
	"universes beyond D&D":                               { watermark_blend(wm_directory + "ub/d&d.png", face:face) }
	"universes beyond transformers":                      { watermark_blend(wm_directory + "ub/transformers.png", face:face) }
	"universes beyond ponies applejack":                  { watermark_blend(wm_directory + "ponies/applejack.png", face:face) }
	"universes beyond ponies pinkie pie":                 { watermark_blend(wm_directory + "ponies/pinkie pie.png", face:face) }
	"universes beyond ponies fluttershy":                 { watermark_blend(wm_directory + "ponies/fluttershy.png", face:face) }
	"universes beyond ponies rainbow dash":               { watermark_blend(wm_directory + "ponies/rainbow dash.png", face:face) }
	"universes beyond ponies rarity":                     { watermark_blend(wm_directory + "ponies/rarity.png", face:face) }
	"universes beyond ponies twilight sparkle":           { watermark_blend(wm_directory + "ponies/twilight sparkle.png", face:face) }
	"universes beyond ponies nightmare moon":             { watermark_blend(wm_directory + "ponies/nightmare moon.png", face:face) }
	"universes beyond ponies luna":                       { watermark_blend(wm_directory + "ponies/luna.png", face:face) }
	
	"custom watermark one":                               { build_custom_watermark_blend(1) }
	"custom watermark two":                               { build_custom_watermark_blend(2) }
	"custom watermark three":                             { build_custom_watermark_blend(3) }
	"custom watermark four":                              { build_custom_watermark_blend(4) }
	"custom watermark five":                              { build_custom_watermark_blend(5) }
	"custom watermark six":                               { build_custom_watermark_blend(6) }
	"custom watermark seven":                             { build_custom_watermark_blend(7) }
	"custom watermark eight":                             { build_custom_watermark_blend(8) }
	"custom watermark nine":                              { build_custom_watermark_blend(9) }
	"custom watermark ten":                               { build_custom_watermark_blend(10) }
	"custom watermark card":                              { build_custom_watermark_blend("a") }
	
	"set symbol":                                         { if (styling.watermark_render or else set.blend_with_colors) == "glow" then glow_watermark_blend(symbol_variation(symbol: set.symbol, variation: "watermark"), face:face) else shadow_watermark_blend(symbol_variation(symbol: set.symbol, variation: "watermark"), face:face) }
]
watermark_image_1 := { watermark_scripts[card.watermark](face:watermark_face_1()) or else "" }
watermark_image_2 := { watermark_scripts[card.watermark_2](face:watermark_face_2()) or else ""  }
watermark_image_3 := { watermark_scripts[card.watermark_3](face:watermark_face_3()) or else ""  }
build_custom_watermark_blend := {
	info := if input == "a" then custom_card_watermark(face:face, long:true)
		else custom_watermark_link(input, long:true)
	array := split_comma(info)
	link := array.0
	l := 500
	h := 500
	if length(array) > 1 then (
		px := px_split(array.2)
		if length(px) > 2
			then l := 0
		else (
			l := px.0
			h := px.1
		)
	)
	watermark_blend(link, l:l, h:h, custom:true, face:face)
}
############################################################## Other scripted fields
#### Dimensions of card faces, can be changed in style files
faces_coordinates := {
	[
		[
			left: 0,
			top: 0,
			width: stylesheet.card_width,
			height: stylesheet.card_height
		]
	]
}
face_coordinates_string := {
	fc := faces_coordinates()
	for x from 0 to length(fc) - 1 do fc[x].left + "," + fc[x].top + "," + fc[x].width + "," + fc[x].height + ";"
}
face_coordinates_map := {
	fc := faces_coordinates()
	fc[input-1] or else [top: 0, left:0, width:0, height:0]
}
face_is_rotated :=
{
	map := face_coordinates_map(input)
	map.width > map.height
}
############################################################## Information below the textbox
############################################################## Global offsets
#### To shift everything up/down:
information_offset_top_1 := { 0 }
#### To shift the card number, set code and artist credit left/right:
information_codes_offset_left_1 := { 0 }
#### To shift the actual copyright lines left/right:
information_copyright_offset_right_1 := { 0 }
#### To shift the copyright up/down on creatures/walkers, if the pt/loyalty box is very short/tall:
information_copyright_offset_pt_top_1 := { 0 }
#### To shift the secondary copyright left/right on creatures/walkers, if the pt/loyalty box is very narrow/wide:
information_secondary_offset_pt_left_1 := { 0 }
#### Disable if the pt/loyalty doesn't affect the secondary copyright
information_secondary_shift_with_pt_1 := { true }
#### For the other faces on DFCs use:
information_offset_top_2 := { 0 }
information_codes_offset_left_2 := { 0 }
information_copyright_offset_right_2 := { 0 }
information_copyright_offset_pt_top_2 := { 0 }
information_secondary_offset_pt_left_2 := { 0 }
information_offset_top_3 := { 0 }
information_codes_offset_left_3 := { 0 }
information_copyright_offset_right_3 := { 0 }
information_copyright_offset_pt_top_3 := { 0 }
information_secondary_offset_pt_left_3 := { 0 }
information_secondary_shift_with_pt_2 := { true }
information_secondary_shift_with_pt_3 := { true }
#### These work the same on 90° rotated cards, but you need to imagine the card is upright
#### For DFC or TFC templates, dont forget to override the faces_coordinates function.
#### You can disable the copyright on some of the faces,
#### by adding the following functions in the init script:
information_disabled_1 := { false }
information_disabled_2 := { false }
information_disabled_3 := { false }

############################################################## Card code fields
set_code_script :=
{
	code := if is_masterpiece() then set.masterpiece_set_code else set.set_code
	if code == "" then set.set_language else (
	brush :=	if		margin_code == "setcode1" then	card.additional_credit_brush
				else if	margin_code == "setcode2" then	card.additional_credit_brush_4
				else if	margin_code == "setcode3" then	card.additional_credit_brush_5
				else									"none"
	if brush == "none" or (not set.adaptive_language_height)
	then code + (if set.set_language != "" then " • " else "") + set.set_language
	else code)
}
set_language_script :=
{
	set.set_language
}
#### a/b add-ons for DFCs
card_number_tags := {
	if contains(card.shape, match:"double")
		then ["a", "b", "b"]
	else ["", "", ""]
}
#### Card number section of card code
card_number_formatter := {
	cn_tag := card_number_tags().0
	
	case set.card_number_style of
		"0001/0099": card_number_mom() + cn_tag + (if set.over_partition_display == "100" and over_partition() then "" else "/" + card_count_mom()),
		"001/099": card_number_m15() + cn_tag + (if set.over_partition_display == "100" and over_partition() then "" else "/" + card_count_m15()),
		"1/99": card_number() + cn_tag + (if set.over_partition_display == "100" and over_partition() then "" else "/" + card_count()),
		"0001": card_number_mom() + cn_tag,
		"001": card_number_m15() + cn_tag,
		else: card_number() + cn_tag
}
#### General card code handler
card_code_script_core := {
	auto_number := use_auto_numbers()
	rc := rarity_code()
	if rc != "" then rc := rc + " "
	cn_style := set.card_number_style
	cn := adjust_face_card_number(card.card_number, face:face)
	if not auto_number and cn_style == "0001" then
		### R CUSTOM TEXT
		combined_editor(prefix: rc, field1: card.custom_card_number, separator: " ", field2: card_code_text)
	else if not auto_number then
		### CUSTOM R TEXT
		combined_editor(field1: card.custom_card_number, separator: " " + rc, field2: card_code_text)
	else if cn_style == "0001/0099" or cn_style == "0001" then
		### R C#### TEXT
		forward_editor(prefix: rc + cn + " ", field: card_code_text)
	else
		### C# R TEXT
		forward_editor(prefix: cn + " " + rc, field: card_code_text)
}@(tag: "")

#### Card code script for individual faces
card_code_script :=
{
	card_code_script_core(card_code_text: card.card_code_text, face:1)
}
card_code_script2 :=
{
	card_code_script_core(card_code_text: card.card_code_text_2, face:2)
}
card_code_script3 :=
{
	card_code_script_core(card_code_text: card.card_code_text_3, face:3)
}
use_auto_numbers := {set.automatic_card_numbers and not is_unsorted()}
adjust_face_card_number := {
	cn_tags := card_number_tags()
	original := cn_tags.0
	change_to := cn_tags[face-1]
	
	if original == change_to
		then input
	else if original != ""
		then replace(input, match:original, replace:change_to)
	else (
		if contains(input, match:"/")
			then replace(input, match:"/", replace:change_to + "/")
		else input + change_to
	)
}@(face:1)

#### i tried to make this one work like above but it kept breaking so here
card_number_old_1 := {
	auto_number := use_auto_numbers()
	auto_copy := set.automatic_copyright
	
	if auto_copy and not auto_number then
		combined_editor(
			field1: card.auto_copyright,
			separator1: " ",
			field2: card.custom_card_number,
			separator2: " ",
			field3: card.card_code_text
		)
	else if not auto_number then
		combined_editor(
			field1: card.copyright,
			separator1: " ",
			field2: card.custom_card_number,
			separator2: " ",
			field3: card.card_code_text
		)
	else if auto_copy then
		combined_editor(
			field1: card.auto_copyright,
			separator: " " + card.card_number + " ",
			field2: card.card_code_text
		)
	else
		combined_editor(
			field1: card.copyright,
			separator: " " + card.card_number + " ",
			field2: card.card_code_text
		)
}
card_number_old_2 := {
	auto_number := use_auto_numbers()
	auto_copy := set.automatic_copyright
	cn := adjust_face_card_number(if auto_number then card.card_number else card.custom_card_number, face:2)
	
	if auto_copy and not auto_number then
		combined_editor(
			field1: card.auto_copyright_2,
			separator: " " + cn + " ",
			field2: card.card_code_text_2
		)
	else if not auto_number then
		combined_editor(
			field1: card.copyright_2,
			separator: " " + cn + " ",
			field2: card.card_code_text_2
		)
	else if auto_copy then
		combined_editor(
			field1: card.auto_copyright_2,
			separator: " " + cn + " ",
			field2: card.card_code_text_2
		)
	else
		combined_editor(
			field1: card.copyright_2,
			separator: " " + cn + " ",
			field2: card.card_code_text_2
		)

}
card_number_old_3 := {
	auto_number := use_auto_numbers()
	auto_copy := set.automatic_copyright
	cn := adjust_face_card_number(if auto_number then card.card_number else card.custom_card_number, face:3)
	
	if auto_copy and not auto_number then
		combined_editor(
			field1: card.auto_copyright_3,
			separator: " " + cn + " ",
			field2: card.card_code_text_3
		)
	else if not auto_number then
		combined_editor(
			field1: card.copyright_3,
			separator: " " + cn + " ",
			field2: card.card_code_text_3
		)
	else if auto_copy then
		combined_editor(
			field1: card.auto_copyright_3,
			separator: " " + cn + " ",
			field2: card.card_code_text_3
		)
	else
		combined_editor(
			field1: card.copyright_3,
			separator: " " + cn + " ",
			field2: card.card_code_text_3
		)

}
############################################################## Copyright fields
copyright_default := { set.copyright }
secondary_copyright_default := { set.secondary_copyright }
############################################################## Additional credit fields
illustrator_brush_default := { "art" }
illustrator_brush_field := { if input <= 1 then card.illustrator_brush else card["illustrator_brush_" + input] }
illustrator_brush_image :=
{
	shape := illustrator_brush_field(field)
	image := "/magic-modules.mse-include/information/" + shape + ".png"
	color := styling.copyright_text_color or else set.copyright_text_color
	recolor_image(image, color: color)
}
additional_credit_default := { "" }
additional_credit_brush_default := { "none" }
additional_credit_brush_field := { if input <= 1 then card.additional_credit_brush else card["additional_credit_brush_" + input] }
additional_credit_brush_image :=
{
	shape := additional_credit_brush_field(field)
	image := "/magic-modules.mse-include/information/" + shape + ".png"
	color := styling.copyright_text_color or else set.copyright_text_color
	recolor_image(image, color: color)
}
############################################################## The List
the_list_icon_default := { "none" }
the_list_icon_field := { if input <= 1 then card.the_list_icon else card["the_list_icon_" + input] }
the_list_icon_image :=
{
	shape := the_list_icon_field(field)
	suffix := if shape == "the list" and face_coordinates_map(face).width != 375 and face_coordinates_map(face).width != 523 then " 750" else ""
	image := "/magic-modules.mse-include/information/" + shape + suffix + ".png"
	color := styling.copyright_text_color or else set.copyright_text_color
	recolor_image(image, color: color)
}
the_list_dot_image :=
{
	shape := the_list_icon_field(field)
	if shape == "none" then ""
	else recolor_image("/magic-modules.mse-include/information/list_dot.png", color: card.border_color)
}

############################################################## Additional textboxes
text_filter_default :=
{
	if transfer_levels() then
	(
		if		margin_code == "lv1" then card.rule_text
		else if	margin_code == "lv2" then card.rule_text_2
		else if	margin_code == "lv3" then card.rule_text_3
		else if	margin_code == "lv4" then card.rule_text_4
		else if	margin_code == "lv5" then card.rule_text_5
		else if	margin_code == "lv6" then card.rule_text_6
		else ""
	)
	else ""
}
text_style_field := { if input <= 1 then card_style.text else card_style["text_" + input] }

############################################################## Saga/Class reminder
chapter_text_filter_default :=
{
	if		margin_code == "chapter_text" then (if not a_saga() then "" else if card.rule_text != "" then card.rule_text else "<i-auto>(" + saga_reminder() + ")</i-auto>")
	else if	margin_code == "chapter_text2" then (if not b_saga() then "" else "<i-auto>(" + saga_reminderb() + ")</i-auto>")
	else ""
}
############################################################## Leveler textboxes
level_filter_default := { "" }
level_filter := { input }

#### Correct the CARDNAME atom for levelers
card_name_for_level := {
	tag :=	name_tag_for_level()
	if (set.CARDNAME_replacement == "card's type" xor reverse)
		then (
			ty := to_lower(cardname_type(card["type"+tag]))
			if ty == "" then "this"
			else "this " + ty
		)
	else if set.CARDNAME_replacement == "card's alias" and card["alias"+tag] != ""
		then card["alias"+tag]
	else card["name"+tag]
}@(reverse:false)
card_name_for_face := {
	tag := if input == 1 then "" else "_" + input
	if (set.CARDNAME_replacement == "card's type" xor reverse)
		then (
			ty := to_lower(cardname_type(card["type"+tag]))
			if ty == "" then "this"
			else "this " + ty
		)
	else if set.CARDNAME_replacement == "card's alias" and card["alias"+tag] != ""
		then card["alias"+tag]
	else card["name"+tag]
}@(reverse:false)
cardname_type := {
	if is_creature(input)
		then lang_setting("creature")
	else if is_land(input)
		then lang_setting("land")
	else if is_spell(input)
		then lang_setting("spell")
	else if is_artifact(input)
		then lang_setting("artifact")
	else if is_planeswalker(input)
		then lang_setting("planeswalker")
	else if is_enchantment(input)
		then lang_setting("enchantment")
	else if is_battle(input)
		then lang_setting("battle")
	else if is_plane(input)
		then lang_setting("plane")
	else ""
	
}
reverse_name_for := {
	lv := "1"
	face := ""
	if contains(margin_code, match:"lv") then
		lv := filter_text(margin_code, match:"[0-9]+")
	else face := filter_text(margin_code, match:"[0-9]+")
	
	card_name := if face != "" then card_name_for_face(face, reverse:true)
					else card_name_for_level(lv, reverse:true)
	
	if card_name == "" then "CARDNAME" else strip_card_codes(card_name, atom:true)
}
#### This can be overwritten for more complicated levelers
#### Dungeons for example will overwrite with just {""}
name_tag_for_level := {
	if input < 5
		then ""
	else if input < 9
		then "_2"
	else if input < 13
		then "_3"
	else if input < 17
		then "_4"
	else ""
}

############################################################## Border
border_color_default := { set.border_color }

corners_default := { set.corner_shape }
corners_field := { if input <= 1 then card.corners else card["corners_" + input] }
corners_image :=
{
	shape := corners_field(field)
	color := if shape == "none" then card.border_color else rgb(255,255,255)
	if shape == "invisible" 
		then "/magic-modules.mse-include/corners/invisible.png"
	else recolor_image("/magic-modules.mse-include/corners/color.png", color: color)
}
corners_mask :=
{
	map := face_coordinates_map(face)
	if map.width == 0 or map.height == 0 then "" else (
		dimensions := map.width + "x" + map.height
		dimensions := corners_possible_dimensions[dimensions] or else (if map.height > map.width then "1046x750" else "750x1046")
		shape := corners_field(field)
		shape := if shape == "none" or shape == "invisible" or shape == "" then "rounded" else shape
		"/magic-modules.mse-include/corners/" + dimensions + " " + shape + ".png"
	)
}
corners_possible_dimensions :=
[
	"375x523":	"375x523"
	"523x375":	"523x375"
	"800x559":  "800x559"
	"646x902":	"646x902"
	"902x646":	"902x646"
	"752x1049":	"752x1049"
	"744x1039":	"744x1039"
	"1039x744":	"1039x744"
	"750x1046":	"750x1046"
	"1046x750":	"1046x750"
	"1500x1046": "1500x1046"
]

corners_disabled_1 := { false }
corners_disabled_2 := { false }
corners_disabled_3 := { false }

############################################################## Punchout counters
counter_default := { "+1/+1" }
counter_field := { if input <= 1 then card.counter else card["counter_" + input] }
counter_image :=
{
	shape := replace(counter_field(field), match: "/", replace: "")
	if shape == "custom" then
	(
		path :=	styling["symbol_" + field + "_custom_image_location"]
				or else styling["counter_symbol_" + field + "_custom_image_location"]
				or else ""
		if contains(path, match: ".png")
		then "/magic-modules.mse-include/counters/" + path
		else "/magic-modules.mse-include/counters/none.png"
	)
	else if shape == "none" then "/magic-modules.mse-include/counters/none.png"
	else
	(
		color :=	styling.symbol_color
					or else styling.counter_symbol_color
					or else rgb(255,255,255)
		recolor_image("/magic-modules.mse-include/counters/" + shape + ".png", color: color)
	)
}

############################################################## Future Sight typesymbols
typesymbol_for :=
	to_text +
	{ lang_setting("remove_supertypes")(input) } +
	{ replace(match: lang_setting("supertype_separator"), replace: "") } +
	{
		if      input == lang_setting("creature")		then	"creature"
		else if input == lang_setting("sorcery")		then	"sorcery"
		else if input == lang_setting("instant")		then	"instant"
		else if input == lang_setting("artifact")		then	"artifact"
		else if input == lang_setting("enchantment")	then	"enchantment"
		else if input == lang_setting("land")			then	"land"
		else if input == lang_setting("planeswalker")	then	"planeswalker"
		else if input == lang_setting("battle")			then	"battle"
		else if input == lang_setting("emblem")			then	"non standard emblem"
		else if input == lang_setting("conspiracy")		then	"non standard conspiracy"
		else if input == lang_setting("dungeon")		then	"non standard dungeon"
		else if input == lang_setting("hero")			then	"non standard hero"
		else if input == lang_setting("phenomenon")		then	"non standard phenomenon"
		else if input == lang_setting("plane")			then	"non standard plane"
		else if input == lang_setting("scheme")			then	"non standard scheme"
		else if input == lang_setting("vanguard")		then	"non standard vanguard"
		else													"multitype"
	}
typesymbol_type := { typesymbol_for(type) }
############################################################## Transform/Lesson symbols
transform_symbol_default :=
{
	stylesheet
	if		margin_code == "transform1" then	"none"
	else if	margin_code == "transform2" then	"none"
	else										"none"
}
transform_symbol_field := { if input <= 1 then card.transformation else card["transformation_" + input] }
transform_symbol_is_mirrored :=
{
	if input <= 1
		then transform_symbol_mirrored_1()
	else if input == 2
		then transform_symbol_mirrored_2()
	else transform_symbol_mirrored_3()
}
transform_symbol_image :=
{
	map := face_coordinates_map(face)
	if map.width == 0 or map.height == 0
		then ""
	else (
		shape := transform_symbol_field(face)
		link := clean_transform_symbol_shape(shape)
		if transform_symbol_is_mirrored(face) then link := flip_transform_symbol_shape(link)
		if contains(link, match:"/default") then (
			color := sparker_card_color(card_color_field(face))
			link := replace(link, match:"/default", replace:"/"+color)
		)
		case shape of
			"none": "",
			"custom symbol one": custom_symbol_1(),
			"custom symbol two": custom_symbol_2(),
			"custom symbol three": custom_symbol_3(),
			"custom symbol four": custom_symbol_4(),
			else: "/magic-modules.mse-include/symbols/" + link + ".png";
	)
}
clean_transform_symbol_shape :=
	replace@(match: "modal front ", replace: "modalfront/") +
	replace@(match: "modal back ", replace: "modalback/") +
	replace@(match: "sparker [(]colored[)] ", replace: "sparker/") +
	replace@(match: "extra |non standard ", replace: "")
flip_transform_symbol_shape :=
	replace@(match: "modalfront/", replace: "modalfrontflipped/") +
	replace@(match: "modalback/", replace: "modalbackflipped/")

#### General form
transform_symbol_left :=
{
	map := face_coordinates_map(face)
	mirrored := transform_symbol_is_mirrored(1)
	if mirrored then offset := -offset
	if map.width > map.height then
	(
		if mirrored then	map.left + 455 * map.width/523 + offset
		else				map.left + 52  * map.width/523 + offset
	)
	else
	(
		if mirrored then	map.left + 319 * map.width/375 + offset
		else				map.left + 13  * map.width/375 + offset
	)
}
transform_symbol_top :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then
			map.top + 11 * map.height/375 + offset
	else	map.top + 19 * map.height/523 + offset
}
transform_symbol_width :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then
			43 * map.width/523 + offset
	else	43 * map.width/375 + offset
}
transform_symbol_height :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then
			43 * map.height/375 + offset
	else	43 * map.height/523 + offset
}

#### Specific faces
transform_symbol_face_1 := { 1 }
transform_symbol_disabled_1 := { false }
transform_symbol_mirrored_1 := { false }
transform_symbol_offset_top_1 := { 0 }
transform_symbol_offset_left_1 := { 0 }
transform_symbol_offset_width_1 := { 0 }
transform_symbol_offset_height_1 := { 0 }
transform_symbol_left_1 :=   { transform_symbol_left(face:transform_symbol_face_1(),    offset:transform_symbol_offset_left_1())   }
transform_symbol_top_1 :=    { transform_symbol_top(face:transform_symbol_face_1(),     offset:transform_symbol_offset_top_1())    }
transform_symbol_width_1 :=  { transform_symbol_width(face:transform_symbol_face_1(),   offset:transform_symbol_offset_width_1())  }
transform_symbol_height_1 := { transform_symbol_height(face:transform_symbol_face_1(),  offset:transform_symbol_offset_height_1()) }

transform_symbol_face_2 := { 2 }
transform_symbol_disabled_2 := { false }
transform_symbol_mirrored_2 := { false }
transform_symbol_offset_top_2 := { 0 }
transform_symbol_offset_left_2 := { 0 }
transform_symbol_offset_width_2 := { 0 }
transform_symbol_offset_height_2 := { 0 }
transform_symbol_left_2 :=   { transform_symbol_left(face:transform_symbol_face_2(),    offset:transform_symbol_offset_left_2())   }
transform_symbol_top_2 :=    { transform_symbol_top(face:transform_symbol_face_2(),     offset:transform_symbol_offset_top_2())    }
transform_symbol_width_2 :=  { transform_symbol_width(face:transform_symbol_face_2(),   offset:transform_symbol_offset_width_2())  }
transform_symbol_height_2 := { transform_symbol_height(face:transform_symbol_face_2(),  offset:transform_symbol_offset_height_2()) }

transform_symbol_face_3 := { 3 }
transform_symbol_disabled_3 := { false }
transform_symbol_mirrored_3 := { false }
transform_symbol_offset_top_3 := { 0 }
transform_symbol_offset_left_3 := { 0 }
transform_symbol_offset_width_3 := { 0 }
transform_symbol_offset_height_3 := { 0 }
transform_symbol_left_3 :=   { transform_symbol_left(face:transform_symbol_face_3(),    offset:transform_symbol_offset_left_3())   }
transform_symbol_top_3 :=    { transform_symbol_top(face:transform_symbol_face_3(),     offset:transform_symbol_offset_top_3())    }
transform_symbol_width_3 :=  { transform_symbol_width(face:transform_symbol_face_3(),   offset:transform_symbol_offset_width_3())  }
transform_symbol_height_3 := { transform_symbol_height(face:transform_symbol_face_3(),  offset:transform_symbol_offset_height_3()) }

############################################################## Tombstone/Alchemy symbols
card_symbol_default := { "" }
card_symbol_field := { if input <= 1 then card.card_symbol else card["card_symbol_" + input] }
card_symbol_image := { 
	map := face_coordinates_map(face)
	shape := card_symbol_field(face)
	if shape == "none" or map.width == 0 or map.height == 0
		then ""
	else "/magic-modules.mse-include/card-symbols/" + shape + ".png"
}

card_symbol_left :=
{
	map := face_coordinates_map(face)
	default := 8 + (if card_symbol_field(face) != "none" then 18 else 0)
	if map.width > map.height then map.left + default * map.width/523 + offset
	else                           map.left + default * map.width/375 + offset
}
card_symbol_top :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then	map.top + 21 * map.height/375 + offset
	else					        map.top + 29 * map.height/523 + offset
}
card_symbol_width :=
{
	map := face_coordinates_map(face)
	default := if card_symbol_field(face) == "none" then 9 else 23
	if map.width > map.height then	default * map.width/523 + offset
	else					        default * map.width/375 + offset
}
card_symbol_height :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then	21 * map.height/375 + offset
	else					        21 * map.height/523 + offset
}

card_symbol_face_1 := { 1 }
card_symbol_disabled_1 := { false }
card_symbol_offset_top_1 := { 0 }
card_symbol_offset_left_1 := { 0 }
card_symbol_offset_width_1 := { 0 }
card_symbol_offset_height_1 := { 0 }
card_symbol_left_1 :=   { card_symbol_left(  face:card_symbol_face_1(), offset:card_symbol_offset_left_1())   }
card_symbol_top_1 :=    { card_symbol_top(   face:card_symbol_face_1(), offset:card_symbol_offset_top_1())    }
card_symbol_width_1 :=  { card_symbol_width( face:card_symbol_face_1(), offset:card_symbol_offset_width_1())  }
card_symbol_height_1 := { card_symbol_height(face:card_symbol_face_1(), offset:card_symbol_offset_height_1()) }

card_symbol_face_2 := { 2 }
card_symbol_disabled_2 := { false }
card_symbol_offset_top_2 := { 0 }
card_symbol_offset_left_2 := { 0 }
card_symbol_offset_width_2 := { 0 }
card_symbol_offset_height_2 := { 0 }
card_symbol_left_2 :=   { card_symbol_left(  face:card_symbol_face_2(), offset:card_symbol_offset_left_2())   }
card_symbol_top_2 :=    { card_symbol_top(   face:card_symbol_face_2(), offset:card_symbol_offset_top_2())    }
card_symbol_width_2 :=  { card_symbol_width( face:card_symbol_face_2(), offset:card_symbol_offset_width_2())  }
card_symbol_height_2 := { card_symbol_height(face:card_symbol_face_2(), offset:card_symbol_offset_height_2()) }

card_symbol_face_3 := { 3 }
card_symbol_disabled_3 := { false }
card_symbol_offset_top_3 := { 0 }
card_symbol_offset_left_3 := { 0 }
card_symbol_offset_width_3 := { 0 }
card_symbol_offset_height_3 := { 0 }
card_symbol_left_3 :=   { card_symbol_left(  face:card_symbol_face_3(), offset:card_symbol_offset_left_3())   }
card_symbol_top_3 :=    { card_symbol_top(   face:card_symbol_face_3(), offset:card_symbol_offset_top_3())    }
card_symbol_width_3 :=  { card_symbol_width( face:card_symbol_face_3(), offset:card_symbol_offset_width_3())  }
card_symbol_height_3 := { card_symbol_height(face:card_symbol_face_3(), offset:card_symbol_offset_height_3()) }

############################################################## Loyalty costs
#### frames can conditionally use the loyalty module
loyalty_has_abilities_1 := { mainframe_walker() }
loyalty_has_abilities_2 := { mainframe_walkerb() }
loyalty_has_abilities_3 := { mainframe_walkerc() }
use_tall_walker_frame_1 :=
{
	count := loyalty_abilities_count(instance: 1, active:true)
	method := styling.use_tall_frame or else "default"
	if method == "default" and count >= 4
		then true
	else if method == "always"
		then true
	else false
}
use_tall_walker_frame_2 :=
{
	count := loyalty_abilities_count(instance: 2, active:true)
	method := styling.use_tall_frame_2 or else "default"
	if method == "default" and count >= 4
		then true
	else if method == "always"
		then true
	else false
}
loyalty_clean_margin_code := replace@(match: "loy(cost)?", replace: "")
loyalty_cost_field :=
{
	input := loyalty_clean_margin_code(input)
	card["loyalty_cost_" + input]
}
loyalty_cost_box_field :=
{
	input := loyalty_clean_margin_code(input)
	card["loyalty_cost_box_" + input]
}
loyalty_cost_box_default :=
{
	cost := loyalty_cost_field(margin_code)
	if cost == "" then "none"
	else if	contains(cost, match: "+") then	"+, shadow"
	else if	contains(cost, match: "-") then	"-, shadow"
	else									"0, shadow"
}
loyalty_boxes_image_folder := { "/magic-modules.mse-include/loyalty/" }
loyalty_cost_box_image :=
{
	shape := remove_comma(loyalty_cost_box_field(input + (instance-1)*8))
	if contains(shape, match: "none") then ""
	else (
	folder := loyalty_boxes_image_folder()
	if not ends_dash(folder) then folder := folder + "/"
	name := "loyalty cost " + shape + ".png"
	path := folder + name
	if exists_in_package(path) then path else "/magic-modules.mse-include/loyalty/" + name)
}

loyalty_field :=
{
	input := loyalty_clean_margin_code(input)
	if input <= 1 then card.loyalty else card["loyalty_" + input]
}
loyalty_box_field :=
{
	input := loyalty_clean_margin_code(input)
	if input <= 1 then card.loyalty_box else card["loyalty_box_" + input]
}
loyalty_box_default :=
{
	margin_code := loyalty_clean_margin_code(margin_code)
	loyalty := loyalty_field(margin_code)
	if loyalty == "" then "none" else (
	type := if margin_code <= 1 then card.super_type else card["super_type_" + margin_code]
	if is_battle(type) or contains(card_shape(), match: "battle") then "defense"
	else "loyalty")
}
loyalty_box_image :=
{
	shape := remove_comma(loyalty_box_field(instance))
	if has_none(shape) then ""
	else (
	folder := loyalty_boxes_image_folder()
	if not ends_dash(folder) then folder := folder + "/"
	name := shape + ".png"
	path := folder + name
	if exists_in_package(path) then path else "/magic-modules.mse-include/loyalty/" + name)
}

loyalty_face_1 := { 1 }
loyalty_text_field_1 := { 1 }
loyalty_stamp_field_1 := { 1 }

loyalty_offset_top_1 := { 0 }
loyalty_offset_left_1 := { 0 }
loyalty_offset_width_1 := { 0 }
loyalty_offset_height_1 := { 0 }

loyalty_cost_offset_top_1 := { 0 }
loyalty_cost_offset_left_1 := { 0 }
loyalty_cost_offset_width_1 := { 0 }
loyalty_cost_offset_height_1 := { 0 }

loyalty_cost_offset_text_margin_1 := { 0 }

loyalty_textbox_mask_1 :=
{
	"/magic-modules.mse-include/loyalty/default_textbox"
	+ (if use_tall_walker_frame_1() then "_tall" else "")
	+ "_mask.png"
}

loyalty_face_2 := { 2 }
loyalty_text_field_2 := { 2 }
loyalty_stamp_field_2 := { 2 }

loyalty_offset_top_2 := { 0 }
loyalty_offset_left_2 := { 0 }
loyalty_offset_width_2 := { 0 }
loyalty_offset_height_2 := { 0 }

loyalty_cost_offset_top_2 := { 0 }
loyalty_cost_offset_left_2 := { 0 }
loyalty_cost_offset_width_2 := { 0 }
loyalty_cost_offset_height_2 := { 0 }

loyalty_cost_offset_text_margin_2 := { 0 }

loyalty_textbox_mask_2 :=
{
	"/magic-modules.mse-include/loyalty/default_textbox"
	+ (if use_tall_walker_frame_2() then "_tall" else "")
	+ "_mask.png"
}

loyalty_face_3 := { 3 }
loyalty_text_field_3 := { 3 }
loyalty_stamp_field_3 := { 3 }

loyalty_offset_top_3 := { 0 }
loyalty_offset_left_3 := { 0 }
loyalty_offset_width_3 := { 0 }
loyalty_offset_height_3 := { 0 }

loyalty_cost_offset_top_3 := { 0 }
loyalty_cost_offset_left_3 := { 0 }
loyalty_cost_offset_width_3 := { 0 }
loyalty_cost_offset_height_3 := { 0 }

loyalty_cost_offset_text_margin_3 := { 0 }

loyalty_textbox_mask_3 :=
{
	if is_stamped(field: loyalty_stamp_field_3())
	then "/magic-modules.mse-include/loyalty/default_textbox_stamp_mask.png"
	else "/magic-modules.mse-include/loyalty/default_textbox_mask.png"
}

loyalty_face := { if instance <= 1 then loyalty_face_1() else if instance == 2 then loyalty_face_2() else loyalty_face_3() }
loyalty_text_field := { if instance <= 1 then loyalty_text_field_1() else if instance == 2 then loyalty_text_field_2() else loyalty_text_field_3() }
loyalty_stamp_field := { if instance <= 1 then loyalty_stamp_field_1() else if instance == 2 then loyalty_stamp_field_2() else loyalty_stamp_field_3() }

loyalty_offset_top := { if instance <= 1 then loyalty_offset_top_1() else if instance == 2 then loyalty_offset_top_2() else loyalty_offset_top_3() }
loyalty_offset_left := { if instance <= 1 then loyalty_offset_left_1() else if instance == 2 then loyalty_offset_left_2() else loyalty_offset_left_3() }
loyalty_offset_width := { if instance <= 1 then loyalty_offset_width_1() else if instance == 2 then loyalty_offset_width_2() else loyalty_offset_width_3() }
loyalty_offset_height := { if instance <= 1 then loyalty_offset_height_1() else if instance == 2 then loyalty_offset_height_2() else loyalty_offset_height_3() }

loyalty_cost_offset_top := { if instance <= 1 then loyalty_cost_offset_top_1() else if instance == 2 then loyalty_cost_offset_top_2() else loyalty_cost_offset_top_3() }
loyalty_cost_offset_left := { if instance <= 1 then loyalty_cost_offset_left_1() else if instance == 2 then loyalty_cost_offset_left_2() else loyalty_cost_offset_left_3() }
loyalty_cost_offset_width := { if instance <= 1 then loyalty_cost_offset_width_1() else if instance == 2 then loyalty_cost_offset_width_2() else loyalty_cost_offset_width_3() }
loyalty_cost_offset_height := { if instance <= 1 then loyalty_cost_offset_height_1() else if instance == 2 then loyalty_cost_offset_height_2() else loyalty_cost_offset_height_3() }

loyalty_cost_offset_text_margin := { if instance <= 1 then loyalty_cost_offset_text_margin_1() else if instance == 2 then loyalty_cost_offset_text_margin_2() else loyalty_cost_offset_text_margin_3() }

loyalty_textbox_mask := { if instance <= 1 then loyalty_textbox_mask_1() else if instance == 2 then loyalty_textbox_mask_2() else loyalty_textbox_mask_3() }

#### All these functions are implicitly passed and passing the 'instance' argument:
a_left :=						{ face := loyalty_face(); face_coordinates_map(face).left }
a_top :=						{ face := loyalty_face(); face_coordinates_map(face).top }
a_bottom :=						{ face := loyalty_face(); face_coordinates_map(face).top + face_coordinates_map(face).height }
a_width :=						{ face := loyalty_face(); face_coordinates_map(face).width }
a_height :=						{ face := loyalty_face(); face_coordinates_map(face).height }
r_width :=						{ face := loyalty_face(); face_coordinates_map(face).width/375 }
r_height :=						{ face := loyalty_face(); face_coordinates_map(face).height/523 }

to_744_width :=					{ input/a_width()*744 }
to_744_height :=				{ input/a_height()*1039 }

loyalty_left :=					{ round_near((if contains(loyalty_box_field(instance), match: "defense") then 323 else 313) * r_width() + a_left() + loyalty_offset_left() - loyalty_offset_width()) }
loyalty_top :=					{ round_near(472 * r_height() + a_top() + loyalty_offset_top() - loyalty_offset_height()) }
loyalty_width :=				{ (if contains(loyalty_box_field(instance), match: "defense") then 20 else 40) * r_width() + 2*loyalty_offset_width() }
loyalty_height :=				{ 21 * r_height() + 2*loyalty_offset_height() }
loyalty_font_size :=			{ (if contains(loyalty_box_field(instance), match: "defense") then 15 else 17) * (21 * r_height() + 0.8*loyalty_offset_height())/21 }

loyalty_box_left :=				{ 301 * r_width() + a_left() + loyalty_offset_left() - loyalty_offset_width() }
loyalty_box_top :=				{ 457 * r_height() + a_top() + loyalty_offset_top() - loyalty_offset_height() }
loyalty_box_width :=			{ 64 * r_width() + 2*loyalty_offset_width() }
loyalty_box_height :=			{ 52.5 * r_height() + 2*loyalty_offset_height() }

loyalty_cost_left :=			{ round_near(loyalty_ability_left() - 24 * r_width() + loyalty_cost_offset_left() - loyalty_cost_offset_width()) }
loyalty_cost_top :=				{ round_near(loyalty_ability_center(input) - loyalty_cost_r_height()/2 + loyalty_cost_r_correction(input) + loyalty_cost_move(input) + loyalty_cost_offset_top() - loyalty_cost_offset_height()) }
loyalty_cost_width :=			{ loyalty_cost_r_width() + 2*loyalty_cost_offset_width() }
loyalty_cost_height :=			{ if loyalty_abilities_count() >= input then loyalty_cost_r_height() + 2*loyalty_cost_offset_height() else 0 }
loyalty_cost_r_width :=			{ 24 * r_width() }
loyalty_cost_r_height :=		{ 20 * r_height() }
loyalty_cost_r_correction :=
{
	box := input + 8*(instance-1)
	cost := card["loyalty_cost_box_" + box]
	if		contains(cost, match: "+") or contains(cost, match: "anti ult") then	-1 * r_height()
	else if	contains(cost, match: "-") or contains(cost, match: "ult")		then	-5 * r_height()
	else																			-3 * r_height()
}
loyalty_cost_font_size :=		{ 13 * (loyalty_cost_r_height() + 0.8*loyalty_cost_offset_height())/20 }

loyalty_cost_box_left :=		{ loyalty_ability_left() - 36 * r_width() + loyalty_cost_offset_left() - loyalty_cost_offset_width() }
loyalty_cost_box_top :=			{ round_near(loyalty_ability_center(input) - loyalty_cost_box_r_height()/2 + loyalty_cost_move(input) + loyalty_cost_offset_top() - loyalty_cost_offset_height()) }
loyalty_cost_box_width :=		{ loyalty_cost_box_r_width() + 2*loyalty_cost_offset_width() }
loyalty_cost_box_height :=		{ if loyalty_abilities_count() >= input then loyalty_cost_box_r_height() + 2*loyalty_cost_offset_height() else 0 }
loyalty_cost_box_r_width :=		{ 47 * r_width() }
loyalty_cost_box_r_height :=	{ 36 * r_height() }

loyalty_colon_left :=			{ round_near(loyalty_ability_left() + 9 * r_width() + loyalty_cost_offset_left() + loyalty_cost_offset_width()) }
loyalty_colon_top :=			{ round_near(loyalty_ability_center(input) - loyalty_colon_r_height()/2 + loyalty_colon_r_correction(input) + loyalty_cost_move(input) + loyalty_cost_offset_top() - loyalty_cost_offset_height()) }
loyalty_colon_width :=			{ loyalty_colon_r_width() }
loyalty_colon_height :=			{ loyalty_colon_r_height() }
loyalty_colon_r_width :=		{ 5 * r_width() }
loyalty_colon_r_height :=		{ 21 * r_height() }
loyalty_colon_r_correction :=	{ -3 * r_height() }
loyalty_colon_font_size :=		{ 13 * (loyalty_colon_r_height() + 2*loyalty_cost_offset_height())/21 }

loyalty_stripe_separator_top :=		{ (loyalty_ability_bottom(input) + loyalty_ability_top(input+1) - loyalty_stripe_separator_height())/2 + loyalty_separator_move(input) }
loyalty_stripe_separator_height :=	{ 8.06 * r_height() }

loyalty_cost_move :=
{
	styling_field := if instance <= 1 then (styling.move_loyalty_costs or else "") else (styling["move_loyalty_costs_" + instance] or else "")
	text := pull_comma_array(styling_field, cell:input-1, end:0, default:0)
	if text == "-" then 0 else clamp(text, minimum: -300, maximum: 300)
}
loyalty_separator_move :=
{
	styling_field := if instance <= 1 then (styling.move_separators or else "") else (styling["move_separators_" + instance] or else "")
	text := pull_comma_array(styling_field, cell:input-1, end:0, default:0)
	if text == "-" then 0 else clamp(text, minimum: -300, maximum: 300)
}

loyalty_level_is_active :=
{
	number := to_int(replace(input, match: "lv", replace: "")) or else 999
	if number > 24 then false else (
		instance := if number < 9 then 1 else if number < 17 then 2 else 3
		mod_val := number mod 8
		if mod_val == 0 then mod_val := 8
		loyalty_abilities_count(active:true) >= mod_val
	)
}
loyalty_abilities_count :=
{
	styling_field := if instance <= 1 then (styling.number_of_textboxes or else "0") else (styling["number_of_textboxes_" + instance] or else "0")
	if styling_field == "automatic" then (
		counter := 1
		bumper := 8 * (instance-1)
		for x from 1 to 8 do (
			tf := card["level_" + (x+bumper) + "_text"]
			if tf != "" and tf != zwsp then counter := x;
		)
		tf := card["level_" + counter + "_text"]
		if active then counter := counter - ( if tf == "" or tf == zwsp then 1 else 0)
		else counter := counter + 1
		styling_field := counter;
	)
	to_int(styling_field) or else digital_map[styling_field]
}@(active:false) 

loyalty_ability_left :=
{
	style_field := text_style_field(loyalty_text_field())
	if style_field.left or else 0 > 0
	then style_field.left
	else stylesheet.card_width * 1.2
}
loyalty_ability_top :=
{
	style_field := text_style_field(loyalty_text_field())
	if style_field.layout.blocks[input-1].bottom or else 0 > 0
	then style_field.top + style_field.layout.blocks[input-1].top
	else stylesheet.card_height * 1.2
}
loyalty_ability_center :=
{
	style_field := text_style_field(loyalty_text_field())
	if style_field.layout.blocks[input-1].bottom or else 0 > 0
	then style_field.top + style_field.layout.blocks[input-1].middle
	else stylesheet.card_height * 1.2
}
loyalty_ability_bottom :=
{
	style_field := text_style_field(loyalty_text_field())
	if style_field.layout.blocks[input-1].bottom or else 0 > 0
	then style_field.top + style_field.layout.blocks[input-1].bottom
	else stylesheet.card_height * 1.2
}

loyalty_stripe_separator_mask :=
{
	mask := loyalty_textbox_mask()
	mask_path := to_string(mask) or else ""
	is_default :=		mask_path == "/magic-modules.mse-include/loyalty/default_textbox_stamp_mask.png"
					or	mask_path == "/magic-modules.mse-include/loyalty/default_textbox_mask.png"
	if is_default then
	(
		crop_safe(
			mask,
			offset_x: 0,
			offset_y: to_744_height(loyalty_stripe_separator_top(input) - a_top()),
			width: 744,
			height: to_744_height(loyalty_stripe_separator_height()),
			max_x: 744,
			max_y: 1039
		)
	)
	else
	(
		crop_safe(
			mask,
			offset_x: 0,
			offset_y: loyalty_stripe_separator_top(input) - a_top(),
			width: a_width(),
			height: loyalty_stripe_separator_height(),
			max_x: a_width(),
			max_y: a_height()
		)
	)
}
loyalty_stripe_mask :=
{
	mask := loyalty_textbox_mask()
	mask_path := to_string(mask) or else ""
	is_default :=		mask_path == "/magic-modules.mse-include/loyalty/default_textbox_stamp_mask.png"
					or	mask_path == "/magic-modules.mse-include/loyalty/default_textbox_mask.png"
	if is_default then
	(
		top :=		if input > 1					then loyalty_stripe_separator_top(2*input-2) + loyalty_stripe_separator_height()	else a_top()
		height := (if loyalty_abilities_count(active:true) >= 2*input	then loyalty_stripe_separator_top(2*input-1)										else a_bottom()) - top
		top := to_744_height(top - a_top())
		height := to_744_height(height)
		crop_safe(
			mask,
			offset_x: 0,
			offset_y: top,
			width: 744,
			height: height,
			max_x: 744,
			max_y: 1039
		)
	)
	else
	(
		top :=		if input > 1					then loyalty_stripe_separator_top(2*input-2) + loyalty_stripe_separator_height()	else a_top()
		height := (if loyalty_abilities_count(active:true) >= 2*input	then loyalty_stripe_separator_top(2*input-1)										else a_bottom()) - top
		top := top - a_top()
		crop_safe(
			mask,
			offset_x: 0,
			offset_y: top,
			width: a_width(),
			height: height,
			max_x: a_width(),
			max_y: a_height()
		)
	)
}
loyalty_stripe_alpha_default := { "40" }
loyalty_stripe_separator_image :=
{
	color := if instance <= 1 then (styling.stripes_color or else rgb(255,255,255)) else (styling["stripes_color_" + instance] or else rgb(255,255,255))
	alpha := if instance <= 1 then (styling.stripes_opacity_percentage or else loyalty_stripe_alpha_default()) else (styling["stripes_opacity_percentage_" + instance] or else loyalty_stripe_alpha_default())
	set_alpha(
		recolor_image(
			"/magic-modules.mse-include/loyalty/stripe_" + (if (input mod 2) == 0 then "top" else "bottom") + ".png",
			color: color
		),
		alpha: get_alpha_percentage(
			alpha,
			default: loyalty_stripe_alpha_default()
		)
	)
}
loyalty_stripe_image :=
{
	color := if instance <= 1 then (styling.stripes_color or else rgb(255,255,255)) else (styling["stripes_color_" + instance] or else rgb(255,255,255))
	alpha := if instance <= 1 then (styling.stripes_opacity_percentage or else loyalty_stripe_alpha_default()) else (styling["stripes_opacity_percentage_" + instance] or else loyalty_stripe_alpha_default())
	set_alpha(
		recolor_image(
			"/magic-modules.mse-include/loyalty/color.png",
			color: color
		),
		alpha: get_alpha_percentage(
			alpha,
			default: loyalty_stripe_alpha_default()
		)
	)
}
loyalty_textbox_background_alpha_default := { "70" }
loyalty_textbox_background_image :=
{
	color := if instance <= 1 then (styling.textbox_color or else rgb(255,255,255)) else (styling["textbox_color_" + instance] or else rgb(255,255,255))
	alpha := if instance <= 1 then (styling.textbox_opacity_percentage or else loyalty_textbox_background_alpha_default()) else (styling["textbox_opacity_percentage_" + instance] or else loyalty_textbox_background_alpha_default())
	set_alpha(
		recolor_image(
			"/magic-modules.mse-include/loyalty/color.png",
			color: color
		),
		alpha: get_alpha_percentage(
			alpha,
			default: loyalty_textbox_background_alpha_default()
		)
	)
}

############################################################## Separators
separator_enable_level := { false }
separator_default := { 
	if set.use_flavor_bar then (
		if set.default_flavor_bar == "thin bar"
			then "grey bar"
		else if set.default_flavor_bar == "thick bar"
			then "flavor bar"
		else set.default_flavor_bar
	)
	else "none"
}

flavor_bar_left := { face_coordinates_map(input).left }
flavor_bar_top :=
{
	style := if input <= 1 then card_style.text else card_style["text_" + input]
	rule := if input <= 1 then card.rule_text else card["rule_text_" + input]
	flavor := if input <= 1 then card.flavor_text else card["flavor_text_" + input]
	disabled := if input <= 1 then flavor_bar_disabled_1() else if input == 2 then flavor_bar_disabled_2() else flavor_bar_disabled_3()
	uninitialized := (style.layout.blocks[1].bottom or else 0) <= 0
	if		disabled
		or	rule == ""
		or	remove_tags(flavor) == ""
	then stylesheet.card_height + 1
	else if uninitialized
	then (if input <= 1 then old_bar_equation() else if input == 2 then old_bar_equation2() else old_bar_equation3()) - flavor_bar_height(input)/2
	else style.top + (style.layout.blocks[0].bottom + style.layout.blocks[1].top)/2 - flavor_bar_height(input)/2
}
flavor_bar_width := { face_coordinates_map(input).width }
flavor_bar_height := { 24 * face_coordinates_map(input).height/1039 }

flavor_bar_disabled_1 := { false }
flavor_bar_offset_top_1 := { 0 }
flavor_bar_offset_left_1 := { 0 }
flavor_bar_offset_width_1 := { 0 }
flavor_bar_offset_height_1 := { 0 }
flavor_bar_disabled_2 := { false }
flavor_bar_offset_top_2 := { 0 }
flavor_bar_offset_left_2 := { 0 }
flavor_bar_offset_width_2 := { 0 }
flavor_bar_offset_height_2 := { 0 }
flavor_bar_disabled_3 := { false }
flavor_bar_offset_top_3 := { 0 }
flavor_bar_offset_left_3 := { 0 }
flavor_bar_offset_width_3 := { 0 }
flavor_bar_offset_height_3 := { 0 }

############################################################## Watermark offsets
watermark_face_1 := { 1 }
watermark_text_field_1 := { 1 }
watermark_stamp_field_1 := { 1 }

watermark_disabled_1 := { false }
watermark_offset_top_1 := { 0 }
watermark_offset_left_1 := { 0 }
watermark_offset_width_1 := { 0 }
watermark_offset_height_1 := { 0 }
watermark_offset_stamp_1 := { 0 }

watermark_face_2 := { 2 }
watermark_text_field_2 := { 2 }
watermark_stamp_field_2 := { 2 }

watermark_disabled_2 := { false }
watermark_offset_top_2 := { 0 }
watermark_offset_left_2 := { 0 }
watermark_offset_width_2 := { 0 }
watermark_offset_height_2 := { 0 }
watermark_offset_stamp_2 := { 0 }

watermark_face_3 := { 3 }
watermark_text_field_3 := { 3 }
watermark_stamp_field_3 := { 3 }

watermark_disabled_3 := { false }
watermark_offset_top_3 := { 0 }
watermark_offset_left_3 := { 0 }
watermark_offset_width_3 := { 0 }
watermark_offset_height_3 := { 0 }
watermark_offset_stamp_3 := { 0 }

############################################################## Color indicator offsets
indicator_left :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then
			map.left + 65 * map.width/523 + offset
	else	map.left + 31 * map.width/375 + offset
}
indicator_top :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then
			map.top + 223 * map.height/375 + offset
	else	map.top + 301 * map.height/523 + offset
}
indicator_size :=
{
	map := face_coordinates_map(face)
	17 * min(map.width, map.height)/375 + offset
}
indicator_disabled_1 := { false }
indicator_offset_top_1 := { 0 }
indicator_offset_left_1 := { 0 }
indicator_offset_size_1 := { 0 }
indicator_left_1 := { indicator_left(face:typeline_face_1(), offset: indicator_offset_left_1()) }
indicator_top_1 :=  { indicator_top(face:typeline_face_1(),  offset: indicator_offset_top_1())  }
indicator_size_1 := { indicator_size(face:typeline_face_1(), offset: indicator_offset_size_1()) }

indicator_disabled_2 := { false }
indicator_offset_top_2 := { 0 }
indicator_offset_left_2 := { 0 }
indicator_offset_size_2 := { 0 }
indicator_left_2 := { indicator_left(face:typeline_face_2(), offset: indicator_offset_left_2()) }
indicator_top_2 :=  { indicator_top(face:typeline_face_2(),  offset: indicator_offset_top_2())  }
indicator_size_2 := { indicator_size(face:typeline_face_2(), offset: indicator_offset_size_2()) }

indicator_disabled_3 := { false }
indicator_offset_top_3 := { 0 }
indicator_offset_left_3 := { 0 }
indicator_offset_size_3 := { 0 }
indicator_left_3 := { indicator_left(face:typeline_face_3(), offset: indicator_offset_left_3()) }
indicator_top_3 :=  { indicator_top(face:typeline_face_3(),  offset: indicator_offset_top_3())  }
indicator_size_3 := { indicator_size(face:typeline_face_3(), offset: indicator_offset_size_3()) }

############################################################## Rarity offsets
rarity_right :=
{
	map := face_coordinates_map(face)
	user_offsets := styling.rarity_offsets or else ""
	if map.width > map.height then
				map.left + (483 * map.width/523) + offset + rarity_user_offset_left(user_offsets) + rarity_user_offset_width(user_offsets)
		else	map.left + (344 * map.width/375) + offset + rarity_user_offset_left(user_offsets) + rarity_user_offset_width(user_offsets)
}
rarity_top :=
{
	map := face_coordinates_map(face)
	user_offsets := styling.rarity_offsets or else ""
	if map.width > map.height then
				map.top + 219 * map.height/375 + offset + rarity_user_offset_top(user_offsets) - rarity_user_offset_height(user_offsets)
		else	map.top + 297 * map.height/523 + offset + rarity_user_offset_top(user_offsets) - rarity_user_offset_height(user_offsets)
}
rarity_width :=
{
	map := face_coordinates_map(face)
	user_offsets := styling.rarity_offsets or else ""
	if map.width > map.height then
				44 * map.width/523 + offset + 2*rarity_user_offset_width(user_offsets)
		else	44 * map.width/375 + offset + 2*rarity_user_offset_width(user_offsets)
}
rarity_height :=
{
	map := face_coordinates_map(face)
	user_offsets := styling.rarity_offsets or else ""
	if map.width > map.height then
				22 * map.height/375 + offset + 2*rarity_user_offset_height(user_offsets)
		else	22 * map.height/523 + offset + 2*rarity_user_offset_height(user_offsets)
}
rarity_size :=
{
	map := face_coordinates_map(face)
	user_offsets := styling.rarity_offsets or else ""
	24 * min(map.width, map.height)/375 + offset + 2*rarity_user_offset_size(user_offsets)
}

rarity_real_width := {
	map := face_coordinates_map(face)
	multi := if map.width > map.height then
				map.height/375
		else 	map.height/523
	cw := if face > 1 then card_style["rarity_" + face].content_width else card_style.rarity.content_width
	cwf := if cw > multi*44 then (if set.print_fix != "" then set.print_fix else multi*22) else if cw < multi*22 then multi*22 else cw
	if not set.shorten_types_for_rarity or cw == 0 then 0 else cwf
}

rarity_disabled_1 := { false }
rarity_offset_top_1 := { 0 }
rarity_offset_left_1 := { 0 }
rarity_offset_size_1 := { 0 }
rarity_right_1 :=   { rarity_right(face:typeline_face_1(),  offset:rarity_offset_left_1()) }
rarity_top_1 :=     { rarity_top(face:typeline_face_1(),    offset:rarity_offset_top_1())  }
rarity_height_1 :=  { rarity_height(face:typeline_face_1(), offset:rarity_offset_size_1()) }
rarity_width_1 :=   { rarity_width(face:typeline_face_1(),  offset:rarity_offset_size_1()) }
rarity_left_1 :=    { rarity_right_1() - rarity_real_width(face:typeline_face_1()) }

rarity_disabled_2 := { false }
rarity_offset_top_2 := { 0 }
rarity_offset_left_2 := { 0 }
rarity_offset_size_2 := { 0 }
rarity_right_2 :=   { rarity_right(face:typeline_face_2(),  offset:rarity_offset_left_2()) }
rarity_top_2 :=     { rarity_top(face:typeline_face_2(),    offset:rarity_offset_top_2())  }
rarity_height_2 :=  { rarity_height(face:typeline_face_2(), offset:rarity_offset_size_2()) }
rarity_width_2 :=   { rarity_width(face:typeline_face_2(),  offset:rarity_offset_size_2()) }
rarity_left_2 :=    { rarity_right_2() - rarity_real_width(face:typeline_face_2()) }

rarity_disabled_3 := { false }
rarity_offset_top_3 := { 0 }
rarity_offset_left_3 := { 0 }
rarity_offset_size_3 := { 0 }
rarity_right_3 :=   { rarity_right(face:typeline_face_3(),  offset:rarity_offset_left_3()) }
rarity_top_3 :=     { rarity_top(face:typeline_face_3(),    offset:rarity_offset_top_3())  }
rarity_height_3 :=  { rarity_height(face:typeline_face_3(), offset:rarity_offset_size_3()) }
rarity_width_3 :=   { rarity_width(face:typeline_face_3(),  offset:rarity_offset_size_3()) }
rarity_left_3 :=    { rarity_right_3() - rarity_real_width(face:typeline_face_3()) }

rarity_user_offset_left :=	 { split := split_comma(input); if length(split) > 0 and split.0 != "" and split.0 != "-" then clamp(split.0, maximum:500, minimum:-500) else 0 }
rarity_user_offset_top :=	 { split := split_comma(input); if length(split) > 1 and split.1 != "" and split.1 != "-" then clamp(split.1, maximum:500, minimum:-500) else 0 }
rarity_user_offset_width :=	 { split := split_comma(input); if length(split) > 2 and split.2 != "" and split.2 != "-" then clamp(split.2, maximum:500, minimum:-500) else 0 }
rarity_user_offset_height := { split := split_comma(input); if length(split) > 2 and split.2 != "" and split.2 != "-" then clamp(split.2, maximum:500, minimum:-500) else 0 }

############################################################## Type offsets

type_indicator_shift :=
{
	if (not identity) or disabled
	then 0
	else offset
}

type_disabled_1 := { false }
type_offset_top_1 := { 0 }
type_offset_left_1 := { 0 }
type_offset_right_1 := { 0 }
type_offset_height_1 := { 0 }
type_indicator_shift_1 := { type_indicator_shift(identity:has_identity(), offset:indicator_size_1()*1.15 + typeline_offset_height_1(), disabled:indicator_disabled_1()) }

type_disabled_2 := { false }
type_offset_top_2 := { 0 }
type_offset_left_2 := { 0 }
type_offset_right_2 := { 0 }
type_offset_height_2 := { 0 }
type_indicator_shift_2 := { type_indicator_shift(identity:has_identity_2(), offset:indicator_size_2()*1.15 + typeline_offset_height_2(), disabled:indicator_disabled_2()) }

type_disabled_3 := { false }
type_offset_top_3 := { 0 }
type_offset_left_3 := { 0 }
type_offset_right_3 := { 0 }
type_offset_height_3 := { 0 }
type_indicator_shift_3 := { type_indicator_shift(identity:has_identity_3(), offset:indicator_size_3()*1.15 + typeline_offset_height_3(), disabled:indicator_disabled_3()) }

typeline_face_1 := { 1 }

typeline_disabled_1 := { false }
typeline_offset_top_1 := { 0 }
typeline_offset_left_1 := { 0 }
typeline_offset_width_1 := { 0 }
typeline_offset_height_1 := { 0 }

typeline_face_2 := { 2 }

typeline_disabled_2 := { false }
typeline_offset_top_2 := { 0 }
typeline_offset_left_2 := { 0 }
typeline_offset_width_2 := { 0 }
typeline_offset_height_2 := { 0 }

typeline_face_3 := { 3 }

typeline_disabled_3 := { false }
typeline_offset_top_3 := { 0 }
typeline_offset_left_3 := { 0 }
typeline_offset_width_3 := { 0 }
typeline_offset_height_3 := { 0 }

############################################################## Casting cost offsets
casting_cost_right :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then
			map.left + 485 * map.width/523 + offset
	else	map.left + 346 * map.width/375 + offset
}
casting_cost_top :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then
			map.top + 19 * map.height/375 + offset
	else	map.top + 27 * map.height/523 + offset
}
casting_cost_width :=
{
	map := face_coordinates_map(face)
	scale := min(map.width, map.height)/375
	minimum := 30 * scale
	buffer := 5 * scale
	max(minimum, card_style.casting_cost.content_width) + buffer + offset
}
casting_cost_height :=
{
	map := face_coordinates_map(face)
	26 * min(map.width, map.height)/375 + offset
}

casting_cost_transform_symbol_shift :=
{
	if transform_symbol_field(face) == "none" or disabled
		then 0
	else (
		map := face_coordinates_map(face)
		29 * -(min(map.width, map.height)/375) - offset
	)
}

casting_cost_disabled_1 := { false }
casting_cost_offset_top_1 := { 0 }
casting_cost_offset_left_1 := { 0 }
casting_cost_offset_width_1 := { 0 }
casting_cost_offset_height_1 := { 0 }
casting_cost_right_1 :=  { casting_cost_right(face:nameline_face_1(),  offset:casting_cost_offset_left_1())   }
casting_cost_top_1 :=    { casting_cost_top(face:nameline_face_1(),    offset:casting_cost_offset_top_1())    }
casting_cost_width_1 :=  { casting_cost_width(face:nameline_face_1(),  offset:casting_cost_offset_width_1())  }
casting_cost_height_1 := { casting_cost_height(face:nameline_face_1(), offset:casting_cost_offset_height_1()) }
casting_cost_transform_symbol_shift_1 := { casting_cost_transform_symbol_shift(face:nameline_face_1(), offset:name_transform_symbol_offset_left_1() + nameline_offset_height_1(), disabled:transform_symbol_disabled_1() or (not transform_symbol_mirrored_1())) }

casting_cost_disabled_2 := { false }
casting_cost_offset_top_2 := { 0 }
casting_cost_offset_left_2 := { 0 }
casting_cost_offset_width_2 := { 0 }
casting_cost_offset_height_2 := { 0 }
casting_cost_right_2 :=  { casting_cost_right(face:nameline_face_2(),  offset:casting_cost_offset_left_2())   }
casting_cost_top_2 :=    { casting_cost_top(face:nameline_face_2(),    offset:casting_cost_offset_top_2())    }
casting_cost_width_2 :=  { casting_cost_width(face:nameline_face_2(),  offset:casting_cost_offset_width_2())  }
casting_cost_height_2 := { casting_cost_height(face:nameline_face_2(), offset:casting_cost_offset_height_2()) }
casting_cost_transform_symbol_shift_2 := { casting_cost_transform_symbol_shift(face:nameline_face_2(), offset:name_transform_symbol_offset_left_2() + nameline_offset_height_2(), disabled:transform_symbol_disabled_2() or (not transform_symbol_mirrored_2())) }

casting_cost_disabled_3 := { false }
casting_cost_offset_top_3 := { 0 }
casting_cost_offset_left_3 := { 0 }
casting_cost_offset_width_3 := { 0 }
casting_cost_offset_height_3 := { 0 }
casting_cost_right_3 :=  { casting_cost_right(face:nameline_face_3(),  offset:casting_cost_offset_left_3())   }
casting_cost_top_3 :=    { casting_cost_top(face:nameline_face_3(),    offset:casting_cost_offset_top_3())    }
casting_cost_width_3 :=  { casting_cost_width(face:nameline_face_3(),  offset:casting_cost_offset_width_3())  }
casting_cost_height_3 := { casting_cost_height(face:nameline_face_3(), offset:casting_cost_offset_height_3()) }
casting_cost_transform_symbol_shift_3 := { casting_cost_transform_symbol_shift(face:nameline_face_3(), offset:name_transform_symbol_offset_left_3() + nameline_offset_height_3(), disabled:transform_symbol_disabled_3() or (not transform_symbol_mirrored_3())) }

############################################################## Name offsets
name_left :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then
			map.left + 67 * map.width/523 + offset
	else	map.left + 32 * map.width/375 + offset
}
name_top :=
{
	map := face_coordinates_map(face)
	if map.width > map.height then
			map.top + 19 * map.height/375 + offset
	else	map.top + 27 * map.height/523 + offset
}
name_right :=
{
	map := face_coordinates_map(face)
	casting_cost_width_1 := if card_style.casting_cost.content_width == 0 then 0 else card_style.casting_cost.content_width + 3 * min(map.width, map.height)/375
	if map.width > map.height then
			map.left + 482 * map.width/523 - casting_cost_width_1 + offset
	else	map.left + 341 * map.width/375 - casting_cost_width_1 + offset
}
name_height :=
{
	map := face_coordinates_map(face)
	26 * min(map.width, map.height)/375 + offset
}

name_transform_symbol_shift :=
{
	if transform_symbol_field(face) == "none" or card_symbol_field(face) == "none" or disabled
		then 0
	else (
		map := face_coordinates_map(face)
		29 * (min(map.width, map.height)/375) + offset
	)
}

name_card_symbol_shift := {
	if card_symbol_field(face) == "none" or disabled
		then 0
	else (
		map := face_coordinates_map(face)
		18 * (min(map.width, map.height)/375) + offset
	)
}

name_max_width_1 := { card_style.name.width }
name_disabled_1 := { false }
name_offset_top_1 := { 0 }
name_offset_left_1 := { 0 }
name_offset_right_1 := { 0 }
name_offset_height_1 := { 0 }
name_card_symbol_offset_left_1 := { 0 }
name_transform_symbol_offset_left_1 := { 0 }
name_left_1 :=   { name_left(face:nameline_face_1(),   offset:name_offset_left_1())   }
name_top_1 :=    { name_top(face:nameline_face_1(),    offset:name_offset_top_1())    }
name_right_1 :=  { name_right(face:nameline_face_1(),  offset:name_offset_right_1())  }
name_height_1 := { name_height(face:nameline_face_1(), offset:name_offset_height_1()) }
name_card_symbol_shift_1 :=      { name_card_symbol_shift(face:nameline_face_1(), offset:name_card_symbol_offset_left_1(), disabled:card_symbol_disabled_1()) }
name_transform_symbol_shift_1 := { name_transform_symbol_shift(face:nameline_face_1(), offset:name_transform_symbol_offset_left_1() + nameline_offset_height_1(), disabled:transform_symbol_disabled_1() or transform_symbol_mirrored_1()) }

name_disabled_2 := { false }
name_offset_top_2 := { 0 }
name_offset_left_2 := { 0 }
name_offset_right_2 := { 0 }
name_offset_height_2 := { 0 }
name_card_symbol_offset_left_2 := { 0 }
name_transform_symbol_offset_left_2 := { 0 }
name_max_width_2 := { card_style.name_2.width }
name_left_2 :=   { name_left(face:nameline_face_2(),   offset:name_offset_left_2())   }
name_top_2 :=    { name_top(face:nameline_face_2(),    offset:name_offset_top_2())    }
name_right_2 :=  { name_right(face:nameline_face_2(),  offset:name_offset_right_2())  }
name_height_2 := { name_height(face:nameline_face_2(), offset:name_offset_height_2()) }
name_card_symbol_shift_2 :=      { name_card_symbol_shift(face:nameline_face_2(), offset:name_card_symbol_offset_left_2(), disabled:card_symbol_disabled_2()) }
name_transform_symbol_shift_2 := { name_transform_symbol_shift(face:nameline_face_2(), offset:name_transform_symbol_offset_left_2() + nameline_offset_height_2(), disabled:transform_symbol_disabled_2() or transform_symbol_mirrored_2()) }

name_disabled_3 := { false }
name_offset_top_3 := { 0 }
name_offset_left_3 := { 0 }
name_offset_right_3 := { 0 }
name_offset_height_3 := { 0 }
name_card_symbol_offset_left_2 := { 0 }
name_transform_symbol_offset_left_3 := { 0 }
name_max_width_3 := { card_style.name_3.width }
name_left_3 :=   { name_left(face:nameline_face_3(),   offset:name_offset_left_3())   }
name_top_3 :=    { name_top(face:nameline_face_3(),    offset:name_offset_top_3())    }
name_right_3 :=  { name_right(face:nameline_face_3(),  offset:name_offset_right_3())  }
name_height_3 := { name_height(face:nameline_face_3(), offset:name_offset_height_3()) }
name_card_symbol_shift_3 :=      { name_card_symbol_shift(face:nameline_face_3(), offset:name_card_symbol_offset_left_3(), disabled:card_symbol_disabled_3()) }
name_transform_symbol_shift_3 := { name_transform_symbol_shift(face:nameline_face_3(), offset:name_transform_symbol_offset_left_3() + nameline_offset_height_3(), disabled:transform_symbol_disabled_3() or transform_symbol_mirrored_3()) }

############################################################## Nameline offsets
nameline_face_1 := { 1 }
nameline_disabled_1 := { false }
nameline_offset_top_1 := { 0 }
nameline_offset_left_1 := { 0 }
nameline_offset_width_1 := { 0 }
nameline_offset_height_1 := { 0 }

nameline_face_2 := { 2 }
nameline_disabled_2 := { false }
nameline_offset_top_2 := { 0 }
nameline_offset_left_2 := { 0 }
nameline_offset_width_2 := { 0 }
nameline_offset_height_2 := { 0 }

nameline_face_3 := { 3 }
nameline_disabled_3 := { false }
nameline_offset_top_3 := { 0 }
nameline_offset_left_3 := { 0 }
nameline_offset_width_3 := { 0 }
nameline_offset_height_3 := { 0 }

############################################################## Stamps
### The stamp to use if the user hasn't overwritten it for this card
card_stamp_default := {
	shape := styling.default_stamp or else set.default_stamp
	if shape == "iderp classicshifted" then shape := "iderp classicshifted default"
	stamp_behavior := styling.stamp_behavior or else set.stamp_behavior
	if stamp_behavior == "default" or stamp_behavior == "flatstamped default" then stamp_behavior := set.stamp_behavior
	
	if field > 1
		then "none" #### backface doesn't have it by default
	else stamp_behavior_checks[stamp_behavior](rare_face:is_rare(field:field), shape:shape)
}@(field:1)
### Map for easier checks than if/else or case
stamp_behavior_checks := [
	"All unstamped": {"none"},
	"All holostamped": {shape},
	"All flatstamped": {"flatstamped " + shape},
	"Standard, rares holostamped": {
		if rare_face then shape else "none"
	},
	"UB, rares holostamped, others flatstamped": {
		if rare_face then shape else "flatstamped " + shape
	}
]
### The image to use for custom stamp
custom_stamp := {
	fs := split_custom_directory(set.custom_stamp_name)
	if set.custom_stamp_name != "" and has_png(set.custom_stamp_name)
		then "/magic-mainframe-extras.mse-include/" 
			+ fs.directory
			+ dimensions + " "
			+ (if flat then "flatstamped " else "")
			+ fs.filename
	else "/magic-modules.mse-include/stamps/375x523 " + (if flat then "flatstamped " else "") + "heart.png"
}@(flat:false)
### The shape of the background stamp for templates
### This can be overwritten to give a template a special stamp for the heart stamp, for example
stamp_shape := {
	case card_stamp_field(field) of
		"universes beyond": "triangle",
		"flatstamped universes beyond": "triangle",
		"none": "none",
		"custom": set.custom_stamp_shape,
		"flatstamped custom": set.custom_stamp_shape,
		else: "round";
}@(field:1)

### The card_stamp_X field for this face
card_stamp_field := { if input <= 1 then card.card_stamp else card["card_stamp_" + input] }
### Does this face have any stamp?
is_stamped := { card_stamp_field(field) != "none" }@(field: 1)
### Does this face have a foil stamp?
is_foil_stamped := { not contains(card_stamp_field(field), match:"flatstamped") }@(field:1)

### Determine the image for the stamp
card_stamp_image :=
{
	if not is_stamped(field: field)
		then ""
	else (
		map := face_coordinates_map(face)
		if map.width == 0 or map.height == 0
			then ""
		else (
			dimensions := map.width + "x" + map.height
			dimensions := card_stamp_possible_dimensions[dimensions] or else (if map.width > map.height then "1039x744" else "744x1039")
			shape := card_stamp_field(field)
			if shape == "default" then shape := set.default_stamp
			if shape == "iderp classicshifted" then shape := "iderp classicshifted default"
			if shape == "custom" or shape == "flatstamped custom"
				then custom_stamp(dimensions: dimensions, flat:not is_foil_stamped(field:field))
			else if shape == "none"
				then ""
			else "/magic-modules.mse-include/stamps/" + dimensions + " " + shape + ".png"
		)
	)
}
card_stamp_possible_dimensions :=
[
	"375x523":	"375x523"
	"523x375":	"523x375"
	"744x1039":	"744x1039"
	"1039x744":	"1039x744"
]
### Offsets for the stamps module
card_stamp_disabled_1 := { false }
card_stamp_offset_top_1 := { 0 }
card_stamp_offset_left_1 := { 0 }
card_stamp_offset_width_1 := { 0 }
card_stamp_offset_height_1 := { 0 }
card_stamp_disabled_2 := { false }
card_stamp_offset_top_2 := { 0 }
card_stamp_offset_left_2 := { 0 }
card_stamp_offset_width_2 := { 0 }
card_stamp_offset_height_2 := { 0 }
card_stamp_disabled_3 := { false }
card_stamp_offset_top_3 := { 0 }
card_stamp_offset_left_3 := { 0 }
card_stamp_offset_width_3 := { 0 }
card_stamp_offset_height_3 := { 0 }

############################################################## Pinlines
#### Face 1
pinline_disabled_1 := { false }
pinline_offset_left_1 := { 0 }
pinline_offset_top_1 := { 0 }
pinline_offset_width_1 := { 0 }
pinline_offset_height_1 := { 0 }
#### Face 2
pinline_disabled_2 := { false }
pinline_offset_left_2 := { 0 }
pinline_offset_top_2 := { 0 }
pinline_offset_width_2 := { 0 }
pinline_offset_height_2 := { 0 }
#### Face 3
pinline_disabled_3 := { false }
pinline_offset_left_3 := { 0 }
pinline_offset_top_3 := { 0 }
pinline_offset_width_3 := { 0 }
pinline_offset_height_3 := { 0 }
#### The primary image script. May apply a mask with set_mask to cut around art and other inner components 
pinline_image_1 := {""}
pinline_image_2 := {""}
pinline_image_3 := {""}
#### The mask used within the image script
pinline_inner_mask_1 := {""}
pinline_inner_mask_2 := {""}
pinline_inner_mask_3 := {""}
#### The mask used on the actual field, allowing invisible parts to be clicked through
pinline_mask_1 := {""}
pinline_mask_2 := {""}
pinline_mask_3 := {""}
############################################################## Crown
crowns_folder := {"/magic-modules.mse-include/crowns/375/"}
module_legend_crown_template := { crowns_folder() + input + "crown.png" }
module_borderless_crown_template := { crowns_folder() + "borderless/" + input + "crown.png" }
module_nyx_crown_template := { crowns_folder() + "nyx/" + input + "crown.png" }
module_companion_crown_template := { crowns_folder() + "companion/" + input + "crown.png" }
module_brawl_crown_template := { crowns_folder() + "brawl/" + input + "crown.png" }
module_custom_crown_template := { 
	"/magic-mainframe-extras.mse-include/"
	+ styling.custom_crown_location
	+ input
	+ "crown.png"
}

module_crown_template := {
	crown_shape := styling.legend_crown or else crown_type
	if override != "" then crown_shape := override
	case crown_shape of
		"borderless": module_borderless_crown_template(),
		"nyx": module_nyx_crown_template(),
		"companion": module_companion_crown_template(),
		"brawl": module_brawl_crown_template(),
		"custom": module_custom_crown_template(),
		else: module_legend_crown_template();
}@(crown_type:"normal", override:"")

module_crown := { color_background(type:"crown",     base_hybrid:card_hybrid, folder:crowns_folder()) }
module_crown_2 := { color_background(type:"crown",     base_hybrid:card_hybrid, folder:crowns_folder(), blend_type:"crown") }
module_crown_3 := { color_background(type:"crown",     base_hybrid:card_hybrid, folder:crowns_folder(), blend_type:"crown") }

crown_disabled_1 := { not is_legend(face:1) }
crown_offset_left_1 := { 0 }
crown_offset_top_1 :=  { 0 }
crown_disabled_2 := { not is_legend(face:2) }
crown_offset_left_2 := { 0 }
crown_offset_top_2 :=  { 0 }
crown_disabled_3 := { not is_legend(face:3) }
crown_offset_left_3 := { 0 }
crown_offset_top_3 :=  { 0 }

############################################################## module styling
popout_coord := {
	split := split_comma(field)
	if length(split) > lim and split[input] != ""
		then to_number_lax(split[input])
	else 0
}@(lim:3)
popout_left   := { popout_coord(0, field:styling.popout_art_coordinates or else "") }
popout_top 	  := { popout_coord(1, field:styling.popout_art_coordinates or else "") }
popout_width  := { popout_coord(2, field:styling.popout_art_coordinates or else "") }
popout_height := { popout_coord(3, field:styling.popout_art_coordinates or else "") }
popout_angle  := { popout_coord(4, field:styling.popout_art_coordinates or else "", lim:4) }
popout_left_2   := { popout_coord(0, field:styling.popout_art_2_coordinates or else "") }
popout_top_2	:= { popout_coord(1, field:styling.popout_art_2_coordinates or else "") }
popout_width_2  := { popout_coord(2, field:styling.popout_art_2_coordinates or else "") }
popout_height_2 := { popout_coord(3, field:styling.popout_art_2_coordinates or else "") }
popout_angle_2  := { popout_coord(4, field:styling.popout_art_2_coordinates or else "", lim:4) }

module_chop := {
	split := split_comma(styling.chop_text_box or else "")
	if length(split) > input
		then to_number_lax(split[input])
	else 0
}
chop_top    := { module_chop(0) }
chop_bottom := { module_chop(1) }
chop_right  := { module_chop(2) }

############################################################## Overlay masks
foil_mask_base_image := { "foil_mask.png" }
foil_mask_added_sections := {
	output := []
	pt_field := if face == 1 then card.pt else card["pt_" + face]
	if pt_field != "" then output := output + ["foil_mask_pt.png"]
	output
}@(face:1)
foil_mask_removed_sections := {
	output := []
	sh := stamp_shape(field:face)
	if sh == "round" then output := output + ["foil_mask_round.png"]
	else if sh == "triangle" then output := output + ["foil_mask_triangle.png"]
	output
}@(face:1)
foil_mask_blended_image := {
	img := foil_mask_base_image(face)
	if img != "" then ( 
		added := foil_mask_added_sections(face)
		removed := foil_mask_removed_sections(face)
		len_add := length(added)
		len_rem := length(removed)
		if(len_add > 0) then (
			for i from 0 to len_add-1 do (
				img := masked_blend(dark:img, light:added[i], mask:added[i]);
				"dummy return"
			)
		)
		if(len_rem > 0) then (
			for i from 0 to len_rem-1 do (
				img := masked_blend(light:img, dark:removed[i], mask:removed[i]);
				"dummy return"
			)
		)
	)
	img
}@(face:1)
############################################################## module styling
popout_coord := {
	split := split_comma(field)
	if length(split) > lim and split[input] != ""
		then to_number_lax(split[input])
	else 0
}@(lim:3)
popout_left   := { popout_coord(0, field:styling.popout_art_coordinates or else "") }
popout_top 	  := { popout_coord(1, field:styling.popout_art_coordinates or else "") }
popout_width  := { popout_coord(2, field:styling.popout_art_coordinates or else "") }
popout_height := { popout_coord(3, field:styling.popout_art_coordinates or else "") }
popout_angle  := { popout_coord(4, field:styling.popout_art_coordinates or else "", lim:4) }
popout_left_2   := { popout_coord(0, field:styling.popout_art_2_coordinates or else "") }
popout_top_2	:= { popout_coord(1, field:styling.popout_art_2_coordinates or else "") }
popout_width_2  := { popout_coord(2, field:styling.popout_art_2_coordinates or else "") }
popout_height_2 := { popout_coord(3, field:styling.popout_art_2_coordinates or else "") }
popout_angle_2  := { popout_coord(4, field:styling.popout_art_2_coordinates or else "", lim:4) }

############################################################## Custom corner symbols
verify_symbol_image := {
	array := split_comma(input)
	if not has_png(array.0)
		then array.0
	else (
		sym_link := array.0
		sym_pad := array.3 or else ""
		sym_exists := exists_in_package("/magic-mainframe-extras.mse-include/"+sym_link)
		if not sym_exists then (
			sym_link + ",Not found,Ensure the file name is correct in /data/magic-mainframe-extras and reload," + sym_pad
		) else (
			sym_width := width_of("/magic-mainframe-extras.mse-include/"+sym_link)
			sym_pad := array.3 or else ""
			if (sym_width <= 512) then (
				if sym_pad == "" then sym_pad := "+"
			)
			sym_link + ",File found,{sym_width},{sym_pad}"
		)
	)
}
custom_symbol_image := {
	src := if style_src != "" then style_src else set["custom_symbol_"+input]
	array := split_comma(src)
	if not has_png(array.0) or (array.1 or else "" == "Not found")
		then "/magic-modules.mse-include/symbols/aetherprint.png"
	else (
		link := "/magic-mainframe-extras.mse-include/" + array.0
		if array.3 or else "" == "+" then link := enlarge(link, border_size:0.189)
		link
	)
}@(style_src:"")
custom_symbol_1 := {
	style_src := styling.custom_symbol_1 or else styling.custom_symbol_one or else styling.custom_symbol or else ""
	custom_symbol_image(1, style_src:style_src)
}
custom_symbol_2 := {
	style_src := styling.custom_symbol_2 or else styling.custom_symbol_two or else styling.custom_symbol or else ""
	custom_symbol_image(2, style_src:style_src)
}
custom_symbol_3 := {
	style_src := styling.custom_symbol_3 or else styling.custom_symbol_three or else styling.custom_symbol or else ""
	custom_symbol_image(3, style_src:style_src)
}
custom_symbol_4 := {
	style_src := styling.custom_symbol_4 or else styling.custom_symbol_four or else styling.custom_symbol or else ""
	custom_symbol_image(4, style_src:style_src)
}
############################################################## Custom fonts
swap_font := {styling.apply_custom_fonts or else false}
split_font := split_text@(match:";")
pop_font_name := {split_font(input).0 or else ""}
pop_font_size := {split_font(input).1 or else ""}
pop_font_color := {split_font(input).2 or else ""}
pop_font_vertical := {split_font(input).3 or else ""}
pop_font_italic := {split_font(input).4 or else ""}
#### General swap functions
swap_font_name := {
	if swap_font() then (
		test := pop_font_name(src)
		if test != "" then font_name := test
	)
	
	font_name
}
swap_font_size := {
	if swap_font() then (
		test := pop_font_size(src)
		if test != "" then font_size := test
	)
	
	font_size
}
swap_font_color := {
	if swap_font() then (
		test := pop_font_color(src)
		nums := split_text(test, match:",")
		test_color := nil
		
		if length(nums) >= 4 then test_color := rgba(to_number_lax(nums.0), to_number_lax(nums.1), to_number_lax(nums.2), to_number_lax(nums.3)) or else nil
		if test_color == nil and length(nums) >= 3 then test_color := rgb(to_number_lax(nums.0), to_number_lax(nums.1), to_number_lax(nums.2)) or else nil
		if test_color == nil and test != "" then test_color := to_color(test) or else nil
		if test_color != nil then font_color := test_color
	) else ""
	
	font_color
}
swap_font_vertical := {
	if swap_font() then (
		test := pop_font_vertical(src)
		if test != "" then vertical := to_number(test)
	)
	
	vertical
}
swap_font_italic := {
	if swap_font() then (
		test := pop_font_italic(src)
		test2 := pop_font_name(src)
		if test != "" then font_name := test
		else if test2 != "" then font_name := ""
	)
	
	font_name
}
#### defaults, can be changed in style
swap_fonts_name_default := [
	name: {"Beleren Bold"},
	size: {16},
	color: {"black"},
	vertical: {0},
	italic: {""}
]
swap_fonts_name2_default := [
	name: {"Beleren Bold"},
	size: {16},
	color: {"black"},
	vertical: {0},
	italic: {""}
]
swap_fonts_name3_default := [
	name: {"Beleren Bold"},
	size: {16},
	color: {"black"},
	vertical: {0},
	italic: {""}
]
swap_fonts_casting_cost_default := [
	name: {"MPlantin"},
	size: {name_font_size()},
	color: {"black"},
	vertical: {0},
	italic: {"MPlantin-Italic"}
]
swap_fonts_casting_cost2_default := [
	name: {"MPlantin"},
	size: {name2_font_size()},
	color: {"black"},
	vertical: {0},
	italic: {"MPlantin-Italic"}
]
swap_fonts_casting_cost3_default := [
	name: {"MPlantin"},
	size: {name3_font_size()},
	color: {"black"},
	vertical: {0},
	italic: {"MPlantin-Italic"}
]
swap_fonts_type_default := [
	name: {"Beleren Bold"},
	size: {13},
	color: {"black"},
	vertical: {0},
	italic: {""}
]
swap_fonts_type2_default := [
	name: {"Beleren Bold"},
	size: {13},
	color: {"white"},
	vertical: {0},
	italic: {""}
]
swap_fonts_type3_default := [
	name: {"Beleren Bold"},
	size: {13},
	color: {"white"},
	vertical: {0},
	italic: {""}
]
swap_fonts_body_default := [
	name: {"MPlantin"},
	size: {13},
	color: {"black"},
	vertical: {0},
	italic: {"MPlantin-Italic"}
]
swap_fonts_body2_default := [
	name: {"MPlantin"},
	size: {13},
	color: {"black"},
	vertical: {0},
	italic: {"MPlantin-Italic"}
]
swap_fonts_body3_default := [
	name: {"MPlantin"},
	size: {13},
	color: {"black"},
	vertical: {0},
	italic: {"MPlantin-Italic"}
]
swap_fonts_pt_default := [
	name: {"Beleren Bold"},
	size: {16},
	color: {"black"},
	vertical: {0},
	italic: {""}
]
swap_fonts_pt2_default := [
	name: {"Beleren Bold"},
	size: {16},
	color: {"black"},
	vertical: {0},
	italic: {""}
]
swap_fonts_pt3_default := [
	name: {"Beleren Bold"},
	size: {16},
	color: {"black"},
	vertical: {0},
	italic: {""}
]
swap_fonts_name_src :=          { styling.custom_name_font           or else "" }
swap_fonts_name2_src :=         { styling.custom_name_2_font         or else "" }
swap_fonts_name3_src :=         { styling.custom_name_3_font         or else "" }
swap_fonts_casting_cost_src :=  { styling.custom_casting_cost_font   or else "" }
swap_fonts_casting_cost2_src := { styling.custom_casting_cost_2_font or else "" }
swap_fonts_casting_cost3_src := { styling.custom_casting_cost_3_font or else "" }
swap_fonts_type_src :=          { styling.custom_type_font           or else "" }
swap_fonts_type2_src :=         { styling.custom_type_2_font         or else "" }
swap_fonts_type3_src :=         { styling.custom_type_3_font         or else "" }
swap_fonts_body_src :=          { styling.custom_body_font           or else "" }
swap_fonts_body2_src :=         { styling.custom_body_2_font         or else "" }
swap_fonts_body3_src :=         { styling.custom_body_3_font         or else "" }
swap_fonts_pt_src :=            { styling.custom_pt_font             or else "" }
swap_fonts_pt2_src :=           { styling.custom_pt_2_font           or else "" }
swap_fonts_pt3_src :=           { styling.custom_pt_3_font           or else "" }
#### specific swap functions
name_font := {
	swap_font_name(
		src: swap_fonts_name_src(), 
		font_name: swap_fonts_name_default.name()
	)
}
name_font_size := {
	swap_font_size(
		src: swap_fonts_name_src(), 
		font_size: swap_fonts_name_default.size()
	) - shrink_name()
}
name_font_color := {
	swap_font_color(
		src: swap_fonts_name_src(),
		font_color: swap_fonts_name_default.color()
	)
}
name_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_name_src(),
		vertical: swap_fonts_name_default.vertical()
	)
}
name_font_italic := {
	swap_font_italic(
		src: swap_fonts_name_src(),
		font_name: swap_fonts_name_default.italic()
	)
}
name_shadow_color :=			{ rgba(0,0,0,0) }
name_shadow_displacement_x :=	{ 0 }
name_shadow_displacement_y :=	{ 0 }

name2_font := {
	swap_font_name(
		src: swap_fonts_name2_src(), 
		font_name: swap_fonts_name2_default.name()
	)
}
name2_font_size := {
	swap_font_size(
		src: swap_fonts_name2_src(), 
		font_size: swap_fonts_name2_default.size()
	) - shrink_name2()
}
name2_font_color := {
	swap_font_color(
		src: swap_fonts_name2_src(),
		font_color: swap_fonts_name2_default.color()
	)
}
name2_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_name2_src(),
		vertical: swap_fonts_name2_default.vertical()
	)
}
name2_font_italic := {
	swap_font_italic(
		src: swap_fonts_name2_src(),
		font_name: swap_fonts_name2_default.italic()
	)
}
name2_shadow_color :=			{ rgba(0,0,0,0) }
name2_shadow_displacement_x :=	{ 0 }
name2_shadow_displacement_y :=	{ 0 }

name3_font := {
	swap_font_name(
		src: swap_fonts_name3_src(), 
		font_name: swap_fonts_name3_default.name()
	)
}
name3_font_size := {
	swap_font_size(
		src: swap_fonts_name3_src(), 
		font_size: swap_fonts_name3_default.size()
	) - shrink_name2()
}
name3_font_color := {
	swap_font_color(
		src: swap_fonts_name3_src(),
		font_color: swap_fonts_name3_default.color()
	)
}
name3_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_name3_src(),
		vertical: swap_fonts_name3_default.vertical()
	)
}
name3_font_italic := {
	swap_font_italic(
		src: swap_fonts_name3_src(),
		font_name: swap_fonts_name3_default.italic()
	)
}
name3_shadow_color :=			{ rgba(0,0,0,0) }
name3_shadow_displacement_x :=	{ 0 }
name3_shadow_displacement_y :=	{ 0 }

casting_cost_font := {
	swap_font_name(
		src: swap_fonts_casting_cost_src(), 
		font_name: swap_fonts_casting_cost_default.name()
	)
}
casting_cost_font_size := {
	swap_font_size(
		src: swap_fonts_casting_cost_src(), 
		font_size: swap_fonts_casting_cost_default.size()
	) - shrink_name()
}
casting_cost_font_color := {
	swap_font_color(
		src: swap_fonts_casting_cost_src(),
		font_color: swap_fonts_casting_cost_default.color()
	)
}
casting_cost_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_casting_cost_src(),
		vertical: swap_fonts_casting_cost_default.vertical()
	)
}
casting_cost_font_italic := {
	swap_font_italic(
		src: swap_fonts_casting_cost_src(),
		font_name: swap_fonts_casting_cost_default.italic()
	)
}

casting_cost2_font := {
	swap_font_name(
		src: swap_fonts_casting_cost2_src(), 
		font_name: swap_fonts_casting_cost2_default.name()
	)
}
casting_cost2_font_size := {
	swap_font_size(
		src: swap_fonts_casting_cost2_src(), 
		font_size: swap_fonts_casting_cost2_default.size()
	) - shrink_name2()
}
casting_cost2_font_color := {
	swap_font_color(
		src: swap_fonts_casting_cost2_src(),
		font_color: swap_fonts_casting_cost2_default.color()
	)
}
casting_cost2_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_casting_cost2_src(),
		vertical: swap_fonts_casting_cost2_default.vertical()
	)
}
casting_cost2_font_italic := {
	swap_font_italic(
		src: swap_fonts_casting_cost2_src(),
		font_name: swap_fonts_casting_cost2_default.italic()
	)
}

casting_cost3_font := {
	swap_font_name(
		src: swap_fonts_casting_cost3_src(), 
		font_name: swap_fonts_casting_cost3_default.name()
	)
}
casting_cost3_font_size := {
	swap_font_size(
		src: swap_fonts_casting_cost3_src(), 
		font_size: swap_fonts_casting_cost3_default.size()
	) - shrink_name2()
}
casting_cost3_font_color := {
	swap_font_color(
		src: swap_fonts_casting_cost3_src(),
		font_color: swap_fonts_casting_cost3_default.color()
	)
}
casting_cost3_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_casting_cost3_src(),
		vertical: swap_fonts_casting_cost3_default.vertical()
	)
}
casting_cost3_font_italic := {
	swap_font_italic(
		src: swap_fonts_casting_cost3_src(),
		font_name: swap_fonts_casting_cost3_default.italic()
	)
}

type_font := {
	swap_font_name(
		src: swap_fonts_type_src(), 
		font_name: swap_fonts_type_default.name()
	)
}
type_font_size := {
	swap_font_size(
		src: swap_fonts_type_src(), 
		font_size: swap_fonts_type_default.size()
	) - shrink_type()
}
type_font_color := {
	swap_font_color(
		src: swap_fonts_type_src(),
		font_color: swap_fonts_type_default.color()
	)
}
type_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_type_src(),
		vertical: swap_fonts_type_default.vertical()
	)
}
type_font_italic := {
	swap_font_italic(
		src: swap_fonts_type_src(),
		font_name: swap_fonts_type_default.italic()
	)
}
type_shadow_color :=			{ rgba(0,0,0,0) }
type_shadow_displacement_x :=	{ 0 }
type_shadow_displacement_y :=	{ 0 }

type2_font := {
	swap_font_name(
		src: swap_fonts_type2_src(), 
		font_name: swap_fonts_type2_default.name()
	)
}
type2_font_size := {
	swap_font_size(
		src: swap_fonts_type2_src(), 
		font_size: swap_fonts_type2_default.size()
	) - shrink_type2()
}
type2_font_color := {
	swap_font_color(
		src: swap_fonts_type2_src(),
		font_color: swap_fonts_type2_default.color()
	)
}
type2_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_type2_src(),
		vertical: swap_fonts_type2_default.vertical()
	)
}
type2_font_italic := {
	swap_font_italic(
		src: swap_fonts_type2_src(),
		font_name: swap_fonts_type2_default.italic()
	)
}
type2_shadow_color :=			{ rgba(0,0,0,0) }
type2_shadow_displacement_x :=	{ 0 }
type2_shadow_displacement_y :=	{ 0 }

type3_font := {
	swap_font_name(
		src: swap_fonts_type3_src(), 
		font_name: swap_fonts_type3_default.name()
	)
}
type3_font_size := {
	swap_font_size(
		src: swap_fonts_type3_src(), 
		font_size: swap_fonts_type3_default.size()
	) - shrink_type2()
}
type3_font_color := {
	swap_font_color(
		src: swap_fonts_type3_src(),
		font_color: swap_fonts_type3_default.color()
	)
}
type3_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_type3_src(),
		vertical: swap_fonts_type3_default.vertical()
	)
}
type3_font_italic := {
	swap_font_italic(
		src: swap_fonts_type3_src(),
		font_name: swap_fonts_type3_default.italic()
	)
}
type3_shadow_color :=			{ rgba(0,0,0,0) }
type3_shadow_displacement_x :=	{ 0 }
type3_shadow_displacement_y :=	{ 0 }

body_font := {
	swap_font_name(
		src: swap_fonts_body_src(), 
		font_name: swap_fonts_body_default.name()
	)
}
body_font_size := {
	swap_font_size(
		src: swap_fonts_body_src(), 
		font_size: swap_fonts_body_default.size()
	)
}
body_font_color := {
	swap_font_color(
		src: swap_fonts_body_src(),
		font_color: swap_fonts_body_default.color()
	)
}
body_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_body_src(),
		vertical: swap_fonts_body_default.vertical()
	)
}
body_font_italic := {
	swap_font_italic(
		src: swap_fonts_body_src(),
		font_name: swap_fonts_body_default.italic()
	)
}

body2_font := {
	swap_font_name(
		src: swap_fonts_body2_src(), 
		font_name: swap_fonts_body2_default.name()
	)
}
body2_font_size := {
	swap_font_size(
		src: swap_fonts_body2_src(), 
		font_size: swap_fonts_body2_default.size()
	)
}
body2_font_color := {
	swap_font_color(
		src: swap_fonts_body2_src(),
		font_color: swap_fonts_body2_default.color()
	)
}
body2_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_body2_src(),
		vertical: swap_fonts_body2_default.vertical()
	)
}
body2_font_italic := {
	swap_font_italic(
		src: swap_fonts_body2_src(),
		font_name: swap_fonts_body2_default.italic()
	)
}

body3_font := {
	swap_font_name(
		src: swap_fonts_body3_src(), 
		font_name: swap_fonts_body3_default.name()
	)
}
body3_font_size := {
	swap_font_size(
		src: swap_fonts_body3_src(), 
		font_size: swap_fonts_body3_default.size()
	)
}
body3_font_color := {
	swap_font_color(
		src: swap_fonts_body3_src(),
		font_color: swap_fonts_body3_default.color()
	)
}
body3_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_body3_src(),
		vertical: swap_fonts_body3_default.vertical()
	)
}
body3_font_italic := {
	swap_font_italic(
		src: swap_fonts_body3_src(),
		font_name: swap_fonts_body3_default.italic()
	)
}

pt_font := {
	swap_font_name(
		src: swap_fonts_pt_src(), 
		font_name: swap_fonts_pt_default.name()
	)
}
pt_font_size := {
	swap_font_size(
		src: swap_fonts_pt_src(), 
		font_size: swap_fonts_pt_default.size()
	)
}
pt_font_color := {
	swap_font_color(
		src: swap_fonts_pt_src(),
		font_color: swap_fonts_pt_default.color()
	)
}
pt_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_pt_src(),
		vertical: swap_fonts_pt_default.vertical()
	)
}
pt_font_italic := {
	swap_font_italic(
		src: swap_fonts_pt_src(),
		font_name: swap_fonts_pt_default.italic()
	)
}

pt2_font := {
	swap_font_name(
		src: swap_fonts_pt2_src(), 
		font_name: swap_fonts_pt2_default.name()
	)
}
pt2_font_size := {
	swap_font_size(
		src: swap_fonts_pt2_src(), 
		font_size: swap_fonts_pt2_default.size()
	)
}
pt2_font_color := {
	swap_font_color(
		src: swap_fonts_pt2_src(),
		font_color: swap_fonts_pt2_default.color()
	)
}
pt2_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_pt2_src(),
		vertical: swap_fonts_pt2_default.vertical()
	)
}
pt2_font_italic := {
	swap_font_italic(
		src: swap_fonts_pt2_src(),
		font_name: swap_fonts_pt2_default.italic()
	)
}

pt3_font := {
	swap_font_name(
		src: swap_fonts_pt3_src(), 
		font_name: swap_fonts_pt3_default.name()
	)
}
pt3_font_size := {
	swap_font_size(
		src: swap_fonts_pt3_src(), 
		font_size: swap_fonts_pt3_default.size()
	)
}
pt3_font_color := {
	swap_font_color(
		src: swap_fonts_pt3_src(),
		font_color: swap_fonts_pt3_default.color()
	)
}
pt3_font_vertical := {
	swap_font_vertical(
		src: swap_fonts_pt3_src(),
		vertical: swap_fonts_pt3_default.vertical()
	)
}
pt3_font_italic := {
	swap_font_italic(
		src: swap_fonts_pt3_src(),
		font_name: swap_fonts_pt3_default.italic()
	)
}

shrink_name :=  {0}
shrink_type :=  {0}
shrink_name2 := {0}
shrink_type2 := {0}
############################################################## Custom rarity symbol
mainframe_rarity_string := {
	if styling.mainframe_rarity_name or else "" != ""
		then mr := styling.mainframe_rarity_name
	else set.mainframe_rarity_name
}
use_main_rarity := { has_png(mainframe_rarity_string()) }
mainframe_rarity := {"/magic-mainframe-extras.mse-include/" + un_png(mainframe_rarity_string()) + input + ".png"}
alt_rarity := { styling.alt_rarity_color or else "" }
use_alt_rarity := { alt_rarity() != "" }
alt_rarity_color := {
	string := "83,67,53:177,150,131:0,0,0:0,0,0:0.07:"
	src := alt_rarity()
	if match(src, match:":$") then string := src
	colons := length(filter_text(string, match:":"))
	output := split_text(string, match:",|:")
	splits := split_text(string, match:":")
	final_num := to_real(splits[length(splits)-2]) or else 0
	final_border := final_num > 0 and final_num < 1
	final_num := if not final_border then "0.07" else to_string(final_num);
	if final_border then (
		colons := colons - 1;
		string := replace(string, match:"{final_num}:", replace:"")
	)
	if colons == 4
		then output := split_text(string+final_num+":", match:",|:")
	if colons == 3
		then output := split_text(string+splits[2]+":"+final_num+":", match:",|:")
	else if colons == 2
		then output := split_text(string+"0,0,0:0,0,0:"+final_num+":", match:",|:")
	else if colons == 1
		then output := split_text(string+splits[0]+":0,0,0:0,0,0:"+final_num+":", match:",|:")
	
	output
}
alt_symbol := {
	alt_array := alt_rarity_color()
	symbol_variation(
		symbol:set.symbol,
		border_radius: alt_array.12,
		fill_type: "linear gradient",
		fill_color_1: rgb(alt_array.0, alt_array.1, alt_array.2),
		fill_color_2: rgb(alt_array.3, alt_array.4, alt_array.5),
		border_color_1: rgb(alt_array.6, alt_array.7, alt_array.8),
		border_color_2: rgb(alt_array.9, alt_array.10, alt_array.11),
		center_x:0.5, center_y:0.5, end_x:1, end_y:1
	)
}
############################################################## Other customizable stuff
split_custom_directory := {
	fn := filter_text(input, match:"[^./]+.png")
	dir := filter_text(input, match:"^([^.]+/)+")
	[directory:dir, filename:fn]
}
auto_custom_available := { set.auto_custom_border != "disabled" and has_png(set.auto_custom_border_source)}
auto_custom_border := {
	auto_custom_available() and active_custom_border()
}
active_custom_border := {
	if set.auto_custom_border == "check typeline" then
		contains(card.type, match:set.auto_custom_border_match)
	else if set.auto_custom_border == "check rules text" then
		contains(card.text, match:set.auto_custom_border_match)
	else false
}
auto_custom_border_2 := {
	auto_custom_available() and active_custom_border_2()
}
active_custom_border_2 := {
	if set.auto_custom_border == "check typeline" then
		contains(card.type_2, match:set.auto_custom_border_match)
	else if set.auto_custom_border == "check rules text" then
		contains(card.text_2, match:set.auto_custom_border_match)
	else false
}
custom_border_image := {
	src := styling.custom_border_source or else ""
	if (not has_png(src)) and auto_custom_available() then src := set.auto_custom_border_source
	ps := split_text(src, match:"-color-")
	if length(ps) > 1 then
		"/magic-mainframe-extras.mse-include/" + ps[0] + input + (if land then "l" else "") + ps[1]
	else
		"/magic-mainframe-extras.mse-include/" + src
}
alt_nyx_template := {
	src := set.alternate_nyx
	fs := filter_text(src, match:"[^./]+.png")
	dir := filter_text(src, match:"^([^.]+/)+")
	"/magic-mainframe-extras.mse-include/" + dir + input + (if land then "l" else "") + fs
}
harder_script := [
	alt_nyx: alt_nyx_template,
	custom_border: custom_border_image
]
############################################################## Card column sorting
type_sort_script :=
{
	sh := card.shape
	if set.alphabetical_type_column then super_type + " " + sub_type else
	#### first sort by 5 broad categories
	(
		if		is_tokenish_statistics(card.shape)			then	"4"
		else if	lang_setting("is_nonstandard")(super_type)	then	"3"
		else if	is_land(super_type)			then	"0"
		else if	is_spell(super_type)		then	"2"
		else														"1"	#### nonland permanents
	) +
	
	#### then check if creature
	(if is_creature(super_type)		then	"0" else "1") +
	
	#### then sort by type, no need to re-check for land or creature
	(if is_sorcery(super_type)		then	"1" else "0") +
	(if is_instant(super_type)		then	"1" else "0") +
	(if is_planeswalker(super_type)	then	"1" else "0") +
	(if is_battle(super_type)		then	"1" else "0") +
	(if is_enchantment(super_type)	then	"1" else "0") +
	(if is_artifact(super_type)		then	"1" else "0") +
	
	(if contains(sh, match: "rulestip")		then	"1" else "0") +
	(if contains(sh, match: "checklist")	then	"1" else "0") +
	(if lang_setting("is_token")(super_type)
		or contains(sh, match: "token")		then	"1" else "0") +
	(if is_emblem(super_type)
		or contains(sh, match: "emblem")	then	"1" else "0") +
	(if contains(sh, match: "counter")		then	"1" else "0") +
	(if contains(sh, match: "designation")	then	"1" else "0") +
	(if lang_setting("is_conspiracy")(super_type)	then	"1" else "0") +
	(if lang_setting("is_dungeon")(super_type)		then	"1" else "0") +
	(if lang_setting("is_phenomenon")(super_type)	then	"1" else "0") +
	(if lang_setting("is_plane")(super_type)		then	"1" else "0") +
	(if lang_setting("is_scheme")(super_type)		then	"1" else "0") +
	(if lang_setting("is_vanguard")(super_type)		then	"1" else "0") +
	(if lang_setting("is_hero")(super_type)			then	"1" else "0") +
	
	#### then sort by super type
	(if lang_setting("is_ongoing")(super_type)		then	"1" else "0") +
	(if lang_setting("is_basic")(super_type)		then	"1" else "0") +
	(if lang_setting("is_legendary")(super_type)	then	"1" else "0") +
	(if lang_setting("is_world")(super_type)		then	"1" else "0") +
	(if lang_setting("is_snow")(super_type)			then	"1" else "0") +
	(if lang_setting("is_kindred")(super_type)		then	"1" else "0") +
	
	#### then sort by sub type
	to_text(sub_type)
}

color_sort_script :=
{
	if chosen(input, choice:"land") then "0" + prefixed_color_identity_statistic() + input
	else "1" + prefixed_color_statistic() + input
}

rarity_sort_script :=
{
	if		input == "basic land"	then	"0"
	else if	input == "common"		then	"1"
	else if	input == "uncommon"		then	"2"
	else if	input == "rare"			then	"3"
	else if	input == "mythic rare"	then	"4"
	else if	input == "masterpiece"	then	"5"
	else									"6"
}
############################################################## Custom index
search_pull := filter_text@(match:"search(name|mana|type|rules|flavor|text|notes)")
search_snip := replace@(match:"search(name|mana|type|rules|flavor|text|notes)_", replace:"")

custom_index := {
	sorting_index := split_text(set.custom_index, match:",")
	for each field in sorting_index do 
			apply_index(to_lower(field))
		or else (
			search_index(to_lower(search_pull(field)), query:search_snip(field))
		)
		or else ""
}
apply_index := {
	[
		name: {
			fill_len(to_string(position (
				of: card
				in: set
				order_by: { sort_name(card.name) + sort_name(export_name())}
				filter:   set_filter()
			)), lead:"0", fill_to:3)
		},
		alias: {
			fill_len(to_string(position (
				of: card
				in: set
				order_by: { sort_name(card.alias) + sort_name(export_name())}
				filter:   set_filter()
			)), lead:"0", fill_to:3)
		}
		name2: {
			fill_len(to_string(position (
				of: card
				in: set
				order_by: { sort_name(card.name_2) + sort_name(export_name())}
				filter:   set_filter()
			)), lead:"0", fill_to:3)
		},
		alias2: {
			fill_len(to_string(position (
				of: card
				in: set
				order_by: { sort_name(card.alias_2) + sort_name(export_name())}
				filter:   set_filter()
			)), lead:"0", fill_to:3)
		}
		color: {fill_len(color_of_card(), lead:"A")},
		"color category": {
			indexes := [[lang_setting("colorless")], [lang_setting("white")], [lang_setting("blue")], [lang_setting("black")], [lang_setting("red")], [lang_setting("green")], [lang_setting("purple")], [lang_setting("pink")], [lang_setting("yellow")], [lang_setting("orange")], [lang_setting("brown")], [lang_setting("multicolor")], [lang_setting("hybrid")]]
			fill_len(position(of:[card.color_category], in:indexes, lead:"0", fill_to:2))
		},
		"exact color": {
			fill_len(card.exact_color, lead:"X", fill_to:5)
		},
		"color identity": {
			fill_len(card.color_identity, lead:"X", fill_to:5)
		},
		"color count": {card.color_count},
		"time created": {card.time_created},
		"created": {card.time_created},
		"time modified": {card.time_modified},
		"modified": {card.time_modified},
		"template": {fill_len(substring(card.template, begin:0, end:9), follow:" ", fill_to:10)},
		artist: {fill_len(substring(card.illustrator, end:7), follow:" ", fill_to:7)},
		artist2: {fill_len(substring(card.illustrator_2, end:7), follow:" ", fill_to:7)},
		design: {fill_len(substring(card.card_code_text, end:7), follow:" ", fill_to:7)},
		mv: {fill_len(to_string(cmc(card.casting_cost)), lead:"0")},
		"mana value": {fill_len(to_string(cmc(card.casting_cost)), lead:"0")},
		cmc: {fill_len(to_string(cmc(card.casting_cost)), lead:"0")},
		"converted mana cost": {fill_len(to_string(cmc(card.casting_cost)), lead:"0")},
		rarity: {index_of_rarity()},
		power: {fill_len(card.power, lead:"0")},
		toughness: {fill_len(card.toughness, lead:"0")},
		pt: {fill_len(card.power, lead:"0") + fill_len(card.toughness, lead:"0")},
		loyalty: {fill_len(card.loyalty, lead:"0")},
		type: {fill_len(filter_text(match:"[A-Z][A-Z]?[A-Z]?", filter_text(match:"[A-Z]", card.super_type)), follow:"0", fill_to:3)},
		hasrules: {if remove_tags(card.rule_text) != "" then "A" else "B"},
		hasflavor: {if remove_tags(card.flavor_text) != "" then "A" else "B"},
		hasrules2: {if remove_tags(card.rule_text_2) != "" then "A" else "B"},
		hasflavor2: {if remove_tags(card.flavor_text_2) != "" then "A" else "B"},
	][input]()
}
search_index := {
	[
		searchname: { if contains(card.name, match:query) or contains(card.name_2, match:query) then "A" else "B"},
		searchmana: { if contains(card.casting_cost, match:query) or contains(card.casting_cost_2, match:query) then "A" else "B"},
		searchtype: { if contains(card.type, match:query) or contains(card.type_2, match:query) then "A" else "B"},
		searchrules: { if contains(card.rule_text, match:query) or contains(card.rule_text_2, match:query) then "A" else "B"},
		searchflavor: { if contains(card.flavor_text, match:query) or contains(card.flavor_text_2, match:query) then "A" else "B"},
		searchartist: { if contains(card.illustrator, match:query) or contains(card.illustrator_2, match:query) then "A" else "B"},
		searchdesign: { if contains(card.card_code_text, match:query) then "A" else "B"},
		searchtext: { if contains(card.text, match:query) or contains(card.text_2, match:query) then "A" else "B"},
		searchnotes: { if contains(card.notes, match:query) then "A" else "B"},
		unsearchname: { if contains(card.name, match:query) or contains(card.name_2, match:query) then "B" else "A"},
		unsearchmana: { if contains(card.casting_cost, match:query) or contains(card.casting_cost_2, match:query) then "B" else "A"},
		unsearchtype: { if contains(card.type, match:query) or contains(card.type_2, match:query) then "B" else "A"},
		unsearchrules: { if contains(card.rule_text, match:query) or contains(card.rule_text_2, match:query) then "B" else "A"},
		unsearchflavor: { if contains(card.flavor_text, match:query) or contains(card.flavor_text_2, match:query) then "B" else "A"},
		unsearchartist: { if contains(card.illustrator, match:query) or contains(card.illustrator_2, match:query) then "B" else "A"},
		unsearchdesign: { if contains(card.card_code_text, match:query) then "B" else "A"},
		unsearchtext: { if contains(card.text, match:query) or contains(card.text_2, match:query) then "B" else "A"},
		unsearchnotes: { if contains(card.notes, match:query) then "B" else "A"}
	][input]()
}
index_of_rarity := {
	if card.rarity == "basic land" then "A"
	else if card.rarity == "common" then "C"
	else if card.rarity == "uncommon" then "D"
	else if card.rarity == "rare" then "E"
	else if card.rarity == "mythic rare" then "F"
	else if card.rarity == "special" then "G"
	else "J"
}
############################################################## Skeleton generator
skeleton_commons := 19
skeleton_uncommons := 11
skeleton_rares := 7
skeleton_mythics := 2
skeleton_land_commons := 1
skeleton_land_uncommons := 5
skeleton_land_rares := 0
skeleton_gold_commons := 0
skeleton_gold_uncommons := 1
skeleton_gold_rares := 1
skeleton_shard_commons := 0
skeleton_shard_uncommons := 0
skeleton_shard_rares := 0
skeleton_wedge_commons := 0
skeleton_wedge_uncommons := 0
skeleton_wedge_rares := 0
skeleton_artifact_commons := 5
skeleton_artifact_uncommons := 5
skeleton_artifact_rares := 0
skeleton_blank_commons := 0
skeleton_blank_uncommons := 5
skeleton_blank_rares := 8
skeleton_blank_mythics := 5
#### generates a set of CCXX Skeleton cards for each color
#### by insertnamehere and cajun
skeleton_runner := {
	cards := []
	for x from 0 to length(letter_list)-1 do
	(
		for y from 1 to count do
			if mana_list == "nope" then
				(cards := cards + [new_card([name:prefix+letter_list[x]+fill_len(y, lead:"0"), rarity:rarity, card_color:color_list[x], super_type:super_type])];)
			else
				(cards := cards + [new_card([name:prefix+letter_list[x]+fill_len(y, lead:"0"), rarity:rarity, super_type:super_type, casting_cost:mana_list[x]])];)
	)
	cards
}@(count:1, rarity:"common", type:"", prefix:"C", super_type:"", color_list:["white", "blue", "black", "red", "green"], letter_list:["W", "U", "B", "R", "G"], mana_list:"nope")
#### outside to make singleton scripts easier
blank_list_5 := ["","","","",""]
blank_list_10 := ["","","","","","","","","",""]
mana_list_ally := ["WU","UB","BR","RG","GW"]
mana_list_enemy := ["WB","UR","BG","RW","GU"]
mana_list_shard := ["WUB","UBR","BRG","RGW","GWU"]
mana_list_wedge := ["WBG","URW","BGU","RWB","GUR"]
skeleton_script := {
	cards := [];
	cards := cards + skeleton_runner(count:skeleton_commons);
	cards := cards + skeleton_runner(count:skeleton_uncommons, prefix:"U", rarity:"uncommon");
	cards := cards + skeleton_runner(count:skeleton_rares, prefix:"R", rarity:"rare");
	cards := cards + skeleton_runner(count:skeleton_mythics, prefix:"M", rarity:"mythic rare");
	cards := cards + skeleton_runner(count:skeleton_gold_commons, prefix:"CM", rarity:"common", letter_list:blank_list_10, mana_list:mana_list_ally+mana_list_enemy);
	cards := cards + skeleton_runner(count:skeleton_gold_uncommons, prefix:"UM", rarity:"uncommon", letter_list:blank_list_10, mana_list:mana_list_ally+mana_list_enemy);
	cards := cards + skeleton_runner(count:skeleton_gold_rares, prefix:"RM", rarity:"rare", letter_list:blank_list_10, mana_list:mana_list_ally+mana_list_enemy);
	cards := cards + skeleton_runner(count:skeleton_shard_commons, prefix:"CM", rarity:"common", letter_list:blank_list_5, mana_list:mana_list_shard);
	cards := cards + skeleton_runner(count:skeleton_shard_uncommons, prefix:"UM", rarity:"uncommon", letter_list:blank_list_5, mana_list:mana_list_shard);
	cards := cards + skeleton_runner(count:skeleton_shard_rares, prefix:"RM", rarity:"rare", letter_list:blank_list_5, mana_list:mana_list_shard);
	cards := cards + skeleton_runner(count:skeleton_wedge_commons, prefix:"CM", rarity:"common", letter_list:blank_list_5, mana_list:mana_list_wedge);
	cards := cards + skeleton_runner(count:skeleton_wedge_uncommons, prefix:"UM", rarity:"uncommon", letter_list:blank_list_5, mana_list:mana_list_wedge);
	cards := cards + skeleton_runner(count:skeleton_wedge_rares, prefix:"RM", rarity:"rare", letter_list:blank_list_5, mana_list:mana_list_wedge);
	for i from 1 to skeleton_artifact_commons do cards := cards + [new_card([name:"CA"+fill_len(i, lead:"0"), rarity:"common", super_type:"Artifact"])];
	for i from 1 to skeleton_artifact_uncommons do cards := cards + [new_card([name:"UA"+fill_len(i, lead:"0"), rarity:"uncommon", super_type:"Artifact"])];
	for i from 1 to skeleton_artifact_rares do cards := cards + [new_card([name:"RA"+fill_len(i, lead:"0"), rarity:"rare", super_type:"Artifact"])];
	for i from 1 to skeleton_land_commons do cards := cards + [new_card([name:"CL"+fill_len(i, lead:"0"), super_type:"Land", rarity:"common"])];
	for i from 1 to skeleton_land_uncommons do cards := cards + [new_card([name:"UL"+fill_len(i, lead:"0"), super_type:"Land", rarity:"uncommon"])];
	for i from 1 to skeleton_land_rares do cards := cards + [new_card([name:"RL"+fill_len(i, lead:"0"), super_type:"Land", rarity:"rare"])];
	for i from 1 to skeleton_blank_commons do cards := cards + [new_card([name:"CX"+fill_len(i, lead:"0"), rarity:"common"])];
	for i from 1 to skeleton_blank_uncommons do cards := cards + [new_card([name:"UX"+fill_len(i, lead:"0"), rarity:"uncommon"])];
	for i from 1 to skeleton_blank_rares do cards := cards + [new_card([name:"RX"+fill_len(i, lead:"0"), rarity:"rare"])];
	for i from 1 to skeleton_blank_mythics do cards := cards + [new_card([name:"MX"+fill_len(i, lead:"0"), rarity:"mythic rare"])];
	cards
}
skeleton_info := {
	trace("Set Skeleton Generator Help:"
	+"\nSet variables here to modify the Skeleton Add Cards script, for example 'skeleton_commons := 10'"
	+"\nCurrent variables:\n"
	+"skeleton_commons: " + skeleton_commons + " (of each color)\n"
	+"skeleton_uncommons: " +  skeleton_uncommons + " (of each color)\n"
	+"skeleton_rares: " + skeleton_rares + " (of each color)\n"
	+"skeleton_mythics: " + skeleton_mythics + " (of each color)\n"
	+"skeleton_gold_commons: " + skeleton_gold_commons + " (of each color pair)\n"
	+"skeleton_gold_uncommons: " + skeleton_gold_uncommons + " (of each color pair)\n"
	+"skeleton_gold_rares: " + skeleton_gold_rares + " (of each color pair)\n"
	+"skeleton_artifact_commons: " + skeleton_artifact_commons + "\n"
	+"skeleton_artifact_uncommons: " + skeleton_artifact_uncommons + "\n"
	+"skeleton_artifact_rares: " + skeleton_artifact_rares + "\n"
	+"skeleton_land_commons: " + skeleton_land_commons + "\n"
	+"skeleton_land_uncommons: " + skeleton_land_uncommons + "\n"
	+"skeleton_land_rares: " + skeleton_land_rares + "\n"
	+"skeleton_blank_commons: " + skeleton_blank_commons + "\n"
	+"skeleton_blank_uncommons: " + skeleton_blank_uncommons + "\n"
	+"skeleton_blank_rares: " + skeleton_blank_rares + "\n"
	+"skeleton_blank_mythics: " + skeleton_blank_mythics + "\n"
	+"skeleton_shard_commons: " + skeleton_shard_commons + "\n"
	+"skeleton_shard_uncommons: " + skeleton_shard_uncommons + "\n"
	+"skeleton_shard_rares: " + skeleton_shard_rares + "\n"
	+"skeleton_wedge_commons: " + skeleton_wedge_commons + "\n"
	+"skeleton_wedge_uncommons: " + skeleton_wedge_uncommons + "\n"
	+"skeleton_wedge_rares: " + skeleton_wedge_rares)
}
############################################################## Hashes
#### return a new Hash
hash_new := {
	len := min(length(keys), length(values)) - 1
	if keys != [] and len >= 0
		then keys := for x from 0 to len do [[keys[x]]]
	else keys := []
	if values != [] and len >= 0
		then values := for x from 0 to len do [[values[x]]]
	else values := []
	[
		keys: keys,
		values: values
	]
}@(keys:[], values:[])
#### check if hash already has this key
hash_includes := {
	if value != nil then
		key := value;
	if keys != [] and key != nil then keys := keys + [key]
	if input == nil
		then false
	else if keys != []
		then hash_nest(input, key_chain:keys, func:hash_includes, update:false, value:key)
	else if position(of:[key] in:input.keys) < 0
		then false 
	else true
}@(key:nil, keys:[], value:nil)
#### add key:value to hash unless key exists
hash_create := {
	if input == [] then input := hash_new()
	if keys != [] and key != nil then keys := keys + [key]
	if keys != []
		then hash_nest(input, key_chain:keys, func:hash_create, value:value)
	else if hash_includes(input, key:key)
		then input
	else hash_push(input, key:key, value:value)
}@(input:[], keys:[], key:nil)
#### add a key:value even if the key exists
hash_push := {
	if keys != [] and key != nil then keys := keys + [key]
	if input == nil
		then []
	else if keys != []
		then hash_nest(input, key_chain:keys, func:hash_push, value:value)
	else [
		keys: input.keys + [[key]],
		values: input.values + [[value]]
	]
}@(keys:[], key:nil)
#### read value from a key
hash_read := {
	if value != nil then
		key := value;
	if keys != [] and key != nil then keys := keys + [key]
	if input == nil
		then []
	else if keys != []
		then hash_nest(input, key_chain:keys, func:hash_read, value:value, update:false)
	else (
		posi := position(of:[key] in:input.keys)
		if posi < 0
			then nil
		else input.values[posi][0]
	)
}@(keys:[], value:nil, key:nil)
#### add key:value to hash. if key already exists, overwrite
hash_update := {
	if keys != [] and key != nil then keys := keys + [key]
	if input == nil
		then []
	else if keys != []
		then hash_nest(input, key_chain:keys, func:hash_update, value:value)
	else (
		posi := position(of:[key] in:input.keys)
		if posi < 0 then hash_create(input, key:key, value:value)
		else [
			keys: (for k from 0 to length(input.keys)-1 do if k == posi then [[key]] else [input.keys[k]]),
			values: (for v from 0 to length(input.values)-1 do if v == posi then [[value]] else [input.values[v]])
		]
	)
}@(keys:[], key:nil)
#### remove a key:value from the hash
hash_delete := {
	if keys != [] and key != nil then keys := keys + [key]
	if input == nil
		then []
	else if keys != []
		then hash_nest(input, key_chain:keys, func:hash_delete, value:value)
	else (
		posi := position(of:[key] in:input.keys)
		if posi < 0 then input
		else [
			keys: (for k from 0 to length(input.keys)-1 do if k == posi then [] else [input.keys[k]]),
			values: (for v from 0 to length(input.values)-1 do if v == posi then [] else [input.values[v]])
		]
	)
}@(keys:[], key:nil)
#### get keys of the hash, optionally only those with a particular value
hash_keys := {
	if keys != [] and key != nil then keys := keys + [key]
	if value != nil then
		of := value;
	if input == nil
		then []
	else if keys != []
		then hash_nest(input, key_chain:keys, func:hash_keys, value:value, update:false)
	else (
		res := for i from 0 to length(input.keys)-1 do if of == nil or input.values[i] == [of] then input.keys[i] else nil
		if res == nil then [] else res
	)
}@(of:nil, keys:[], key:nil, value:nil)
hash_increment := {
	if keys != [] and key != nil then keys := keys + [key]
	if input == nil
		then []
	else if keys != []
		then hash_nest(input, key_chain:keys, func:hash_increment, value:value)
	else (
		initial := hash_read(input, key:key)
		if initial == nil then initial := 0
		hash_update(input, key:key, value:initial+value)
	)
}@(value:1, keys:[], key:nil)
hash_decrement := {
	hash_increment(input, key:key, keys:keys, value:(-1*value))
}@(value:1, keys:[], key:nil)
#### update a nested hash
hash_nest := {
	hash_chain := [input]
	for x from 0 to length(key_chain)-2 do (
		hash_chain := hash_chain + [hash_read(hash_chain[x], key:key_chain[x])]
	)
	len := length(hash_chain)-1
	value := func(hash_chain[length(hash_chain)-1], key:key_chain[length(key_chain)-1], value:value)
	if update then (
		len := len - 1
		for x from 0 to len do (
			ind := len - x
			value := hash_update(hash_chain[ind], key:key_chain[ind])
		)
	)
	value
}@(key_chain:[], func:hash_update, update:true)



#### load the user overwrites here, doing it in game overwrites this file instead
include file: custom_script