
############################################################## Statistics scripts 30-03-2023
############################################################## Blame GenevensiS for this

#Helper Functions
remove_flavor_statistic := replace@(match: "<i-flavor>.*?</i-flavor>", replace: "")
remove_reminder_statistic := replace@(match: "(<i>|<i-auto>).*?(</i>|</i-auto>)", replace: "")
keep_only_symbols_statistic := filter_text@(match: "<sym[^>]*>.+?</sym[^>]*>")
keep_only_symbols_list_statistic :=
{
	if input == [] then [] else (
	count := length(input) - 1
	for x from 0 to count do [to_text(keep_only_symbols_statistic(input[x]))])
}
contains_element_statistic :=
{
	contained := false
	count := length(input)-1
	for x from 0 to count do (if input[x] == element then contained := true;0)
	contained
}

# The casting cost
casting_cost_statistic :=
{
	cc_1 := trim(to_text(card.casting_cost))
	cc_2 := if check_2_statistic() then trim(to_text(card.casting_cost_2)) else ""
	cc_1 + (if cc_1 != "" and cc_2 != "" then "," else "") + cc_2
}

# The converted mana cost
mana_value_statistic :=
{
	if contains(card.shape, match: "split") or contains(card.shape, match: "aftermath") then cmc(card.casting_cost + " " + card.casting_cost_2) else cmc(card.casting_cost)
}

# The color combinations of the cards in the set.
color_statistic :=
{
	colors :=	if contains(card.shape, match: "split") or contains(card.shape, match: "aftermath") then	distil_colors_statistic(face_color_statistic(face: 1) + face_color_statistic(face: 2))
				else																						face_color_statistic(face: 1)		# shape == "adventure", "prototype", "leveler", "saga", "class", "flip", "double faced", "meld" or "normal"
	if colors == "" then "C" else colors
}
back_face_color_statistic :=
{
	colors :=	if contains(card.shape, match: "split") or contains(card.shape, match: "aftermath") then	"C"
				else																						face_color_statistic(face: 2)		# shape == "adventure", "prototype", "leveler", "saga", "class", "flip", "double faced", "meld" or "normal"
	if colors == "" then "C" else colors
}
all_faces_color_statistic :=
{
	colors := distil_colors_statistic(face_color_statistic(face: 1) + face_color_statistic(face: 2) + face_color_statistic(face: 3))
	if colors == "" then "C" else colors
}
face_color_statistic :=
{
	suffix :=	if face == 1 then ""				else if face == 2 then "_2"				else if face == 3 then "_3"		else ""
	identity :=	if face == 1 then has_identity()	else if face == 2 then has_identity_2()	else if face == 3 then false	else false
	
	colors := ""
	
	# Colors defined by a color indicator dot. I believe it takes precedence over everything.
	if identity then colors := distil_color_words_statistic(card["indicator" + suffix])
	if colors != "" then colors else (
	
	# Colors defined by english text on the card. Takes precedence over casting cost.
	colors :=	cda_to_color_statistic(remove_reminder_statistic(card["rule_text" + suffix]), suffix: suffix) +
				cda_to_color_statistic(remove_reminder_statistic(card["level_" + (1+4*(face-1)) + "_text"]), suffix: suffix)
	if face <= 2 then colors := colors + cda_to_color_statistic(remove_reminder_statistic(card["chapter_text" + suffix]), suffix: suffix)
	colors := distil_colors_statistic(colors)
	if colors != "" then colors else (
	
	# Colors defined by casting cost symbols.
	distil_colors_statistic(card["casting_cost" + suffix])))
}

# The commander color identities of the cards in the set.
color_identity_statistic :=
{
	texts := text_to_check_statistic()
	front_count := length(texts) - 1
	texts := texts + text_to_check_2_statistic()
	count := length(texts) - 1
	total_colors :=	for x from 0 to count do
	(
		# Colors defined by english text on the card.
		cda_to_color_statistic(remove_reminder_statistic(card[texts[x]]), suffix: (if x <= front_count then "" else "_2")) +
		
		# Colors defined by rule text symbols.
		keep_only_symbols_statistic(remove_reminder_statistic(card[texts[x]]))
	)
	total_colors :=	total_colors +
		
		# Colors defined by a color indicator dot.
		(if has_identity() then distil_color_words_statistic(card.indicator) else "") +
		(if has_identity_2() then distil_color_words_statistic(card.indicator_2) else "") +
	
		# Colors defined by casting cost symbols.
		card.casting_cost + " " +
		card.casting_cost_2
	
	total_colors := distil_colors_statistic(total_colors)
	if total_colors == "" then "C" else total_colors
}

cda_to_color_statistic :=
{
	if input == "" then "" else (
	
	text := to_text(input)
	
	if contains(text, match: "This card has no color.") then "C" else (
	if devoid_match_statistic(text) then "C" else (
	
	card_name := card["name" + suffix]
	trigger := color_cda_filter_statistic(text, in_context: "(" + regex_escape(card_name) + "|" + regex_escape(legend_filter(card_name)) + ") <match>\\.")
	if trigger == "" then "" else (
	
	if contains(trigger, match: "all colors") then "WUBRG" else (
	
	distil_color_words_statistic(trigger))))))
}
devoid_match_statistic := match@(match: "(\n|^|,| )[Dd]evoid(\n|$|,| |\\()")
color_cda_filter_statistic := filter_text@(match: "is (colorless|all colors|((blue|white|green|red|black)((,|,? and) (blue|white|green|red|black))*))")
distil_color_words_statistic :=
{
	colors := ""
	if contains(match: "colorless")	then colors := colors + "C"
	if contains(match: "white") 	then colors := colors + "W"
	if contains(match: "blue")  	then colors := colors + "U"
	if contains(match: "black") 	then colors := colors + "B"
	if contains(match: "red")   	then colors := colors + "R"
	if contains(match: "green") 	then colors := colors + "G"
	
	if length(colors) > 1 and colors.0 == "C" then substring(colors, begin: 1) else colors
}
distil_colors_statistic :=
{
	colors := ""
	if contains(match: "C")			then colors := colors + "C"
	if contains(match: "W")			then colors := colors + "W"
	if contains(match: "U")			then colors := colors + "U"
	if contains(match: "B")			then colors := colors + "B"
	if contains(match: "R")			then colors := colors + "R"
	if contains(match: "G")			then colors := colors + "G"
	
	if length(colors) > 1 and colors.0 == "C" then substring(colors, begin: 1) else colors
}
color_count_statistic :=
{
	colors := color_statistic()
	if colors == "C" then 0 else length(colors)
}
color_identity_count_statistic :=
{
	colors := color_identity_statistic()
	if colors == "C" then 0 else length(colors)
}

# Omniverse colors
omniverse_color_statistic :=
{
	if		chosen(choice: "land")											then	"land"
	else if chosen(choice: "multicolor")									then	"multicolor"
	else if count_chosen(choices: "white, blue, black, red, green") == 2
		and	chosen(choice: "artifact") 										then	"hybrid"		##hybrid artifacts would show as their first color
	else if chosen(choice: "hybrid")										then	"hybrid"
	else if (chosen(choice: "artifact")
		and not (		chosen(choice: "white")
					or	chosen(choice: "blue")
					or	chosen(choice: "black")
					or	chosen(choice: "red")
					or	chosen(choice: "green"))) 							then	"artifact"
	else if chosen(choice: "white")											then	"white"
	else if chosen(choice: "blue")											then	"blue"
	else if chosen(choice: "black")											then	"black"
	else if chosen(choice: "red")											then	"red"
	else if chosen(choice: "green")											then	"green"
	else if chosen(choice: "pink")											then	"pink"
	else if chosen(choice: "purple")										then	"purple"
	else if chosen(choice: "yellow")										then	"yellow"
	else if chosen(choice: "orange")										then	"orange"
	else if chosen(choice: "brown")											then	"brown"
	else																			input
}

# Count how many cards have one white devotion in the set. Repeat for two white devotion. Repeat for three, then four+, the again for other colors.
cc_colored_pips_statistic :=
{
	split_casting_cost := cmc_split(card.casting_cost)
	split_casting_cost_2 := if check_2_statistic() then cmc_split(card.casting_cost_2) else []
	
	symbol_aggregate_statistic(split_casting_cost, symbol: "W") +
	symbol_aggregate_statistic(split_casting_cost, symbol: "U") +
	symbol_aggregate_statistic(split_casting_cost, symbol: "B") +
	symbol_aggregate_statistic(split_casting_cost, symbol: "R") +
	symbol_aggregate_statistic(split_casting_cost, symbol: "G") +
	symbol_aggregate_statistic(split_casting_cost, symbol: "C") +
	symbol_aggregate_statistic(split_casting_cost_2, symbol: "W") +
	symbol_aggregate_statistic(split_casting_cost_2, symbol: "U") +
	symbol_aggregate_statistic(split_casting_cost_2, symbol: "B") +
	symbol_aggregate_statistic(split_casting_cost_2, symbol: "R") +
	symbol_aggregate_statistic(split_casting_cost_2, symbol: "G") +
	symbol_aggregate_statistic(split_casting_cost_2, symbol: "C")
}

# Count the total devotion of all cards in the set.
cc_colored_pips_totals_statistic :=
{
	split_casting_cost := cmc_split(card.casting_cost + (if check_2_statistic() then " " + card.casting_cost_2 else ""))
	
	symbol_count_list_statistic(split_casting_cost, symbol: "W") +
	symbol_count_list_statistic(split_casting_cost, symbol: "U") +
	symbol_count_list_statistic(split_casting_cost, symbol: "B") +
	symbol_count_list_statistic(split_casting_cost, symbol: "R") +
	symbol_count_list_statistic(split_casting_cost, symbol: "G") +
	symbol_count_list_statistic(split_casting_cost, symbol: "C")
}

# Count how many cards have one white pip in their ability costs. Repeat for two white pips. Repeat for three, then four+, then again for other colors.
ability_colored_pips_statistic :=
{
	costs := gather_ability_symbols_statistic()
	if costs == [] then "" else (
	count := length(costs) - 1
	for x from 0 to count do
	(
		split_text := cmc_split(costs[x])
	
		symbol_aggregate_statistic(split_text, symbol: "W") +
		symbol_aggregate_statistic(split_text, symbol: "U") +
		symbol_aggregate_statistic(split_text, symbol: "B") +
		symbol_aggregate_statistic(split_text, symbol: "R") +
		symbol_aggregate_statistic(split_text, symbol: "G") +
		symbol_aggregate_statistic(split_text, symbol: "C")
	))
}

# Count the total pips of all the abilities of all the cards in the set.
ability_colored_pips_totals_statistic :=
{
	costs := gather_ability_symbols_statistic()
	if costs == [] then "" else (
	count := length(costs) - 1
	for x from 0 to count do
	(
		split_text := cmc_split(costs[x])
	
		symbol_count_list_statistic(split_text, symbol: "W") +
		symbol_count_list_statistic(split_text, symbol: "U") +
		symbol_count_list_statistic(split_text, symbol: "B") +
		symbol_count_list_statistic(split_text, symbol: "R") +
		symbol_count_list_statistic(split_text, symbol: "G") +
		symbol_count_list_statistic(split_text, symbol: "C")
	))
}

colored_pips_statistic :=
{
	cc_colored_pips_statistic() + ability_colored_pips_statistic()
}

colored_pips_totals_statistic :=
{
	cc_colored_pips_totals_statistic() + ability_colored_pips_totals_statistic()
}

gather_ability_symbols_statistic :=
{
	texts := text_to_check_statistic() + if check_2_statistic() then text_to_check_2_statistic() else []
	count := length(texts) - 1
	for x from 0 to count do
	(
		text := remove_reminder_statistic(card[texts[x]])
		keep_only_symbols_list_statistic(activated_cost_filter_statistic(text)) +
		keep_only_symbols_list_statistic(triggered_cost_filter_statistic(text)) +
		keep_only_symbols_list_statistic(keyword_cost_filter_statistic(text))
	)
}

activated_cost_filter_statistic :=
	replace@(match: "<[^>]*:[^>]*>", replace: "") +												#Remove tags with : inside them
	break_text@(match: "(\n|^)[^(\n|^)]+?:")													#Keep only activated ability costs
triggered_cost_filter_statistic :=
	replace@(match: "<[^>]*\\.[^>]*>", replace: "") +											#Remove tags with . inside them
	break_text@(match:" pay .+?(\\.|,| )", in_context: "(When|At).+?may<match> ?(If|if|to) ")	#Keep only triggered ability costs
keyword_cost_filter_statistic :=
	break_text@(match: "<param[^>]*>.+?</param[^>]*>")											#Keep only keyword parameters

symbol_aggregate_statistic :=
{
	if input == [] then "" else (
	
	count := for each sym in input do (if contains(sym, match: symbol) then 1 else 0)
	if count == 0 then		""
	else if count == 1 then (symbol + ",")
	else if count == 2 then (symbol + symbol + ",")
	else if count == 3 then (symbol + symbol + symbol + ",")
	else					(symbol + symbol + symbol + symbol + "+,"))
}
symbol_count_list_statistic :=
{
	list := for each sym in input do (if contains(sym, match: symbol) then (symbol + ",") else "")
	if list == nil then "" else list
}

# How many colored pips does each casting cost have.
cc_colored_pips_count_statistic :=
{
	check_1 := card.casting_cost != ""
	check_2 := check_2_statistic() and card.casting_cost_2 != ""
	(if check_1 then colored_pips_count_statistic(cmc_split(card.casting_cost)) else "") +
	(if check_2 then (if check_1 then "," else "") + colored_pips_count_statistic(cmc_split(card.casting_cost_2)) else "")
}

# How many colored pips does each ability cost have.
ability_colored_pips_count_statistic :=
{
	costs := gather_ability_symbols_statistic()
	if costs == [] then "" else (
	count := length(costs) - 1
	for x from 0 to count do
	(
		colored_pips_count_statistic(cmc_split(costs[x])) + (if x < count then "," else "")
	))
}

# How many colored pips does each cost have.
colored_pips_count_totals_statistic :=
{
	cc_count := cc_colored_pips_count_statistic()
	ability_count := ability_colored_pips_count_statistic()
	cc_count + if ability_count == nil then "" else "," + ability_count
}

colored_pips_count_statistic :=
{
	count := for each sym in input do (if is_colored_mana(sym) then 1 else 0)
	if count == nil then "0"
	else if count >= 8 then "8+"
	else count
}

# Count how many cards can produce white mana in the set. Repeat for other colors.
mana_production_list_statistic :=
{
	result_1 :=	if		check_type == "land" and not contains(card.super_type, match: "Land") and not contains(card.super_type, match: "land")		then	""
				else if	check_type == "nonland" and (contains(card.super_type, match: "Land") or contains(card.super_type, match: "land"))			then	""
				else																																		face_mana_production_list_statistic(texts: text_to_check_statistic(card: card), card: card, sub: card.sub_type)
	result_2 :=	if not check_2_statistic(card: card)																								then	""
				else if	check_type == "land" and not contains(card.super_type_2, match: "Land") and not contains(card.super_type_2, match: "land")	then	""
				else if	check_type == "nonland" and (contains(card.super_type_2, match: "Land") or contains(card.super_type_2, match: "land"))		then	""
				else																																		face_mana_production_list_statistic(texts: text_to_check_2_statistic(card: card), card: card, sub: card.sub_type_2)
	substring(result_1 + result_2, begin: 1)
}
face_mana_production_list_statistic :=
{
	can_C :=		if can_add_C_statistic(texts, card: card)				then ",C"		else ""
	can_Any :=		if can_add_any_color_statistic(texts, card: card)		then ",Any"		else ""
	can_Chosen :=	if can_add_chosen_color_statistic(texts, card: card)	then ",Chosen"	else ""
	if can_Any != "" or can_Chosen != "" then (can_Any + can_Chosen + can_C) else (
	
	(if can_add_W_statistic(texts, card: card, sub: sub) then ",W" else "") +
	(if can_add_U_statistic(texts, card: card, sub: sub) then ",U" else "") +
	(if can_add_B_statistic(texts, card: card, sub: sub) then ",B" else "") +
	(if can_add_R_statistic(texts, card: card, sub: sub) then ",R" else "") +
	(if can_add_G_statistic(texts, card: card, sub: sub) then ",G" else "") +
	can_C)
}

match_add_W_statistic					:= match@(match: "(—| |^)[Aa]dd [^(\n|^)]*<sym[^>]*>[^<]*W[^<]*<")
match_add_U_statistic					:= match@(match: "(—| |^)[Aa]dd [^(\n|^)]*<sym[^>]*>[^<]*U[^<]*<")
match_add_B_statistic					:= match@(match: "(—| |^)[Aa]dd [^(\n|^)]*<sym[^>]*>[^<]*B[^<]*<")
match_add_R_statistic					:= match@(match: "(—| |^)[Aa]dd [^(\n|^)]*<sym[^>]*>[^<]*R[^<]*<")
match_add_G_statistic					:= match@(match: "(—| |^)[Aa]dd [^(\n|^)]*<sym[^>]*>[^<]*G[^<]*<")
match_add_C_statistic					:= match@(match: "(—| |^)[Aa]dd [^(\n|^)]*<sym[^>]*>[^<]*C[^<]*<")
match_add_any_color_statistic			:= match@(match: "(—| |^)[Aa]dd [^(\n|^)]*mana ((of any [^(\n|^)]*)|(in any combination of ))color")
match_add_chosen_color_statistic		:= match@(match: "(—| |^)[Aa]dd [^(\n|^)]*mana of the chosen color")
match_add_chosen_color_bis_statistic	:= match@(match: "(—| |^)[Cc]hoose a color[^(\n|^)]+ [Aa]dd [^(\n|^)]*mana of that color")

can_add_W_statistic :=
{
	if contains(sub, match: "Plains")
	or contains(sub, match: "plains")
	then true else (
	
	count := length(input) - 1
	result := false
	for x from 0 to count do (if match_add_W_statistic(remove_reminder_statistic(card[input[x]])) then (result := true; 0) else 0)
	result)
}
can_add_U_statistic :=
{
	if contains(sub, match: "Island")
	or contains(sub, match: "island")
	then true else (
	
	count := length(input) - 1
	result := false
	for x from 0 to count do (if match_add_U_statistic(remove_reminder_statistic(card[input[x]])) then (result := true; 0) else 0)
	result)
}
can_add_B_statistic :=
{
	if contains(sub, match: "Swamp")
	or contains(sub, match: "swamp")
	then true else (
	
	count := length(input) - 1
	result := false
	for x from 0 to count do (if match_add_B_statistic(remove_reminder_statistic(card[input[x]])) then (result := true; 0) else 0)
	result)
}
can_add_R_statistic :=
{
	if contains(sub, match: "Mountain")
	or contains(sub, match: "mountain")
	then true else (
	
	count := length(input) - 1
	result := false
	for x from 0 to count do (if match_add_R_statistic(remove_reminder_statistic(card[input[x]])) then (result := true; 0) else 0)
	result)
}
can_add_G_statistic :=
{
	if contains(sub, match: "Forest")
	or contains(sub, match: "forest")
	then true else (
	
	count := length(input) - 1
	result := false
	for x from 0 to count do (if match_add_G_statistic(remove_reminder_statistic(card[input[x]])) then (result := true; 0) else 0)
	result)
}
can_add_C_statistic :=
{
	count := length(input) - 1
	result := false
	for x from 0 to count do (if match_add_C_statistic(remove_reminder_statistic(card[input[x]])) then (result := true; 0) else 0)
	result
}
can_add_any_color_statistic :=
{
	count := length(input) - 1
	result := false
	for x from 0 to count do (if match_add_any_color_statistic(remove_reminder_statistic(card[input[x]])) then (result := true; 0) else 0)
	result
}
can_add_chosen_color_statistic :=
{
	count := length(input) - 1
	result := false
	for x from 0 to count do
	(
		text := remove_reminder_statistic(card[input[x]])
		if match_add_chosen_color_statistic(text) or match_add_chosen_color_bis_statistic(text) then (result := true; 0)
		else 0
	)
	result
}

# Word counting
total_word_count_statistic :=
{
	texts := text_to_check_statistic() + if check_2_statistic() then text_to_check_2_statistic() else []
	count := length(texts) - 1
	for x from 0 to count do
	(
		text := trim(to_text(card[texts[x]]))
		if text == "" or text == "​" then 0 else word_count(text)		# There is a zero width space in the second ""
	)
}
#total_line_count_statistic :=
#{
#	texts := text_to_check_statistic() + if check_2_statistic() then text_to_check_2_statistic() else []
#	count := length(texts) - 1
#	for x from 0 to count do
#	(
#		if card[texts[x]] != "" then card_style[texts[x]].content_lines else 0		# card_style does not initialize correctly when loading the set, so this is unreliable atm.
#	)
#}
total_paragraph_count_statistic :=
{
	texts := text_to_check_statistic() + if check_2_statistic() then text_to_check_2_statistic() else []
	count := length(texts) - 1
	for x from 0 to count do
	(
		text := trim(card[texts[x]])
		if text == "" or text == "​" then 0 else 1 + line_count_statistic(text) - soft_line_count_statistic(text)		# There is a zero width space in the second ""
	)
}
line_count_statistic := break_text@(match: "\\n") + length
soft_line_count_statistic := break_text@(match: "<soft-line>") + length

# Artists
illustrator_statistic :=
{
	artist_1 := trim(replace_full_width_commas_statistic(card.illustrator))
	artist_2 := trim(replace_full_width_commas_statistic(card.illustrator_2))
	result := artist_1 + (if check_2_statistic() and artist_2 != "" and artist_2 != artist_1 then "," + artist_2 else "")
	if result == "" then " No Artist" else if result.0 == "," then substring(result, begin: 1) else result
}

# Card notes
split_notes_words_statistic := replace@(match: " *(,|\\.|;|(?=!)|\\n)?  *", replace: ",")
split_notes_clauses_statistic :=
{
	regex := if set.card_notes_clauses_split == "" then " *(\\.|\\n|;|,|(?=!)) *" else set.card_notes_clauses_split
	regex := replace_full_width_commas_statistic(regex)
	notes := replace_full_width_commas_statistic(card.notes)
	result := replace(notes, match: regex, replace: ",")
	result := clean_commas_statistic(result)
	result
}
clean_commas_statistic := replace@(match: ",,", replace: ",") + replace@(match: "^,", replace: "") + replace@(match: ",$", replace: "")
replace_full_width_commas_statistic := replace@(match:",", replace: "，")

# Hypergeometric probability of hitting every single land drop.
land_drop_hit_percentage_statistic :=
{
	if card != set.cards.0 then "" else (
	set_count := length(set.cards)-1
	cards := for x from 0 to set_count do (if trim_from_draw_statistic(card: set.cards[x]) then [] else [set.cards[x]])
	card_count := length(cards)
	if card_count <= start then "Not enough non-commander non-promo cards to draw an opening hand. Add normal cards." else (
	
	land_count := for each c in cards do
	(
		if		contains(c.super_type, match: "Land")
			or	contains(c.super_type, match: "land")
			or	(check_2_statistic(card: c) and (contains(c.super_type_2, match: "Land") or contains(c.super_type_2, match: "land")))
		then 1
		else 0
	)
	if land_count == 0 then "No lands found. 0% chance to hit land drops." else (
	
	max_turns := min(10, card_count-start)
	probability_per_turn := for t from 1 to max_turns do [100*hypergeometric_sum_statistic(population: card_count, successes_in_population: land_count, sample: start+t, turn: t)]
	probability_string_per_turn := for t from 1 to max_turns do
	(
		split := split_text(match: "\\.", to_string(probability_per_turn[t-1]))
		number := split[0]
		digit := if (split[1] or else "") == "" then "0" else split[1].0
		["Turn " + t + " — " + number + "." + digit + "%"]
	)
	result := for t from 1 to max_turns do
	(
		count := to_int(probability_per_turn[t-1])
		if count == 0 then count := 1
		for x from 1 to count do ("," + probability_string_per_turn[t-1])
	)
	substring(result, begin: 1))))
}
hypergeometric_sum_statistic :=
{
	max_succes := min(successes_in_population, sample)
	for x from turn to max_succes do hypergeometric_formula_statistic(population: population, successes_in_population: successes_in_population, sample: sample, successes_in_sample: x)
}
hypergeometric_formula_statistic :=
{
	n_choose_k_statistic(n: successes_in_population, k: successes_in_sample) * n_choose_k_statistic(n: population - successes_in_population, k: sample - successes_in_sample) / n_choose_k_statistic(n: population, k: sample)
}
n_choose_k_statistic :=
{
	accumulator := 1.0;
	for x from 0 to k-1 do (accumulator := accumulator * to_real(n-x) / to_real(k-x))
	accumulator
}

# Average number of cards in an opening hand
average_opening_hand_statistic :=
{
	averages := split_text(set.global_variable_average_opening_hand, match: ";")
	if length(averages) != 9 then set.global_variable_average_opening_hand else (
	types :=	[has_type_statistic("Land")] +
				(if has_type_statistic("Artifact") then (if mana_production_list_statistic(check_type: "nonland") == "" then [false, true] else [true, false]) else [false, false]) +
				[has_type_statistic("Enchantment")] +
				[has_type_statistic("Planeswalker")] +
				[has_type_statistic("Battle")] +
				[has_type_statistic("Creature")] +
				[has_type_statistic("Sorcery")] +
				[has_type_statistic("Instant")]
	result := for x from 0 to 8 do (if types[x] then averages[x] else "")
	substring(result, begin: 1))
}
global_variable_average_opening_hand_statistic :=
{
	set_count := length(set.cards)-1
	if set_count < 0 then "" else (
	cards := for x from 0 to set_count do (if trim_from_draw_statistic(card: set.cards[x]) then [] else [set.cards[x]])
	card_count := length(cards)-1
	card_count_real := to_number(card_count+1)
	if card_count < 6 then "Not enough non-commander non-promo cards to draw an opening hand. Add normal cards." else (
	
	lands := 0
	manaartifacts := 0
	nonmanaartifacts := 0
	enchantments := 0
	planeswalkers := 0
	battles := 0
	creatures := 0
	sorceries := 0
	instants := 0
	
	for x from 0 to card_count do
	(
		c := cards[x]
		if has_type_statistic(card:c, "Land") then lands := lands + 1
		if has_type_statistic(card:c, "Artifact") then (if mana_production_list_statistic(card: c, check_type: "nonland") == "" then (nonmanaartifacts := nonmanaartifacts + 1) else (manaartifacts := manaartifacts + 1))
		if has_type_statistic(card:c, "Enchantment") then enchantments := enchantments + 1
		if has_type_statistic(card:c, "Planeswalker") then planeswalkers := planeswalkers + 1
		if has_type_statistic(card:c, "Battle") then battles := battles + 1
		if has_type_statistic(card:c, "Creature") then creatures := creatures + 1
		if has_type_statistic(card:c, "Sorcery") then sorceries := sorceries + 1
		if has_type_statistic(card:c, "Instant") then instants := instants + 1
	)
	
	lands_average := format_average_statistic(7.0 * to_number(lands) / card_count_real)
	manaartifacts_average := format_average_statistic(7.0 * to_number(manaartifacts) / card_count_real)
	nonmanaartifacts_average := format_average_statistic(7.0 * to_number(nonmanaartifacts) / card_count_real)
	enchantments_average := format_average_statistic(7.0 * to_number(enchantments) / card_count_real)
	planeswalkers_average := format_average_statistic(7.0 * to_number(planeswalkers) / card_count_real)
	battles_average := format_average_statistic(7.0 * to_number(battles) / card_count_real)
	creatures_average := format_average_statistic(7.0 * to_number(creatures) / card_count_real)
	sorceries_average := format_average_statistic(7.0 * to_number(sorceries) / card_count_real)
	instants_average := format_average_statistic(7.0 * to_number(instants) / card_count_real)
	
	",​Lands — " + lands_average +
	";,​​Mana Artifacts — " + manaartifacts_average +
	";,​​​Non-Mana Artifacts — " + nonmanaartifacts_average +
	";,​​​​Enchantments — " + enchantments_average +
	";,​​​​​Planeswalkers — " + planeswalkers_average +
	";,​​​​​Battles — " + battles_average +
	";,​​​​​​Creatures — " + creatures_average +
	";,​​​​​​​Sorceries — " + sorceries_average +
	";,​​​​​​​​Instants — " + instants_average))
}
format_average_statistic :=
{
	split := split_text(match: "\\.", to_string(input))
	number := split[0]
	digits := if (split[1] or else "") == "" then "00" else split[1]
	if length(digits) == 1 then digits := digits + "0"
	else if length(digits) > 2 then digits := substring(digits, end:2)
	number + "." + digits
}

# Rarities.
rarity_statistic :=
{
	if		card.shape == "Token" or card.shape == "token" or contains(card.super_type, match: "Token") or contains(card.super_type, match: "token") then "token"
	else if	(contains(card.super_type, match: "Land") or contains(card.super_type, match: "land")) and (contains(card.super_type, match: "Basic") or contains(card.super_type, match: "basic")) then "basic land"	#There is an EN space in this string
	else if	card.rarity == "basic land" then "basic land"	#There is an EN space in this string
	else if	card.rarity == "mythic rare" then "mythic rare"		#There is an EN space in this string
	else card.rarity
}

# Watermarks
watermark_statistic :=
{
	watermark_1 := trim(to_text(card.watermark))
	watermark_2 := if check_2_statistic() then trim(to_text(card.watermark_2)) else ""
	watermark_1 + (if watermark_1 != "" and watermark_2 != "" then "," else "") + watermark_2
}
stamp_statistic :=
{
	stamp_1 := trim(to_text(card.card_stamp))
	stamp_2 := if check_2_statistic() then trim(to_text(card.card_stamp_2)) else ""
	stamp_1 + (if stamp_1 != "" and stamp_2 != "" then "," else "") + stamp_2
}
symbol_statistic :=
{
	symbol_1 := trim(to_text(card.card_symbol))
	symbol_2 := if check_2_statistic() then trim(to_text(card.card_symbol_2)) else ""
	symbol_1 + (if symbol_1 != "" and symbol_2 != "" then "," else "") + symbol_2
}

# Count how many creatures, non-creature permanents, and non-permanents are in the set.
permanent_statistic :=
{
	result := face_permanent_statistic(to_text(card.super_type)) + (if check_2_statistic() then face_permanent_statistic(to_text(card.super_type_2)) else "")
	substring(result, begin: 1)
}
face_permanent_statistic :=
{
	if		input == ""																			then	""
	else if	contains(input, match: "Creature")		or contains(input, match: "creature")		then	",​Creature"
	else if	contains(input, match: "Artifact")		or contains(input, match: "artifact")
	or		contains(input, match: "Enchantment")	or contains(input, match: "enchantment")
	or		contains(input, match: "Land")			or contains(input, match: "land")
	or		contains(input, match: "Hero")			or contains(input, match: "hero")
	or		contains(input, match: "Planeswalker")	or contains(input, match: "planeswalker")
	or		contains(input, match: "Battle")		or contains(input, match: "battle")			then	",​​Permanent"
	else if	contains(input, match: "Sorcery")		or contains(input, match: "sorcery")
	or		contains(input, match: "Instant")		or contains(input, match: "instant")		then	",​​​Non Permanent"
	else if	contains(input, match: "Emblem")		or contains(input, match: "emblem")
	or		contains(input, match: "Conspiracy")	or contains(input, match: "conspiracy")
	or		contains(input, match: "Dungeon")		or contains(input, match: "dungeon")
	or		contains(input, match: "Phenomenon")	or contains(input, match: "phenomenon")
	or		match_plane_statistic(input)
	or		contains(input, match: "Scheme")		or contains(input, match: "scheme")
	or		contains(input, match: "Vanguard")		or contains(input, match: "vanguard")		then	",​​​​Command Zone"
	else																								",​​​​​Unknown"
}

# Types.
supertype_statistic :=
{
	result := face_supertype_statistic(card.super_type) + (if check_2_statistic() then face_supertype_statistic(card.super_type_2) else "")
	substring(result, begin: 1)
}
face_supertype_statistic :=
{
	supertypes := split_space_statistic(to_text(input))
	count := length(supertypes) - 1
	custom_supertypes := custom_supertype_statistic()
	for x from 0 to count do
	(
		type := supertypes[x]
		if		type == "Basic"		or type == "basic"							then	",​Basic"			# There is a zero width space after the comma in ",Basic" so that it always appears first.
		else if	type == "Snow"		or type == "snow"							then	",​​Snow"				# There are two zero width spaces after the comma in ",Snow" so that it always appears second.
		else if	type == "World"		or type == "world"							then	",​​​World"			# Etc...
		else if	type == "Legendary"	or type == "legendary"						then	",​​​​Legendary"
		else if	type == "Token"		or type == "token"							then	",​​​​​Token"
		else if	type == "Ongoing"	or type == "ongoing"						then	",​​​​​​Ongoing"
		else if	type == "Elite"		or type == "elite"							then	",​​​​​​​Elite"
		else if	type == "Host"		or type == "host"							then	",​​​​​​​​Host"
		else if contains_element_statistic(custom_supertypes, element: type)	then	("," + type)
		else																			""
	)
}

combined_type_statistic :=
{
	type_1 := trim(to_text(card.super_type))
	type_2 := if check_2_statistic() then trim(to_text(card.super_type_2)) else ""
	type_1 + (if type_1 != "" and type_2 != "" then "," else "") + type_2
}

#type_statistic :=
#{
#	result := face_type_statistic(card.super_type) + (if check_2_statistic() then face_type_statistic(card.super_type_2) else "")
#	substring(result, begin: 1)
#}
#face_type_statistic :=
#{
#	(if contains(input, match: "Land")			or contains(input, match: "land")			then ",Land" else "") +
#	(if contains(input, match: "Creature")		or contains(input, match: "creature")		then ",Creature" else "") +
#	(if contains(input, match: "Artifact")		or contains(input, match: "artifact")		then ",Artifact" else "") +
#	(if contains(input, match: "Enchantment")	or contains(input, match: "enchantment")	then ",Enchantment" else "") +
#	(if contains(input, match: "Planeswalker")	or contains(input, match: "planeswalker")	then ",Planeswalker" else "") +
#	(if contains(input, match: "Battle")		or contains(input, match: "battle")			then ",Battle" else "") +
#	(if contains(input, match: "Sorcery")		or contains(input, match: "sorcery")		then ",Sorcery" else "") +
#	(if contains(input, match: "Instant")		or contains(input, match: "instant")		then ",Instant" else "")
#}

type_extended_statistic :=
{
	result := face_type_extended_statistic(card.super_type) + (if check_2_statistic() then face_type_extended_statistic(card.super_type_2) else "")
	substring(result, begin: 1)
}
face_type_extended_statistic :=
{
	old_types := split_space_statistic(to_text(input))
	count := length(old_types)-1
	custom_supertypes := custom_supertype_statistic()
	new_types := for x from 0 to count do
	(
		type := old_types[x]
		if		type == ""														then	""
		else if	contains_element_statistic(custom_supertypes, element: type)	then	""
		else if	is_canon_supertype_statistic(type)								then	""
		else if	type == "Land"			or type == "land"						then	",​Land"				# There is a zero width space after the comma in ",Land" so that it always appears after custom types.
		else if	type == "Creature"		or type == "creature"					then	",​​Creature"			# There are two zero width spaces after the comma in ",Creature" so that it always appears after lands.
		else if	type == "Tribal"		or type == "tribal"						then	",​​​Kindred"			# There are three zero width spaces after the comma in ",Kindred", etc...
		else if	type == "Kindred"		or type == "kindred"					then	",​​​Kindred"
		else if	type == "Artifact"		or type == "artifact"					then	",​​​​Artifact"
		else if	type == "Enchantment"	or type == "enchantment"				then	",​​​​​Enchantment"
		else if	type == "Emblem"		or type == "emblem"						then	",​​​​​​Emblem"
		else if	type == "Planeswalker"	or type == "planeswalker"				then	",​​​​​​​Planeswalker"
		else if	type == "Battle"		or type == "battle"						then	",​​​​​​​​Battle"
		else if	type == "Sorcery"		or type == "sorcery"					then	",​​​​​​​​​Sorcery"
		else if	type == "Instant"		or type == "instant"					then	",​​​​​​​​​​Instant"
		else if	type == "Conspiracy"	or type == "conspiracy"					then	",​​​​​​​​​​​Conspiracy"
		else if	type == "Dungeon"		or type == "dungeon"					then	",​​​​​​​​​​​​Dungeon"
		else if	type == "Hero"			or type == "hero"						then	",​​​​​​​​​​​​​Hero"
		else if	type == "Phenomenon"	or type == "phenomenon"					then	",​​​​​​​​​​​​​​Phenomenon"
		else if	match_plane_statistic(type)										then	",​​​​​​​​​​​​​​​Plane"
		else if	type == "Scheme"		or type == "scheme"						then	",​​​​​​​​​​​​​​​​Scheme"
		else if	type == "Vanguard"		or type == "vanguard"					then	",​​​​​​​​​​​​​​​​​Vanguard"
		else																			("," + type)
	)
	if new_types == nil then "" else new_types
}
is_canon_supertype_statistic :=
{
		input == "Legendary"	or input == "legendary"
	or	input == "Basic"		or input == "basic"
	or	input == "Snow"			or input == "snow"
	or	input == "Token"		or input == "token"
	or	input == "World"		or input == "world"
	or	input == "Ongoing"		or input == "ongoing"
	or	input == "Elite"		or input == "elite"
	or	input == "Host"			or input == "host"
}
custom_supertype_statistic := split_text@(input: set.custom_super_types, match: " ?, ?")
has_type_statistic :=
{
	lower_input := to_lower(input)
	contains(card.type, match: input) or
	contains(card.type, match: lower_input) or
	(check_2_statistic(card:card) and (contains(card.type_2, match: input) or contains(card.type_2, match: lower_input)))
}
match_plane_statistic := match@(match: "(?i)Plane(?!swalker)")

combined_subtype_statistic :=
{
	type_1 := trim(to_text(card.sub_type))
	type_2 := if check_2_statistic() then trim(to_text(card.sub_type_2)) else ""
	type_1 + (if type_1 != "" and type_2 != "" then "," else "") + type_2
}

detect_custom_creature_subtypes_statistic :=
{
	set.custom_super_types		#re-run this script when set.custom_super_types changes
	result := []
	set_count := length(set.cards)-1
	for x from 0 to set_count do
	(
		c := set.cards[x]
		subtypes :=	face_detect_custom_creature_subtypes_statistic(super: c.super_type, sub: c.sub_type) +
					face_detect_custom_creature_subtypes_statistic(super: c.super_type_2, sub: c.sub_type_2)		# Don't use check_2_statistic() here
		count := length(subtypes)-1
		for y from 0 to count do
		(
			subtype := subtypes[y]
			if not contains_element_statistic(result, element: subtype) and not contains(creature_subtypes_statistic, match: subtype + ";") then result := result + [subtype]
		)
	)
	result := sort_list(result)
	count := length(result)-2
	if count == -2 then "" else (for x from 0 to count do result[x] + ", ") + result[count+1]
}
face_detect_custom_creature_subtypes_statistic :=
{
	types := remove_supertypes_statistic(super)
	if types == "Creature" or types == "creature" then split_space_statistic(clean_subtypes_statistic(to_text(sub))) else []
}
remove_legendary_statistic := replace@(match: "[Ll]egendary", replace: "")
remove_basic_statistic := replace@(match: "[Bb]asic", replace: "")
remove_snow_statistic := replace@(match: "[Ss]now", replace: "")
remove_token_statistic := replace@(match: "[Tt]oken", replace: "")
remove_world_statistic := replace@(match: "[Ww]orld", replace: "")
remove_ongoing_statistic := replace@(match: "[Oo]ngoing", replace: "")
remove_elite_statistic := replace@(match: "[Ee]lite", replace: "")
remove_host_statistic := replace@(match: "[Hh]ost", replace: "")
remove_custom_supertypes_statistic :=
{
	custom_supertypes := custom_supertype_statistic()
	count := length(custom_supertypes)-1
	for x from 0 to count do input := replace(input, match: custom_supertypes[x], replace: "")
	input
}
remove_supertypes_statistic :=	to_text +
								remove_legendary_statistic +
								remove_basic_statistic +
								remove_snow_statistic +
								remove_token_statistic +
								remove_world_statistic +
								remove_ongoing_statistic +
								remove_elite_statistic +
								remove_host_statistic +
								remove_custom_supertypes_statistic +
								trim

creature_subtype_statistic :=
{
	canon := creature_subtypes_statistic
	custom := replace_commas_statistic(set.custom_creature_races) + ";" + replace_commas_statistic(set.custom_creature_classes) + ";"
	excluded := ""
	result :=	(face_creature_subtype_statistic(sub: card.sub_type, super: card.super_type, canon_subtypes: canon, custom_subtypes: custom, excluded_subtypes: excluded)) +
				(if check_2_statistic() then face_creature_subtype_statistic(sub: card.sub_type_2, super: card.super_type_2, canon_subtypes: canon, custom_subtypes: custom, excluded_subtypes: excluded) else "")
	substring(result, begin: 1)
}
creature_race_statistic :=
{
	canon := creature_races_statistic
	custom := replace_commas_statistic(set.custom_creature_races) + ";"
	excluded := replace_commas_statistic(set.custom_creature_classes) + ";"
	result :=	(face_creature_subtype_statistic(sub: card.sub_type, super: card.super_type, canon_subtypes: canon, custom_subtypes: custom, excluded_subtypes: excluded)) +
				(if check_2_statistic() then face_creature_subtype_statistic(sub: card.sub_type_2, super: card.super_type_2, canon_subtypes: canon, custom_subtypes: custom, excluded_subtypes: excluded) else "")
	substring(result, begin: 1)
}
creature_class_statistic :=
{
	canon := creature_classes_statistic
	custom := replace_commas_statistic(set.custom_creature_classes) + ";"
	excluded := replace_commas_statistic(set.custom_creature_races) + ";"
	result :=	(face_creature_subtype_statistic(sub: card.sub_type, super: card.super_type, canon_subtypes: canon, custom_subtypes: custom, excluded_subtypes: excluded)) +
				(if check_2_statistic() then face_creature_subtype_statistic(sub: card.sub_type_2, super: card.super_type_2, canon_subtypes: canon, custom_subtypes: custom, excluded_subtypes: excluded) else "")
	substring(result, begin: 1)
}

face_creature_subtype_statistic :=
{
	old_subtypes := to_text(sub)
	if old_subtypes == "" then "" else (
	
	old_subtypes := clean_subtypes_statistic(old_subtypes)
	split := split_space_statistic(old_subtypes)
	count := length(split)-1
	new_subtypes := for x from 0 to count do
	(
		subtype := split[x]
		subtypesc := subtype + ";"
		if		subtype == ""
			or	contains(excluded_subtypes, match: subtypesc)	then	""
		else if	contains(canon_subtypes, match: subtypesc)
			or	contains(custom_subtypes, match: subtypesc)		then	("," + subtype)
		else															""
	)
	if new_subtypes == nil then "" else new_subtypes)
}

noncreature_subtype_statistic :=
{
	result := face_noncreature_subtype_statistic(sub: card.sub_type, super: card.super_type) + (if check_2_statistic() then face_noncreature_subtype_statistic(sub: card.sub_type_2, super: card.super_type_2) else "")
	substring(result, begin: 1)
}
face_noncreature_subtype_statistic :=
{
	old_subtypes := to_text(sub)
	if old_subtypes == "" then "" else (
	
	old_subtypes := clean_subtypes_statistic(old_subtypes)
	split := split_space_statistic(old_subtypes)
	count := length(split)-1
	custom_creature_subtypes := replace_commas_statistic(set.custom_creature_races) + ";" + replace_commas_statistic(set.custom_creature_classes) + ";"
	new_subtypes := for x from 0 to count do
	(
		subtype := split[x]
		subtypesc := subtype + ";"
		if subtype == ""																			then	""
		else if contains(custom_creature_subtypes, match: subtypesc)								then	""
		else if contains(creature_subtypes_statistic, match: subtypesc)								then	""
		else if contains(land_subtypes_statistic, match: subtypesc)									then	(",​" + subtype)	# There is a zero width space after the comma so that land subtypes always appear after custom subtypes.
		else if contains(artifact_subtypes_statistic, match: subtypesc)								then	(",​​" + subtype)	# There are two zero width spaces after the comma so that artifact subtypes always appear after land subtypes, etc...
		else if contains(enchantment_subtypes_statistic, match: subtypesc)							then	(",​​​" + subtype)
		else if contains(planeswalker_subtypes_statistic, match: subtypesc)							then	(",​​​​" + subtype)
		else if contains(battle_subtypes_statistic, match: subtypesc)								then	(",​​​​​" + subtype)
		else if contains(spell_subtypes_statistic, match: subtypesc)								then	(",​​​​​​" + subtype)
		else if contains(dungeon_subtypes_statistic, match: subtypesc)								then	(",​​​​​​​" + subtype)
		else if contains(plane_subtypes_statistic, match: subtypesc)								then	(",​​​​​​​​" + subtype)
		else if contains(super, match: "Planeswalker")	or contains(super, match: "planeswalker")	then	(",​​​​" + subtype)
		else if contains(super, match: "Artifact")		or contains(super, match: "artifact")		then	(",​​" + subtype)
		else if contains(super, match: "Enchantment")	or contains(super, match: "enchantment")	then	(",​​​" + subtype)
		else if contains(super, match: "Land")			or contains(super, match: "land")			then	(",​" + subtype)
		else if contains(super, match: "Sorcery")		or contains(super, match: "sorcery")
			or	contains(super, match: "Instant")		or contains(super, match: "instant")		then	(",​​​​​​" + subtype)
		else if contains(super, match: "Battle")		or contains(super, match: "battle")			then	(",​​​​​" + subtype)
		else if contains(super, match: "Dungeon")		or contains(super, match: "dungeon")		then	(",​​​​​​​" + subtype)
		else if match_plane_statistic(super)														then	(",​​​​​​​​" + subtype)
		else																								("," + subtype)
	)
	if new_subtypes == nil then "" else new_subtypes)
}
replace_commas_statistic := replace@(match: " ?, ?", replace: ";")
split_space_statistic := split_text@(match: " ")
replace_space_statistic := replace@(match: " ", replace: "_")
replace_squote_statistic := replace@(match: "'", replace: "’")
clean_subtypes_statistic :=	replace_squote_statistic +
							replace@(match: "Bolas’s Meditation Realm", replace: "Bolas’s Meditation Realm") +		#Replace spaces within subtypes by EN spaces that won't be split (Is replaced in the list of subtypes as well.)
							replace@(match: "New Phyrexia", replace: "New Phyrexia") +
							replace@(match: "Serra’s Realm", replace: "Serra’s Realm") +
							replace@(match: "Alfava Metraxis", replace: "Alfava Metraxis") +
							replace@(match: "Androzani Minor", replace: "Androzani Minor") +
							replace@(match: "Horsehead Nebula", replace: "Horsehead Nebula") +
							replace@(match: "New Earth", replace: "New Earth") +
							replace@(match: "Outside Mutter’s Spiral", replace: "Outside Mutter’s Spiral") +
							replace@(match: "The Abyss", replace: "The Abyss") +
							replace@(match: "The Dalek Asylum", replace: "The Dalek Asylum") +
							replace@(match: "The Library", replace: "The Library") +
							replace@(match: "Unknown Planet", replace: "Unknown Planet") +
							replace@(match: "Time Lord", replace: "Time Lord")

land_subtypes_statistic :=
		"Desert;"
	+	"Forest;"
	+	"Gate;"
	+	"Island;"
	+	"Lair;"
	+	"Locus;"
	+	"Mine;"
	+	"Mountain;"
	+	"Plains;"
	+	"Power-Plant;"
	+	"Sphere;"
	+	"Swamp;"
	+	"Tower;"
	+	"Urza’s;";
artifact_subtypes_statistic :=
		"Attraction;"
	+	"Blood;"
	+	"Clue;"
	+	"Contraption;"
	+	"Equipment;"
	+	"Food;"
	+	"Fortification;"
	+	"Gold;"
	+	"Incubator;"
	+	"Powerstone;"
	+	"Treasure;"
	+	"Vehicle;";
enchantment_subtypes_statistic :=
		"Aura;"
	+	"Background;"
	+	"Cartouche;"
	+	"Class;"
	+	"Curse;"
	+	"Role;"
	+	"Rune;"
	+	"Saga;"
	+	"Shard;"
	+	"Shrine;";
planeswalker_subtypes_statistic :=
		"Ajani;"
	+	"Aminatou;"
	+	"Angrath;"
	+	"Arlinn;"
	+	"Ashiok;"
	+	"Bahamut;"
	+	"Basri;"
	+	"Bolas;"
	+	"Calix;"
	+	"Chandra;"
	+	"Comet;"
	+	"Dack;"
	+	"Dakkon;"
	+	"Daretti;"
	+	"Davriel;"
	+	"Dihada;"
	+	"Domri;"
	+	"Dovin;"
	+	"Ellywick;"
	+	"Elminster;"
	+	"Elspeth;"
	+	"Estrid;"
	+	"Freyalise;"
	+	"Garruk;"
	+	"Gideon;"
	+	"Grist;"
	+	"Guff;"
	+	"Huatli;"
	+	"Jace;"
	+	"Jared;"
	+	"Jaya;"
	+	"Jeska;"
	+	"Kaito;"
	+	"Karn;"
	+	"Kasmina;"
	+	"Kaya;"
	+	"Kiora;"
	+	"Koth;"
	+	"Liliana;"
	+	"Lolth;"
	+	"Lukka;"
	+	"Minsc;"
	+	"Mordenkainen;"
	+	"Nahiri;"
	+	"Narset;"
	+	"Niko;"
	+	"Nissa;"
	+	"Nixilis;"
	+	"Oko;"
	+	"Ral;"
	+	"Rowan;"
	+	"Saheeli;"
	+	"Samut;"
	+	"Sarkhan;"
	+	"Serra;"
	+	"Sivitri;"
	+	"Sorin;"
	+	"Szat;"
	+	"Tamiyo;"
	+	"Tasha;"
	+	"Teferi;"
	+	"Teyo;"
	+	"Tezzeret;"
	+	"Tibalt;"
	+	"Tyvar;"
	+	"Ugin;"
	+	"Urza;"
	+	"Venser;"
	+	"Vivien;"
	+	"Vraska;"
	+	"Vronos;"
	+	"Will;"
	+	"Windgrace;"
	+	"Wrenn;"
	+	"Xenagos;"
	+	"Yanggu;"
	+	"Yanling;"
	+	"Zariel;";
battle_subtypes_statistic :=
		"Siege;";
spell_subtypes_statistic :=
		"Adventure;"
	+	"Arcane;"
	+	"Lesson;"
	+	"Trap;";
dungeon_subtypes_statistic :=
		"Undercity;";
plane_subtypes_statistic :=
		"Alara;"
	+	"Alfava Metraxis;"
	+	"Amonkhet;"
	+	"Androzani Minor;"
	+	"Antausia;"
	+	"Apalapucia;"
	+	"Arcavios;"
	+	"Arkhos;"
	+	"Azgol;"
	+	"Belenon;"
	+	"Bolas’s Meditation Realm;"
	+	"Capenna;"
	+	"Cridhe;"
	+	"Darillium;"
	+	"Dominaria;"
	+	"Earth;"
	+	"Echoir;"
	+	"Eldraine;"
	+	"Equilor;"
	+	"Ergamon;"
	+	"Fabacin;"
	+	"Fiora;"
	+	"Gallifrey;"
	+	"Gargantikar;"
	+	"Gobakhan;"
	+	"Horsehead Nebula;"
	+	"Ikoria;"
	+	"Innistrad;"
	+	"Iquatana;"
	+	"Ir;"
	+	"Ixalan;"
	+	"Kaladesh;"
	+	"Kaldheim;"
	+	"Kamigawa;"
	+	"Kandoka;"
	+	"Karsus;"
	+	"Kephalai;"
	+	"Kinshala;"
	+	"Kolbahan;"
	+	"Kylem;"
	+	"Kyneth;"
	+	"Lorwyn;"
	+	"Luvion;"
	+	"Mars;"
	+	"Mercadia;"
	+	"Mirrodin;"
	+	"Moag;"
	+	"Mongseng;"
	+	"Moon;"
	+	"Muraganda;"
	+	"Necros;"
	+	"New Earth;"
	+	"New Phyrexia;"
	+	"Outside Mutter’s Spiral;"
	+	"Phyrexia;"
	+	"Pyrulea;"
	+	"Rabiah;"
	+	"Rath;"
	+	"Ravnica;"
	+	"Regatha;"
	+	"Segovia;"
	+	"Serra’s Realm;"
	+	"Shadowmoor;"
	+	"Shandalar;"
	+	"Shenmeng;"
	+	"Skaro;"
	+	"Spacecraft;"
	+	"Tarkir;"
	+	"The Abyss;"
	+	"The Dalek Asylum;"
	+	"The Library;"
	+	"Theros;"
	+	"Time;"
	+	"Trenzalore;"
	+	"Ulgrotha;"
	+	"Unknown Planet;"
	+	"Valla;"
	+	"Vryn;"
	+	"Wildfire;"
	+	"Xerex;"
	+	"Zhalfir;"
	+	"Zendikar;";
creature_subtypes_statistic :=
		"Advisor;"
	+	"Aetherborn;"
	+	"Alien;"
	+	"Ally;"
	+	"Angel;"
	+	"Antelope;"
	+	"Ape;"
	+	"Archer;"
	+	"Archon;"
	+	"Army;"
	+	"Artificer;"
	+	"Assassin;"
	+	"Assembly-Worker;"
	+	"Astartes;"
	+	"Atog;"
	+	"Aurochs;"
	+	"Avatar;"
	+	"Azra;"
	+	"Badger;"
	+	"Balloon;"
	+	"Barbarian;"
	+	"Bard;"
	+	"Basilisk;"
	+	"Bat;"
	+	"Bear;"
	+	"Beast;"
	+	"Beeble;"
	+	"Beholder;"
	+	"Berserker;"
	+	"Bird;"
	+	"Blinkmoth;"
	+	"Boar;"
	+	"Bringer;"
	+	"Brushwagg;"
	+	"Camarid;"
	+	"Camel;"
	+	"Caribou;"
	+	"Carrier;"
	+	"Cat;"
	+	"Centaur;"
	+	"Cephalid;"
	+	"Child;"
	+	"Chimera;"
	+	"Citizen;"
	+	"Cleric;"
	+	"Clown;"
	+	"Cockatrice;"
	+	"Construct;"
	+	"Coward;"
	+	"Crab;"
	+	"Crocodile;"
	+	"C’tan;"
	+	"Custodes;"
	+	"Cyberman;"
	+	"Cyclops;"
	+	"Dalek;"
	+	"Dauthi;"
	+	"Demigod;"
	+	"Demon;"
	+	"Deserter;"
	+	"Detective;"
	+	"Devil;"
	+	"Dinosaur;"
	+	"Djinn;"
	+	"Doctor;"
	+	"Dog;"
	+	"Dragon;"
	+	"Drake;"
	+	"Dreadnought;"
	+	"Drone;"
	+	"Druid;"
	+	"Dryad;"
	+	"Dwarf;"
	+	"Efreet;"
	+	"Egg;"
	+	"Elder;"
	+	"Eldrazi;"
	+	"Elemental;"
	+	"Elephant;"
	+	"Elf;"
	+	"Elk;"
	+	"Employee;"
	+	"Eye;"
	+	"Faerie;"
	+	"Ferret;"
	+	"Fish;"
	+	"Flagbearer;"
	+	"Fox;"
	+	"Fractal;"
	+	"Frog;"
	+	"Fungus;"
	+	"Gamer;"
	+	"Gargoyle;"
	+	"Germ;"
	+	"Giant;"
	+	"Gith;"
	+	"Gnoll;"
	+	"Gnome;"
	+	"Goat;"
	+	"Goblin;"
	+	"God;"
	+	"Golem;"
	+	"Gorgon;"
	+	"Graveborn;"
	+	"Gremlin;"
	+	"Griffin;"
	+	"Guest;"
	+	"Hag;"
	+	"Halfling;"
	+	"Hamster;"
	+	"Harpy;"
	+	"Hellion;"
	+	"Hippo;"
	+	"Hippogriff;"
	+	"Homarid;"
	+	"Homunculus;"
	+	"Horror;"
	+	"Horse;"
	+	"Hound;"
	+	"Human;"
	+	"Hydra;"
	+	"Hyena;"
	+	"Illusion;"
	+	"Imp;"
	+	"Incarnation;"
	+	"Inkling;"
	+	"Inquisitor;"
	+	"Insect;"
	+	"Jackal;"
	+	"Jellyfish;"
	+	"Juggernaut;"
	+	"Kavu;"
	+	"Kirin;"
	+	"Kithkin;"
	+	"Knight;"
	+	"Kobold;"
	+	"Kor;"
	+	"Kraken;"
	+	"Lamia;"
	+	"Lammasu;"
	+	"Leech;"
	+	"Leviathan;"
	+	"Lhurgoyf;"
	+	"Licid;"
	+	"Lizard;"
	+	"Lord;"
	+	"Manticore;"
	+	"Masticore;"
	+	"Mercenary;"
	+	"Merfolk;"
	+	"Metathran;"
	+	"Minion;"
	+	"Minotaur;"
	+	"Mite;"
	+	"Mole;"
	+	"Monger;"
	+	"Mongoose;"
	+	"Monk;"
	+	"Monkey;"
	+	"Moonfolk;"
	+	"Mouse;"
	+	"Mutant;"
	+	"Myr;"
	+	"Mystic;"
	+	"Naga;"
	+	"Nautilus;"
	+	"Necron;"
	+	"Nephilim;"
	+	"Nightmare;"
	+	"Nightstalker;"
	+	"Ninja;"
	+	"Noble;"
	+	"Noggle;"
	+	"Nomad;"
	+	"Nymph;"
	+	"Octopus;"
	+	"Ogre;"
	+	"Ooze;"
	+	"Orb;"
	+	"Orc;"
	+	"Orgg;"
	+	"Otter;"
	+	"Ouphe;"
	+	"Ox;"
	+	"Oyster;"
	+	"Pangolin;"
	+	"Peasant;"
	+	"Pegasus;"
	+	"Pentavite;"
	+	"Performer;"
	+	"Pest;"
	+	"Phelddagrif;"
	+	"Phoenix;"
	+	"Phyrexian;"
	+	"Pilot;"
	+	"Pincher;"
	+	"Pirate;"
	+	"Plant;"
	+	"Praetor;"
	+	"Primarch;"
	+	"Prism;"
	+	"Processor;"
	+	"Rabbit;"
	+	"Raccoon;"
	+	"Ranger;"
	+	"Rat;"
	+	"Rebel;"
	+	"Reflection;"
	+	"Rhino;"
	+	"Rigger;"
	+	"Robot;"
	+	"Rogue;"
	+	"Sable;"
	+	"Salamander;"
	+	"Samurai;"
	+	"Sand;"
	+	"Saproling;"
	+	"Satyr;"
	+	"Scarecrow;"
	+	"Scientist;"
	+	"Scion;"
	+	"Scorpion;"
	+	"Scout;"
	+	"Sculpture;"
	+	"Serf;"
	+	"Serpent;"
	+	"Servo;"
	+	"Shade;"
	+	"Shaman;"
	+	"Shapeshifter;"
	+	"Shark;"
	+	"Sheep;"
	+	"Siren;"
	+	"Skeleton;"
	+	"Slith;"
	+	"Sliver;"
	+	"Slug;"
	+	"Snake;"
	+	"Soldier;"
	+	"Soltari;"
	+	"Spawn;"
	+	"Specter;"
	+	"Spellshaper;"
	+	"Sphinx;"
	+	"Spider;"
	+	"Spike;"
	+	"Spirit;"
	+	"Splinter;"
	+	"Sponge;"
	+	"Squid;"
	+	"Squirrel;"
	+	"Starfish;"
	+	"Surrakar;"
	+	"Survivor;"
	+	"Tentacle;"
	+	"Tetravite;"
	+	"Thalakos;"
	+	"Thopter;"
	+	"Thrull;"
	+	"Tiefling;"
	+	"Time Lord;"
	+	"Treefolk;"
	+	"Trilobite;"
	+	"Triskelavite;"
	+	"Troll;"
	+	"Turtle;"
	+	"Tyranid;"
	+	"Unicorn;"
	+	"Vampire;"
	+	"Vedalken;"
	+	"Viashino;"
	+	"Volver;"
	+	"Wall;"
	+	"Walrus;"
	+	"Warlock;"
	+	"Warrior;"
	+	"Weird;"
	+	"Werewolf;"
	+	"Whale;"
	+	"Wizard;"
	+	"Wolf;"
	+	"Wolverine;"
	+	"Wombat;"
	+	"Worm;"
	+	"Wraith;"
	+	"Wurm;"
	+	"Yeti;"
	+	"Zombie;"
	+	"Zubera;";
creature_races_statistic :=
		"Aetherborn;"
	+	"Alien;"
	+	"Angel;"
	+	"Antelope;"
	+	"Ape;"
	+	"Archon;"
	+	"Assembly-Worker;"
	+	"Astartes;"
	+	"Atog;"
	+	"Aurochs;"
	+	"Avatar;"
	+	"Azra;"
	+	"Badger;"
	+	"Balloon;"
	+	"Basilisk;"
	+	"Bat;"
	+	"Bear;"
	+	"Beast;"
	+	"Beeble;"
	+	"Beholder;"
	+	"Bird;"
	+	"Blinkmoth;"
	+	"Boar;"
	+	"Bringer;"
	+	"Brushwagg;"
	+	"C’tan;"
	+	"Camarid;"
	+	"Camel;"
	+	"Caribou;"
	+	"Carrier;"
	+	"Cat;"
	+	"Centaur;"
	+	"Cephalid;"
	+	"Chimera;"
	+	"Cockatrice;"
	+	"Construct;"
	+	"Crab;"
	+	"Crocodile;"
	+	"Custodes;"
	+	"Cyberman;"
	+	"Cyclops;"
	+	"Dalek;"
	+	"Dauthi;"
	+	"Demigod;"
	+	"Demon;"
	+	"Devil;"
	+	"Dinosaur;"
	+	"Djinn;"
	+	"Dog;"
	+	"Dragon;"
	+	"Drake;"
	+	"Dreadnought;"
	+	"Drone;"
	+	"Dryad;"
	+	"Dwarf;"
	+	"Egg;"
	+	"Efreet;"
	+	"Eldrazi;"
	+	"Elemental;"
	+	"Elephant;"
	+	"Elf;"
	+	"Elk;"
	+	"Eye;"
	+	"Faerie;"
	+	"Ferret;"
	+	"Fish;"
	+	"Fox;"
	+	"Fractal;"
	+	"Frog;"
	+	"Fungus;"
	+	"Gargoyle;"
	+	"Germ;"
	+	"Giant;"
	+	"Gith;"
	+	"Gnoll;"
	+	"Gnome;"
	+	"Goat;"
	+	"Goblin;"
	+	"God;"
	+	"Golem;"
	+	"Gorgon;"
	+	"Graveborn;"
	+	"Gremlin;"
	+	"Griffin;"
	+	"Hag;"
	+	"Halfling;"
	+	"Hamster;"
	+	"Harpy;"
	+	"Hellion;"
	+	"Hippo;"
	+	"Hippogriff;"
	+	"Homarid;"
	+	"Homunculus;"
	+	"Horror;"
	+	"Horse;"
	+	"Hound;"
	+	"Human;"
	+	"Hydra;"
	+	"Hyena;"
	+	"Illusion;"
	+	"Imp;"
	+	"Incarnation;"
	+	"Inkling;"
	+	"Insect;"
	+	"Jackal;"
	+	"Jellyfish;"
	+	"Juggernaut;"
	+	"Kavu;"
	+	"Kirin;"
	+	"Kithkin;"
	+	"Kobold;"
	+	"Kor;"
	+	"Kraken;"
	+	"Lamia;"
	+	"Lammasu;"
	+	"Leech;"
	+	"Leviathan;"
	+	"Lhurgoyf;"
	+	"Licid;"
	+	"Lizard;"
	+	"Manticore;"
	+	"Masticore;"
	+	"Merfolk;"
	+	"Metathran;"
	+	"Minotaur;"
	+	"Mite;"
	+	"Mole;"
	+	"Mongoose;"
	+	"Monkey;"
	+	"Moonfolk;"
	+	"Mouse;"
	+	"Mutant;"
	+	"Myr;"
	+	"Naga;"
	+	"Nautilus;"
	+	"Necron;"
	+	"Nephilim;"
	+	"Nightmare;"
	+	"Nightstalker;"
	+	"Noggle;"
	+	"Nymph;"
	+	"Octopus;"
	+	"Ogre;"
	+	"Ooze;"
	+	"Orb;"
	+	"Orc;"
	+	"Orgg;"
	+	"Otter;"
	+	"Ouphe;"
	+	"Ox;"
	+	"Oyster;"
	+	"Pangolin;"
	+	"Pegasus;"
	+	"Pentavite;"
	+	"Pest;"
	+	"Phelddagrif;"
	+	"Phoenix;"
	+	"Phyrexian;"
	+	"Pincher;"
	+	"Plant;"
	+	"Praetor;"
	+	"Primarch;"
	+	"Prism;"
	+	"Rabbit;"
	+	"Raccoon;"
	+	"Rat;"
	+	"Reflection;"
	+	"Rhino;"
	+	"Robot;"
	+	"Sable;"
	+	"Salamander;"
	+	"Sand;"
	+	"Saproling;"
	+	"Satyr;"
	+	"Scarecrow;"
	+	"Scorpion;"
	+	"Sculpture;"
	+	"Serpent;"
	+	"Servo;"
	+	"Shade;"
	+	"Shapeshifter;"
	+	"Shark;"
	+	"Sheep;"
	+	"Siren;"
	+	"Skeleton;"
	+	"Slith;"
	+	"Sliver;"
	+	"Slug;"
	+	"Snake;"
	+	"Soltari;"
	+	"Spawn;"
	+	"Specter;"
	+	"Sphinx;"
	+	"Spider;"
	+	"Spike;"
	+	"Spirit;"
	+	"Splinter;"
	+	"Sponge;"
	+	"Squid;"
	+	"Squirrel;"
	+	"Starfish;"
	+	"Surrakar;"
	+	"Tentacle;"
	+	"Tetravite;"
	+	"Thalakos;"
	+	"Thopter;"
	+	"Thrull;"
	+	"Tiefling;"
	+	"Time Lord;"
	+	"Treefolk;"
	+	"Trilobite;"
	+	"Triskelavite;"
	+	"Troll;"
	+	"Turtle;"
	+	"Tyranid;"
	+	"Unicorn;"
	+	"Vampire;"
	+	"Vedalken;"
	+	"Viashino;"
	+	"Volver;"
	+	"Wall;"
	+	"Walrus;"
	+	"Weird;"
	+	"Werewolf;"
	+	"Whale;"
	+	"Wolf;"
	+	"Wolverine;"
	+	"Wombat;"
	+	"Worm;"
	+	"Wraith;"
	+	"Wurm;"
	+	"Yeti;"
	+	"Zombie;"
	+	"Zubera;";
creature_classes_statistic :=
		"Advisor;"
	+	"Ally;"
	+	"Archer;"
	+	"Archon;"
	+	"Army;"
	+	"Artificer;"
	+	"Assassin;"
	+	"Barbarian;"
	+	"Bard;"
	+	"Beast;"
	+	"Berserker;"
	+	"Bringer;"
	+	"Carrier;"
	+	"Child;"
	+	"Citizen;"
	+	"Cleric;"
	+	"Clown;"
	+	"Coward;"
	+	"Deserter;"
	+	"Detective;"
	+	"Doctor;"
	+	"Dreadnought;"
	+	"Drone;"
	+	"Druid;"
	+	"Egg;"
	+	"Elder;"
	+	"Employee;"
	+	"Flagbearer;"
	+	"Gamer;"
	+	"Guest;"
	+	"Horror;"
	+	"Incarnation;"
	+	"Inquisitor;"
	+	"Juggernaut;"
	+	"Knight;"
	+	"Leviathan;"
	+	"Lord;"
	+	"Mercenary;"
	+	"Minion;"
	+	"Monger;"
	+	"Monk;"
	+	"Mutant;"
	+	"Mystic;"
	+	"Ninja;"
	+	"Noble;"
	+	"Nomad;"
	+	"Peasant;"
	+	"Performer;"
	+	"Pilot;"
	+	"Pirate;"
	+	"Processor;"
	+	"Ranger;"
	+	"Rebel;"
	+	"Reflection;"
	+	"Rigger;"
	+	"Rogue;"
	+	"Samurai;"
	+	"Scientist;"
	+	"Scion;"
	+	"Scout;"
	+	"Serf;"
	+	"Shaman;"
	+	"Skeleton;"
	+	"Soldier;"
	+	"Spawn;"
	+	"Spellshaper;"
	+	"Spirit;"
	+	"Survivor;"
	+	"Thopter;"
	+	"Vampire;"
	+	"Warlock;"
	+	"Warrior;"
	+	"Werewolf;"
	+	"Wizard;"
	+	"Zombie;";

format_number_statistic :=
{
	if input == "x" or input == "y" or input == "X" or input == "Y" then input := "X"
	else if (to_number(input) or else 0) > 10 then input := "11+"
	else if (to_number(input) or else 0) < 0 then input := "negative"
	if input == "" then "" else "," + input
}
power_statistic :=
{
	fields := ["power"] +	if		not check_2_statistic()						then	[]
							else if	contains(card.shape, match: "flip")
								or	contains(card.shape, match: "split")
								or	contains(card.shape, match: "aftermath") 	then	["power_2"]
							else if	contains(card.shape, match: "double faced") then	(if contains((card.styling or else styling).front_style or else "", match: "leveler") then ["power_4"] else ["power_2"])
							else														[]
	count := length(fields) - 1
	result := for x from 0 to count do format_number_statistic(card[fields[x]])
	substring(result, begin: 1)
}
toughness_statistic :=
{
	fields := ["toughness"] +	if		not check_2_statistic()						then	[]
								else if	contains(card.shape, match: "flip")
									or	contains(card.shape, match: "split")
									or	contains(card.shape, match: "aftermath") 	then	["toughness_2"]
								else if	contains(card.shape, match: "double faced") then	(if contains((card.styling or else styling).front_style or else "", match: "leveler") then ["toughness_4"] else ["toughness_2"])
								else														[]
	count := length(fields) - 1
	result := for x from 0 to count do format_number_statistic(card[fields[x]])
	substring(result, begin: 1)
}
loyalty_statistic :=
{
	result_1 := if contains(card.super_type, match: "Planeswalker") or contains(card.super_type, match: "planeswalker") or contains(card.shape, match: "planeswalker") then trim(to_text(card.loyalty)) else ""
	result_1 := format_number_statistic(result_1)
	result_2 := if check_2_statistic() and (contains(card.super_type_2, match: "Planeswalker") or contains(card.super_type_2, match: "planeswalker")) then trim(to_text(card.loyalty_2)) else ""
	result_2 := format_number_statistic(result_2)
	substring(result_1+result_2, begin: 1)
}
defense_statistic :=
{
	result_1 := if contains(card.super_type, match: "Battle") or contains(card.super_type, match: "battle") or contains(card.shape, match: "battle") then trim(to_text(card.loyalty)) else ""
	result_1 := format_number_statistic(result_1)
	result_2 := if check_2_statistic() and (contains(card.super_type_2, match: "Battle") or contains(card.super_type_2, match: "battle")) then trim(to_text(card.loyalty_2)) else ""
	result_2 := format_number_statistic(result_2)
	substring(result_1+result_2, begin: 1)
}

# Should we check the secondary face of the card, like the card.casting_cost_2 or card.type_2 fields?
check_2_statistic :=
{
	(chosen(set.count_secondary_faces, choice: "MDFC")		and contains(card.shape, match: "modal")) or
	(chosen(set.count_secondary_faces, choice: "TDFC")		and contains(card.shape, match: "transform")) or
	(chosen(set.count_secondary_faces, choice: "TDFC")		and contains(card.shape, match: "double faced")	and not contains(card.shape, match: "modal") and not contains(card.shape, match: "transform")) or
	(chosen(set.count_secondary_faces, choice: "Aftermath")	and contains(card.shape, match: "aftermath")) or
	(chosen(set.count_secondary_faces, choice: "Adventure")	and contains(card.shape, match: "adventure")) or
	(chosen(set.count_secondary_faces, choice: "Flip")		and contains(card.shape, match: "flip")) or
	(chosen(set.count_secondary_faces, choice: "Split")		and contains(card.shape, match: "split"))
}

# Should we check the card.rule_text_X fields, or the card.level_X_text fields?
text_to_check_statistic :=
{
	if contains(card.shape, match: "double faced") then
	(
		front := (card.styling or else styling).front_style or else ""
		if contains(front, match: "planeswalker") or contains(front, match: "leveler") or contains(card.shape, match: "planeswalker") or contains(card.shape, match: "leveler") then
		[
			"level_1_text",
			"level_2_text",
			"level_3_text",
			"level_4_text",
			"rule_text_3"
		]
		else if contains(front, match: "saga") then
		[
			"chapter_text",
			"level_1_text",
			"level_2_text",
			"level_3_text",
			"level_4_text",
			"rule_text_3"
		]
		else if contains(front, match: "class") then
		[
			"chapter_text",
			"level_1_text",
			"level_2_text",
			"level_3_text",
			"level_4_text",
			"level_9_text",
			"level_10_text",
			"level_11_text",
			"rule_text_3"
		]
		else
		[
			"rule_text",
			"rule_text_3"
		]
	)
	else if contains(card.shape, match: "planeswalker") then
	[
		"level_1_text",
		"level_2_text",
		"level_3_text",
		"level_4_text",
		"level_5_text",
		"level_6_text",
		"rule_text_3"
	]
	else if contains(card.shape, match: "leveler") then
	[
		"level_1_text",
		"level_2_text",
		"level_3_text",
		"level_4_text",
		"level_5_text",
		"rule_text_3"
	]
	else if contains(card.shape, match: "saga") then
	[
		"chapter_text",
		"level_1_text",
		"level_2_text",
		"level_3_text",
		"level_4_text",
		"level_5_text",
		"level_6_text",
		"level_7_text",
		"rule_text_3"
	]
	else if contains(card.shape, match: "class") then
	[
		"chapter_text",
		"level_1_text",
		"level_2_text",
		"level_3_text",
		"level_4_text",
		"level_5_text",
		"level_6_text",
		"level_7_text",
		"level_9_text",
		"level_10_text",
		"level_11_text",
		"level_12_text",
		"level_13_text",
		"level_14_text",
		"rule_text_3"
	]
	else if contains(card.shape, match: "split") then
	[
		"rule_text",
		"rule_text_3"
	]
	else if has_mutate_text_statistic(card: card) then
	[
		"rule_text",
		"level_1_text"
	]
	else # if contains(card.shape, match: "normal") or contains(card.shape, match: "adventure") or contains(card.shape, match: "flip") or contains(card.shape, match: "aftermath") then
	[
		"rule_text"
	]
}
text_to_check_2_statistic :=
{
	if contains(card.shape, match: "double faced") then
	(
		back := (card.styling or else styling).back_style or else ""
		if contains(back, match: "planeswalker") or contains(back, match: "leveler") then
		[
			"level_5_text",
			"level_6_text",
			"level_7_text",
			"level_8_text"
		]
		else if contains(back, match: "saga") then
		[
			"chapter_text_2",
			"level_5_text",
			"level_6_text",
			"level_7_text",
			"level_8_text"
		]
		else if contains(back, match: "class") then
		[
			"chapter_text_2",
			"level_5_text",
			"level_6_text",
			"level_7_text",
			"level_8_text",
			"level_12_text",
			"level_13_text",
			"level_14_text"
		]
		else
		[
			"rule_text_2"
		]
	)
	else if contains(card.shape, match: "adventure") or contains(card.shape, match: "flip") or contains(card.shape, match: "aftermath") or contains(card.shape, match: "split") then
	[
		"rule_text_2"
	]
	else # if contains(card.shape, match: "normal") or contains(card.shape, match: "planeswalker") or contains(card.shape, match: "leveler") or contains(card.shape, match: "saga") or contains(card.shape, match: "class")
	[
	]
}
has_mutate_text_statistic :=
{
	contains(card.shape, match: "normal") and
	contains((card.styling or else styling).frames or else "", match: "mutate") and
	card.level_1_text != "" and
	card.level_1_text != card.rule_text
}

#Is the given text field visible on the card? This would be much better than the above methods to know which fields to check, but card_style does not initialize properly, so it's not usable atm.
#is_field_visible_statistic :=
#{
#	style := card_style[input]
#	style.visible and
#	min(stylesheet.card_width, style.right) - max(0, style.left) > stylesheet.card_width/70 and		#Field needs to take up a certain percentage of the total card to be considered visible.
#	min(stylesheet.card_height, style.bottom) - max(0, style.top) > stylesheet.card_width/80
#}

# Should the card be excluded from the statistics?
filter_from_statistic :=
{
	if set.filter_statistics == "" then "Kept" else (
	initial := escape_quotes_filter_statistics(replace_squote_statistic(set.filter_statistics))
	negate := if initial.0 == "!" then (initial := substring(initial, begin:1); true) else false
	initial_filters := get_filter_values_statistic(initial)
	initial_keys := get_filter_keys_statistic(initial)
	initial_modes := get_filter_modes_statistic(initial)
	count := length(initial_filters)-1
	if count != length(initial_keys)-1 or count != length(initial_modes)-1 then "!! Failed to parse filters !!" else (
	fields := []
	filters := []
	keys := []
	modes := []
	for x from 0 to count do
	(
		key := trim(initial_keys[x])
		mode := initial_modes[x]
		field :=		if		key == "artist" then			card.illustrator
						else if	key == "artist_2"
							or	key == "artist 2" then			card.illustrator_2
						else if	key == "color"
							or	key == "colors" then			color_statistic()
						else if	key == "color_identity"
							or	key == "color identity" then	color_identity_statistic()
						else if	key == "mana_value"
							or	key == "mana value"
							or	key == "cmc" then				cmc(card.casting_cost)
						else if	key == "card_notes"
							or	key == "card notes"
							or	key == "sorted_notes"
							or	key == "sorted notes" then		card.notes
						else									(card[key] or else card[replace_space_statistic(key)]) or else nil
		filter :=		if		key == "color"
							or	key == "colors"
							or	key == "color_identity"
							or	key == "color identity" then	(	colors := distil_color_filter_statistic(initial_filters[x])
																	if mode == "==" or mode == "!=" then	colors
																	else									(field := sort_text(field, order:colors); colors))
						else									remove_quotes_statistic(initial_filters[x])
		fields := fields + [escape_quotes_field_statistics(replace_squote_statistic(field))]
		filters := filters + [filter]
		keys := keys + [key]
		modes := modes + [mode]
	)
	message := "Kept"
	for x from 0 to count do
	(
		if message == "Kept" or message == "Filtered" then (
		if fields[x] == nil then message := "!! Could not find card field named [ " + keys[x] + " ] !!" else (
		field := trim(remove_tags(fields[x]))
		filter := filters[x]
		key := keys[x]
		mode := modes[x]
		if		(mode == "==" and field != filter)
			or	(mode == "!=" and field == filter)
			or	(mode == "=:" and not contains(to_lower(field), match: to_lower(filter)))
			or	(mode == "!:" and contains(to_lower(field), match: to_lower(filter)))		then message := "Filtered"
		else if (mode == "\<=" or mode == ">=") and field != ""								then (	field_number := to_number(field) or else nil
																									filter_number := to_number(filter) or else nil
																									if		field_number == nil									then message := "!! Could not convert the value of card field [ " + key + " ] to a number !!"
																									else if	filter_number == nil								then message := "!! Could not convert the value of filter [ " + key + mode + "\"" + unescape_quotes_filter_statistics(filter) + "\" ] to a number !!"
																									else if	(mode == "\<=" and field_number > filter_number)
																										or	(mode == ">=" and field_number < filter_number)		then message := "Filtered")))
	)
	if		message == "Filtered" and negate then	"Kept"
	else if	message == "Kept" and negate then		"Filtered"
	else											message))
}
unescape_quotes_filter_statistics := replace@(match: "\\[\\[quoteescape\\]\\]", replace: "\\\\\"")
escape_quotes_filter_statistics := replace@(match: "(\\\\\")|“|”", replace: "[[quoteescape]]")
escape_quotes_field_statistics := replace@(match: "(\\\")|“|”", replace: "[[quoteescape]]")
get_filter_values_statistic := trim + break_text@(match: "\"[^\"]*\"")
get_filter_keys_statistic := trim + replace@(match: "\"[^\"]*\"", replace: "") + replace@(match: "=:|!:|==|!=|\<=|>=", replace: "") + split_text@(match: ", ?")
get_filter_modes_statistic := trim + replace@(match: "\"[^\"]*\"", replace: "") + break_text@(match: "=:|!:|==|!=|\<=|>=")
distil_color_filter_statistic :=
{
	filter := distil_color_words_statistic(input)
	if filter == "" then distil_colors_statistic(input) else filter
}
remove_quotes_statistic := replace@(match: "\"", replace: "")

trim_from_statistic :=
{
	if set.trim_statistics then
	(
			card.shape == "token"
		or	card.shape == "emblem"
		or	card.rarity == "special"
		or	card.rarity == "masterpiece"
		or	contains(card.type, match: "token")
		or	contains(card.type, match: "Token")
		or	contains(card.type, match: "emblem")
		or	contains(card.type, match: "Emblem")
		or	contains(card.type, match: "dungeon")
		or	contains(card.type, match: "Dungeon")
		or	contains(card.type, match: "hero")
		or	contains(card.type, match: "Hero")
		or	contains(card.type, match: "conspiracy")
		or	contains(card.type, match: "Conspiracy")
		or	contains(card.type, match: "vanguard")
		or	contains(card.type, match: "Vanguard")
		or	contains(card.type, match: "scheme")
		or	contains(card.type, match: "Scheme")
		or	contains(card.type, match: "phenomenon")
		or	contains(card.type, match: "Phenomenon")
		or	match_plane_statistic(card.type)
	)
	else false
}

trim_from_draw_statistic :=
{
			contains(card.notes, match: "commander")
		or	contains(card.notes, match: "Commander")
		or	(set.trim_statistics and (card.rarity == "special" or card.rarity == "masterpiece"))
		or	card.shape == "token"
		or	card.shape == "emblem"
		or	contains(card.type, match: "token")
		or	contains(card.type, match: "Token")
		or	contains(card.type, match: "emblem")
		or	contains(card.type, match: "Emblem")
		or	contains(card.type, match: "Hero")
		or	contains(card.type, match: "hero")
		or	contains(card.type, match: "dungeon")
		or	contains(card.type, match: "Dungeon")
		or	contains(card.type, match: "conspiracy")
		or	contains(card.type, match: "Conspiracy")
		or	contains(card.type, match: "vanguard")
		or	contains(card.type, match: "Vanguard")
		or	contains(card.type, match: "scheme")
		or	contains(card.type, match: "Scheme")
		or	contains(card.type, match: "phenomenon")
		or	contains(card.type, match: "Phenomenon")
		or	match_plane_statistic(card.type)
		or	filter_from_statistic(card: card) == "Filtered"
}

statistics_info :=
{
	trace("
	
	[[STATISTICS HELP]]
	
	If some cards are improperly counted, reloading the data via the File menu may correct it.
	If the program seems to count things that are not present on a card, it may be picking up on remnants from when the card used another template.
	Temporarily switch to a DFC template or a leveler template and delete any info that is not necessary on the current version of the card.
	
	
	
	[[SET INFO TAB]]
	
	Trim statistics:
	
	This option will exclude the following cards from being counted in the statistics:
	
	- cards with special rarity
	- cards with masterpiece rarity
	- tokens
	- emblems
	- dungeons
	- conspiracies
	- heroes
	- vanguards
	- schemes
	- planes
	- phenomenons
	
	
	
	Filter statistics:
	
	This lets you more precisely exclude cards from being counted.
	The syntax is as follows:
	
	field_name==\"value\"
	
	So for example if you write:
	
	notes==\"Removal\"
	
	the stats page will only count cards for which the notes are precisely 'Removal' and nothing else.
	You can use != for strict inequality, so for example if you write:
	
	notes!=\"Removal\"
	
	the stats page will only count cards for which the notes are not precisely 'Removal' and nothing else.
	Use =: to check if the field contains the value, so for example if you write:
	
	sub_type=:\"goblin\"
	
	the stats page will only count cards that have 'goblin' among their subtypes.
	Use !: to exclude, so write:
	
	sub_type!:\"goblin\"
	
	and the stats page will not count cards that have 'goblin' among their subtypes.
	Use >= and <= for quantities that are numeric, so stuff like:
	
	mana_value>=\"6\"
	
	toughness<=\"3\"
	
	This will not filter cards that have no toughness. In other words, it will keep all cards that have 3 or less toughness, and also keep all cards that don't have toughness.
	To keep only cards that have toughness AND have 3 or less toughness, you would write:
	
	toughness<=\"3\", toughness!=\"\"
	
	You can write multiple criteria by separating them with a comma, so:
	
	rule_text=:\"deathtouch\", sub_type!:\"snake\"
	
	will only count cards that contain 'deathtouch' in their rule text, AND that are not snakes.
	You can negate the entire filter by prepending '!'. So if you write:
	
	!color!=\"R\",color!=\"G\"
	
	this will keep all the cards that contain either red or green among their colors, because of the following identity: R or G = not ( not R and not G )
	If you search for \" quotes, you must escape them with \\. For example:
	
	rule_text=:\"Creatures you control gain \\\"T: Add G.\\\" until end of turn.\"
	
	
	
	Count secondary faces:
	
	This option allows the stats page to count the back faces of DFC cards, the adventure on adventure cards, both halves of a split card, etc...
	Some things like color never take into account the secondary faces, regardless of what is chosen here.
	Some things like color identity always take into account the secondary faces.
	
	
	
	Custom super types:
	
	If your set uses custom super types, write them all in this field, separated by commas. Otherwise, they will be counted as types.
	
	
	
	Custom creature races/classes:
	
	If your set uses custom creature sub types, write them all in these fields, separated by commas. Otherwise, they will be counted as non-creature sub types.
	Some sub types can be auto-detected if they appear on a card that has no other types than creature, but this might miss a few.
	Some ambiguous canon sub types like Zombie are counted as both a race and a class. If you want them to only count in one category, add them to the corresponding field.
	
	
	
	[[STATISTICS TAB]]
	
	Color:
	
	The color as defined by the comprehensive rules. Never takes into account the back side or secondary face (like on adventures for example),
	except for split cards and aftermath cards.
	
	
	
	Color Identity:
	
	The commander color identity as defined by the comprehensive rules. Always takes into account all sides and faces of the card.
	
	
	
	Casting Cost, Mana Value:
	
	Self explanatory. Counts each side/face separately, if the option is checked in the Set info tab.
	
	
	
	Casting Costs Pips:
	
	Counts how many cards have a single white pip in their casting cost. Repeat for two white pips. Then three, then four+, then for all other colors.
	Counts each side/face separately if the option is checked.
	
	
	
	Cast. Costs Pips Totals:
	
	Counts the total number of white pips in all the casting costs. Repeat for all other colors.
	
	
	
	Ability Costs Pips:
	
	Counts how many activated/triggered/keyworded abilities have a single white pip in their cost. Repeat for two white pips. Then three, then four+, then for all other colors.
	Counts each ability on each side/face separately.
	
	
	
	Abil. Costs Pips Totals:
	
	Counts the total number of white pips in all the activated/triggered/keyworded ability costs. Repeat for all other colors.
	
	
	
	All Costs Pips:
	
	Counts how many costs contain a single white pip. Repeat for two white pips. Then three, then four+, then for all other colors. Counts each cost on each side/face separately.
	
	
	
	All Costs Pips Totals:
	
	Counts the total number of white pips in all the costs. Repeat for all other colors.
	
	
	
	Land Mana Production:
	
	Counts how many lands can produce white mana. Repeat for all other colors. Then counts how many lands can produce mana of any color, and mana of a chosen color.
	
	
	
	Nonland Mana Production
	Same as above but for nonland cards.
	
	
	
	All Mana Production:
	
	Sum of the two fields above.
	
	
	
	Permanent/Nonperm:
	
	Counts the number of creatures, noncreature permanents, and nonpermanents. Counts each side/face separately.
	
	
	
	Card Notes Words:
	
	Counts each word that appears in the card notes field.
	
	
	
	Card Notes Clauses:
	
	Cuts the card notes using the regex specified in the set info tab. By default, it will cut at each dot, each new line, each semicolon, each comma and before each exclamation mark.
	So for example, if you write 'Removal, Board Wipe; Draw' the card will count in the 'Removal' category, the 'Board Wipe' category and the 'Draw' category.
	You can make whatever categories you like.
	
	
	
	Land Drop Hit % (Play):
	
	If the set is a deck, probability of hitting every single land drop up to the given turn, when on the play. Always excludes cards with the word 'commander' in their card notes,
	as well as tokens, emblems, dungeons, conspiracies, heroes, vanguards, schemes, planes and phenomenons.
	
	
	
	Land Drop Hit % (Draw):
	
	Same as above, but when on the draw.
	
	
	
	Average Opening Hand:
	
	If the set is a deck, how many cards of each type will an opening hand contain on average.
	!! This statistic only properly updates when the program is reloaded, or when a card is added or removed from the set !!
	
	
	
	Color Count:
	
	How many cards have one color, how many have two, three, etc...
	
	
	
	Color Identity Count:
	
	How many cards have one color in their color identity, how many have two, three, etc...
	
	
	
	Color (Secondary Face):
	
	Color of the back side or secondary face (like on adventures for example).
	
	
	
	Color (All Faces):
	
	Combined color of all the sides/faces.
	
	
	
	Color (Promos):
	
	Color of cards with 'special' or 'masterpiece' rarity.
	
	
	
	Omniverse Color:
	
	Same as color category, but counts extended colors (Purple, Pink, Yellow, Orange, Brown)
	
	
	
	Cast. Costs Pips Count:
	
	Counts the number of casting costs that contain one colored pip. Repeat for all other amounts.
	
	
	
	Abil. Costs Pips Count:
	
	Counts the number of activated/triggered/keyworded ability costs that contain one colored pip. Repeat for all other amounts.
	
	
	
	All Costs Pips Count:
	
	Counts the number of costs that contain one colored pip. Repeat for all other amounts.
	
	
	
	Filter:
	
	Shows which cards have been filtered by the criteria in the 'Filter statistics' field of the Set info tab, or displays error messages if the criteria could not be parsed.
	
	
	
	(Scroll up to see the beginning)
	")
}
statistics_help :=
{
	statistics_info()
}
